/*
 * File: Model_Target.c
 *
 * Code generated for Simulink model 'Model_Target'.
 *
 * Model version                  : 1.70
 * Simulink Coder version         : 9.8 (R2022b) 13-May-2022
 * C/C++ source code generated on : Wed Mar  6 16:05:06 2024
 *
 * Target selection: ert_shrlib.tlc
 * Embedded hardware selection: Qualcomm->Hexagon
 * Emulation hardware selection:
 *    Differs from embedded hardware (MATLAB Host)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "Model_Target.h"
#include "rtwtypes.h"
#include "Model_Target_private.h"
#include <string.h>
#include "qhmath.h"
#include <math.h>
#include "Model_Target_types.h"
#include "circbuf.h"
#include "pooliir_hexagon.h"
#include "qhblas.h"
#include "qhcomplex.h"
#include "qhdsp.h"
#include "qhdsp_common.h"
#include "qhdsp_iir.h"
#include "PostProcess.h"
#include "MedusaExpandTailComps.h"
#include "fir_hexagon.h"
#include "blkutil.h"
#include "qhdsp_fft_internal.h"
#include "rfft_hexagon.h"
#include "fireven_hexagon.h"
#include "qhl_common.h"
#include "Ifir.h"
#include "MedusaPostHoligram.h"
#include "rt_sys_Enabled_530.h"
#include "rt_sys_Enabled_543.h"
#include "rt_sys_Enabled_536.h"
#include "rt_sys_Enabled_535.h"
#include "Enabled.h"
#include "VLS.h"
#include "Model_Target_MedusaDelays.h"
#include "PoolDelayStorage.h"
#include "Model_Target_FirGenericStorage.h"
#include "Model_Target_MedusaHoligramEq.h"
#include "FFTBuffers.h"
#include "FirStorage.h"
#include "tsp_capture_settings.h"

/* Named constants for MATLAB Function: '<S491>/InnerLink' */
#define Model_Target_SuperFastDecayMultiplier (3.0F)

/* Named constants for MATLAB Function: '<S1814>/InnerLink' */
#define Model_Target_SuperFastDecayMultiplier_m (30.0F)

/* Named constants for MATLAB Function: '<S1191>/Delay Line Update' */
#define Model_Target_fixedDelayLength  (660)

/* Named constants for MATLAB Function: '<S1193>/Delay Line Update' */
#define Model_Target_fixedDelayLength_l (540)

/* Named constants for MATLAB Function: '<S716>/Detect Impulse' */
#define Model_Target_MaxValueOfCounterForDetectingImpulse (4.0)

/* Named constants for MATLAB Function: '<S800>/Detect Impulse' */
#define Model_Target_MaxValueOfCounterForDetectingImpulse_n (16.0)

/* Named constants for MATLAB Function: '<S835>/Mono Detector' */
#define Model_Target_maxZeroLevelCount (693.0)

/* Exported data definition */

/* Definition for custom storage class: ExportToFile */
real32_T DeciRateBassDelay[1482];      /* '<S891>/Data Store Memory' */
real32_T DeciRateSpeakerDelay[10170];  /* '<S1290>/Data Store Memory' */
real32_T FullRateBassDelay[70];        /* '<S892>/Data Store Memory' */
real32_T FullRateSpeakerDelay[30822];  /* '<S1291>/Data Store Memory' */
real32_T MidrangeDelay[1392];          /* '<S890>/Data Store Memory' */
real32_T PeripheralDelayBuffer[11880]; /* '<S1191>/Data Store Memory' */
real32_T TrebleDelay[8552];            /* '<S652>/Data Store Memory' */

/* Block signals (default storage) */
B_Model_Target_T Model_Target_B;

/* Block states (default storage) */
DW_Model_Target_T Model_Target_DW;

/* Real-time model */
static RT_MODEL_Model_Target_T Model_Target_M_;
RT_MODEL_Model_Target_T *const Model_Target_M = &Model_Target_M_;

/* Forward declaration for local functions */
static void Model_Target_sum(const real32_T x_data[], const int32_T x_size[2],
    real32_T y[8]);

/* Forward declaration for local functions */
static void Model_Target_Mixer(const real32_T audioIn[8], const real32_T loc[2],
    const real32_T gainMatrix[25], real_T interp, real32_T mixOut[8]);
static void Model_Target_Mixer_k(const real32_T audioIn[32], const real32_T loc
    [2], const real32_T gainMatrix[25], real_T interp, real32_T mixOut[32]);
static real32_T Model_Target_interp1(const real32_T varargin_1[2], const
    real32_T varargin_2[2], real32_T varargin_3);
static void Model_Target_eml_find_a(const boolean_T x[2], int32_T i_data[],
    int32_T i_size[2]);
static real32_T Model_Target_mod(real32_T x, real32_T y);
static real32_T Model_Target_interp1_m(const real32_T varargin_1[128], const
    real32_T varargin_2[128], real32_T varargin_3);
static void rate_monotonic_scheduler(void);

/* Declare variables for internal data of system '<S586>/Alignment Delay' */
B_AlignmentDelay_Model_Target_T Model_Target_AlignmentDelay_B;
DW_AlignmentDelay_Model_Target_T Model_Target_AlignmentDelay_DW;

/* Declare variables for internal data of system '<S558>/Medusa5H1 Part 3' */
B_Medusa5H1Part3_Model_Target_T Model_Target_Medusa5H1Part3_B;
DW_Medusa5H1Part3_Model_Target_T Model_Target_Medusa5H1Part3_DW;

/* Declare variables for internal data of system '<S558>/Medusa5H1 Part 4' */
B_Medusa5H1Part4_Model_Target_T Model_Target_Medusa5H1Part4_B;
DW_Medusa5H1Part4_Model_Target_T Model_Target_Medusa5H1Part4_DW;

/* Declare variables for internal data of system '<S558>/Medusa5H1 Part 5' */
B_Medusa5H1Part5_Model_Target_T Model_Target_Medusa5H1Part5_B;
DW_Medusa5H1Part5_Model_Target_T Model_Target_Medusa5H1Part5_DW;

/* Declare variables for internal data of system '<S558>/Medusa5H1 Part 6' */
B_Medusa5H1Part6_Model_Target_T Model_Target_Medusa5H1Part6_B;
DW_Medusa5H1Part6_Model_Target_T Model_Target_Medusa5H1Part6_DW;

/* Declare variables for internal data of system '<S4>/PreAmpPart1' */
B_PreAmpPart1_Model_Target_T Model_Target_PreAmpPart1_B;
DW_PreAmpPart1_Model_Target_T Model_Target_PreAmpPart1_DW;

// PreAmpMedusaSurroundLevelControlIndex RTC Request-Response Handler (RTC ID 0x15200001) '<S1113>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaSurroundLevelControlIndex(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S1113>/Request' */

    /* S-Function (RTC_BytePack): '<S1121>/UnpackREQ' */
    PreAmpMedusaSurroundLevelControlIndex_REQ_T* payloadREQ =
        (PreAmpMedusaSurroundLevelControlIndex_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index =
        payloadREQ->surround_index;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second
        = payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds
        = payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaSurroundLevelControlIndex();

    /* Output and update for function-call system: '<S1113>/Response' */

    /* S-Function (RTC_BytePack): '<S1122>/PackRSP' */
    PreAmpMedusaSurroundLevelControlIndex_RSP_T* payloadRSP =
        (PreAmpMedusaSurroundLevelControlIndex_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->surround_index =
        Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaSurroundLevelControlIndex RTC NTF check complete '<S1113>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpMedusaSurroundLevelControlIndex( void )
{
    /* Output and update for function-call system: '<S1113>/NtfCheck' */
    {
        int32_T i;
        boolean_T done;
        boolean_T done_c;
        boolean_T done_f;
        boolean_T done_h;
        boolean_T done_i;
        boolean_T done_k;
        boolean_T done_kk;
        boolean_T done_n;
        boolean_T exitg1;

        /* MATLAB Function: '<S998>/Split NTF_check_done' */
        /* MATLAB Function: '<S998>/Split NTF_check_done' incorporates:
         *  MATLAB Function: '<S1073>/check sequence'
         */
        /* MATLAB Function: '<S1073>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1118>:1' */
        /* '<S1118>:1:3' go(); */
        /*  #codegen */
        /*  Splits the incoming function call */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Split NTF_check_done': '<S1009>:1' */
        /* '<S1009>:1:4' fcncall_Left(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Ramper/check sequence': '<S1078>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1078>:1:8' done = true; */
        done_i = true;

        /* '<S1078>:1:10' for i=1:numel(Premix_targetGain_Left) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 77))
        {
            /* '<S1078>:1:11' if (Premix_targetGain_Left(i) ~= Premix_currentGain_Left(i)) */
            if (Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left[i] !=
                    Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left[i])
            {
                /* '<S1078>:1:12' done = false; */
                done_i = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S998>/Split NTF_check_done' incorporates:
         *  MATLAB Function: '<S1061>/check sequence'
         */
        /* MATLAB Function: '<S1061>/check sequence' */
        /* '<S1009>:1:5' fcncall_CS(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/check sequence': '<S1066>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1066>:1:8' done = true; */
        done_n = true;

        /* '<S1066>:1:10' for i=1:numel(Premix_targetGain_CS) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 20))
        {
            /* '<S1066>:1:11' if (Premix_targetGain_CS(i) ~= Premix_currentGain_CS(i)) */
            if (Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS[i] !=
                    Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[i])
            {
                /* '<S1066>:1:12' done = false; */
                done_n = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S998>/Split NTF_check_done' incorporates:
         *  MATLAB Function: '<S1085>/check sequence'
         */
        /* MATLAB Function: '<S1085>/check sequence' */
        /* '<S1009>:1:6' fcncall_Right(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Ramper/check sequence': '<S1090>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1090>:1:8' done = true; */
        done_h = true;

        /* '<S1090>:1:10' for i=1:numel(Premix_targetGain_Right) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 77))
        {
            /* '<S1090>:1:11' if (Premix_targetGain_Right(i) ~= Premix_currentGain_Right(i)) */
            if (Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right[i] !=
                    Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right[i])
            {
                /* '<S1090>:1:12' done = false; */
                done_h = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S931>/MATLAB Function' */
        /* MATLAB Function: '<S931>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S964>/check sequence'
         */
        /* MATLAB Function: '<S964>/check sequence' */
        /* '<S1009>:1:7' fcncall_AND(); */
        /*  #codegen */
        /*  Splits the incoming function call */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/MATLAB Function': '<S939>:1' */
        /* '<S939>:1:4' fcncall_Left(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Ramper/check sequence': '<S969>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S969>:1:7' done = true; */
        done_kk = true;

        /* '<S969>:1:9' for i=1:numel(FRM_targetGain_Left) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 30))
        {
            /* '<S969>:1:10' if (FRM_targetGain_Left(i) ~= FRM_currentGain_Left(i)) */
            if (Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left[i] !=
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i])
            {
                /* '<S969>:1:11' done = false; */
                done_kk = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S931>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S952>/check sequence'
         */
        /* MATLAB Function: '<S952>/check sequence' */
        /* '<S939>:1:5' fcncall_CS(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/check sequence': '<S957>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S957>:1:7' done = true; */
        done_k = true;

        /* '<S957>:1:9' for i=1:numel(FRM_targetGain_CS) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 12))
        {
            /* '<S957>:1:10' if (FRM_targetGain_CS(i) ~= FRM_currentGain_CS(i)) */
            if (Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS[i] !=
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS[i])
            {
                /* '<S957>:1:11' done = false; */
                done_k = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S931>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S976>/check sequence'
         */
        /* MATLAB Function: '<S976>/check sequence' */
        /* '<S939>:1:6' fcncall_Right(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Ramper/check sequence': '<S981>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S981>:1:7' done = true; */
        done_f = true;

        /* '<S981>:1:9' for i=1:numel(FRM_targetGain_Right) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 30))
        {
            /* '<S981>:1:10' if (FRM_targetGain_Right(i) ~= FRM_currentGain_Right(i)) */
            if (Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right[i] !=
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i])
            {
                /* '<S981>:1:11' done = false; */
                done_f = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1143>/check sequence' */
        /* MATLAB Function: '<S1143>/check sequence' */
        /* '<S939>:1:7' fcncall_AND(); */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/check sequence': '<S1146>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1146>:1:8' done = true; */
        done_c = true;

        /* '<S1146>:1:10' for i=1:numel(VLSDrv_targetGain) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 12))
        {
            /* '<S1146>:1:11' if (VLSDrv_targetGain(i) ~= VLSDrv_currentGain(i)) */
            if (Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain[i] !=
                    Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain[i])
            {
                /* '<S1146>:1:12' done = false; */
                done_c = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* MATLAB Function: '<S1168>/check sequence' */
        /* MATLAB Function: '<S1168>/check sequence' */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Ramper/check sequence': '<S1171>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1171>:1:8' done = true; */
        done = true;

        /* '<S1171>:1:10' for i=1:numel(VLSPax_targetGain) */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 12))
        {
            /* '<S1171>:1:11' if (VLSPax_targetGain(i) ~= VLSPax_currentGain(i)) */
            if (Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain[i] !=
                    Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain[i])
            {
                /* '<S1171>:1:12' done = false; */
                done = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S897>/Merge NTF_done' */
        /* MATLAB Function: '<S998>/Split NTF_check_done' */
        /* MATLAB Function: '<S998>/Split NTF_check_done' incorporates:
         *  SubSystem: '<S998>/Merge NTF_done'
         */
        /* MATLAB Function: '<S931>/MATLAB Function' */
        /* MATLAB Function: '<S931>/MATLAB Function' incorporates:
         *  SubSystem: '<S931>/Merge NTF_done'
         */
        /* Logic: '<S1109>/AND' incorporates:
         *  Logic: '<S1007>/AND'
         *  Logic: '<S940>/AND'
         */
        Model_Target_Medusa5H1Part3_B.AND = (done_h && done_n && done_i &&
            (done_f && done_k && done_kk) && done_c && done);

        /* End of Outputs for SubSystem: '<S897>/Merge NTF_done' */

        /* Outputs for Function Call SubSystem: '<S1110>/NTF_SLC' */
        /* SignalConversion generated from: '<S1112>/In1' */
        Model_Target_Medusa5H1Part3_B.In1 =
            Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index;

        /* End of Outputs for SubSystem: '<S1110>/NTF_SLC' */
    }
}

// PreAmpMedusaSurroundLevelControlIndex RTC NTF message preparation and packing '<S1113>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpMedusaSurroundLevelControlIndex(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1113>/Notification' */

    /* S-Function (RTC_BytePack): '<S1117>/PackNTF' */
    PreAmpMedusaSurroundLevelControlIndex_NTF_T* payloadNTF =
        (PreAmpMedusaSurroundLevelControlIndex_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->surround_index = Model_Target_Medusa5H1Part3_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpMedusaSurroundLevelControlReset RTC Request-Response Handler (RTC ID 0x15210002) '<S1114>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaSurroundLevelControlReset(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S1114>/Request' */

    /* S-Function (RTC_BytePack): '<S1127>/UnpackREQ' */
    PreAmpMedusaSurroundLevelControlReset_REQ_T* payloadREQ =
        (PreAmpMedusaSurroundLevelControlReset_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaSurroundLevelControlResetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaSurroundLevelControlReset();

    /* Output and update for function-call system: '<S1114>/Response' */

    /* S-Function (RTC_BytePack): '<S1128>/PackRSP' */
    PreAmpMedusaSurroundLevelControlReset_RSP_T* payloadRSP =
        (PreAmpMedusaSurroundLevelControlReset_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaSurroundLevelControlResetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaPostUpmixDisable RTC Request-Response Handler (RTC ID 0x15210000) '<S889>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaPostUpmixDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S889>/Request' */

    /* S-Function (RTC_BytePack): '<S1185>/UnpackREQ' */
    PreAmpMedusaPostUpmixDisable_REQ_T* payloadREQ =
        (PreAmpMedusaPostUpmixDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaPostUpmixDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaPostUpmixDisable();

    /* Output and update for function-call system: '<S889>/Response' */

    /* S-Function (RTC_BytePack): '<S1186>/PackRSP' */
    PreAmpMedusaPostUpmixDisable_RSP_T* payloadRSP =
        (PreAmpMedusaPostUpmixDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaPostUpmixDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaHoligramDisable RTC Request-Response Handler (RTC ID 0x16210000) '<S1190>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaHoligramDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1190>/Request' */

    /* S-Function (RTC_BytePack): '<S1276>/UnpackREQ' */
    PreAmpMedusaHoligramDisable_REQ_T* payloadREQ =
        (PreAmpMedusaHoligramDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaHoligramDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaHoligramDisable();

    /* Output and update for function-call system: '<S1190>/Response' */

    /* S-Function (RTC_BytePack): '<S1277>/PackRSP' */
    PreAmpMedusaHoligramDisable_RSP_T* payloadRSP =
        (PreAmpMedusaHoligramDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaHoligramDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaOverheadHoligramDisable RTC Request-Response Handler (RTC ID 0x17210000) '<S1280>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaOverheadHoligramDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1280>/Request' */

    /* S-Function (RTC_BytePack): '<S1288>/UnpackREQ' */
    PreAmpMedusaOverheadHoligramDisable_REQ_T* payloadREQ =
        (PreAmpMedusaOverheadHoligramDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaOverheadHoligramDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaOverheadHoligramDisable();

    /* Output and update for function-call system: '<S1280>/Response' */

    /* S-Function (RTC_BytePack): '<S1289>/PackRSP' */
    PreAmpMedusaOverheadHoligramDisable_RSP_T* payloadRSP =
        (PreAmpMedusaOverheadHoligramDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaOverheadHoligramDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMedusaPostHoligramDisable RTC Request-Response Handler (RTC ID 0x11210000) '<S1300>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMedusaPostHoligramDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1300>/Request' */

    /* S-Function (RTC_BytePack): '<S1326>/UnpackREQ' */
    PreAmpMedusaPostHoligramDisable_REQ_T* payloadREQ =
        (PreAmpMedusaPostHoligramDisable_REQ_T*)pREQBuf;
    Model_TargetPreAmpMedusaPostHoligramDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMedusaPostHoligramDisable();

    /* Output and update for function-call system: '<S1300>/Response' */

    /* S-Function (RTC_BytePack): '<S1327>/PackRSP' */
    PreAmpMedusaPostHoligramDisable_RSP_T* payloadRSP =
        (PreAmpMedusaPostHoligramDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMedusaPostHoligramDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpBassSet RTC Request-Response Handler (RTC ID 0x10200000) '<S1527>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpBassSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1527>/Request' */

    /* S-Function (RTC_BytePack): '<S1543>/UnpackREQ' */
    PreAmpBassSet_REQ_T* payloadREQ = (PreAmpBassSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpBassSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpBassSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpBassSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpBassSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpBassSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpBassSet();

    /* Output and update for function-call system: '<S1527>/Response' */

    /* S-Function (RTC_BytePack): '<S1544>/PackRSP' */
    PreAmpBassSet_RSP_T* payloadRSP = (PreAmpBassSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpBassSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpBassSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpBassSet RTC NTF check complete '<S1527>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpBassSet( void )
{
    /* Output and update for function-call system: '<S1527>/NtfCheck' */

    /* MATLAB Function: '<S1523>/check done' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1540>:1' */
    /* '<S1540>:1:3' go(); */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Bass/check done': '<S1534>:1' */
    /*  Checking whether the frameCounts are exactly equal to 0 was leading to */
    /*  unpredictable behavior. Therefore, we now check whether or not the  */
    /*  frameCounts are less-than/equal-to 0. */
    /*  See SAMPLERATE-1196 & SAMPLERATE-1205 for more details.  */
    /* '<S1534>:1:10' done = (Rampers(1).frameCount <= 0) && (Rampers(2).frameCount <= 0); */
    Model_Target_PreAmpPart1_B.done_b =
        ((Model_TargetControlDsms.PreAmpBassRampers[0].frameCount <= 0) &&
         (Model_TargetControlDsms.PreAmpBassRampers[1].frameCount <= 0));

    /* Outputs for Function Call SubSystem: '<S1523>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1530>/In1' */
    Model_Target_PreAmpPart1_B.In1_h =
        Model_TargetPreAmpBassSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1523>/Triggered Subsystem' */
}

// PreAmpBassSet RTC NTF message preparation and packing '<S1527>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpBassSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1527>/Notification' */

    /* S-Function (RTC_BytePack): '<S1539>/PackNTF' */
    PreAmpBassSet_NTF_T* payloadNTF = (PreAmpBassSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpBassSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_PreAmpPart1_B.In1_h;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpMidrangeSet RTC Request-Response Handler (RTC ID 0x10200001) '<S1545>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMidrangeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1545>/Request' */

    /* S-Function (RTC_BytePack): '<S1561>/UnpackREQ' */
    PreAmpMidrangeSet_REQ_T* payloadREQ = (PreAmpMidrangeSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpMidrangeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpMidrangeSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpMidrangeSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpMidrangeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpMidrangeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMidrangeSet();

    /* Output and update for function-call system: '<S1545>/Response' */

    /* S-Function (RTC_BytePack): '<S1562>/PackRSP' */
    PreAmpMidrangeSet_RSP_T* payloadRSP = (PreAmpMidrangeSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMidrangeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpMidrangeSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMidrangeSet RTC NTF check complete '<S1545>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpMidrangeSet( void )
{
    /* Output and update for function-call system: '<S1545>/NtfCheck' */

    /* MATLAB Function: '<S1524>/check done' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1558>:1' */
    /* '<S1558>:1:3' go(); */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Midrange/check done': '<S1553>:1' */
    /*  Checking whether the frameCounts are exactly equal to 0 was leading to */
    /*  unpredictable behavior. Therefore, we now check whether or not the  */
    /*  frameCounts are less-than/equal-to 0. */
    /*  See SAMPLERATE-1196 & SAMPLERATE-1205 for more details.  */
    /* '<S1553>:1:10' done = (Rampers(1).frameCount <= 0) && (Rampers(2).frameCount <= 0); */
    Model_Target_PreAmpPart1_B.done_k =
        ((Model_TargetControlDsms.PreAmpMidrangeRampers[0].frameCount <= 0) &&
         (Model_TargetControlDsms.PreAmpMidrangeRampers[1].frameCount <= 0));

    /* Outputs for Function Call SubSystem: '<S1524>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1548>/In1' */
    Model_Target_PreAmpPart1_B.In1_i =
        Model_TargetPreAmpMidrangeSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1524>/Triggered Subsystem' */
}

// PreAmpMidrangeSet RTC NTF message preparation and packing '<S1545>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpMidrangeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1545>/Notification' */

    /* S-Function (RTC_BytePack): '<S1557>/PackNTF' */
    PreAmpMidrangeSet_NTF_T* payloadNTF = (PreAmpMidrangeSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpMidrangeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_PreAmpPart1_B.In1_i;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpTrebleSet RTC Request-Response Handler (RTC ID 0x10200002) '<S1581>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpTrebleSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1581>/Request' */

    /* S-Function (RTC_BytePack): '<S1597>/UnpackREQ' */
    PreAmpTrebleSet_REQ_T* payloadREQ = (PreAmpTrebleSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpTrebleSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpTrebleSet();

    /* Output and update for function-call system: '<S1581>/Response' */

    /* S-Function (RTC_BytePack): '<S1598>/PackRSP' */
    PreAmpTrebleSet_RSP_T* payloadRSP = (PreAmpTrebleSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpTrebleSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpTrebleSet RTC NTF check complete '<S1581>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpTrebleSet( void )
{
    /* Output and update for function-call system: '<S1581>/NtfCheck' */

    /* MATLAB Function: '<S1526>/check done' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1594>:1' */
    /* '<S1594>:1:3' go(); */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Treble/check done': '<S1588>:1' */
    /*  Checking whether the frameCounts are exactly equal to 0 was leading to */
    /*  unpredictable behavior. Therefore, we now check whether or not the  */
    /*  frameCounts are less-than/equal-to 0. */
    /*  See SAMPLERATE-1196 & SAMPLERATE-1205 for more details.  */
    /* '<S1588>:1:10' done = (Rampers(1).frameCount <= 0) && (Rampers(2).frameCount <= 0); */
    Model_Target_PreAmpPart1_B.done =
        ((Model_TargetControlDsms.PreAmpTrebleRampers[0].frameCount <= 0) &&
         (Model_TargetControlDsms.PreAmpTrebleRampers[1].frameCount <= 0));

    /* Outputs for Function Call SubSystem: '<S1526>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1584>/In1' */
    Model_Target_PreAmpPart1_B.In1 =
        Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1526>/Triggered Subsystem' */
}

// PreAmpTrebleSet RTC NTF message preparation and packing '<S1581>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpTrebleSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1581>/Notification' */

    /* S-Function (RTC_BytePack): '<S1593>/PackNTF' */
    PreAmpTrebleSet_NTF_T* payloadNTF = (PreAmpTrebleSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpTrebleSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_PreAmpPart1_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PostProcessMuteSet RTC Request-Response Handler (RTC ID 0x10300003) '<S2221>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessMuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2221>/Request' */

    /* S-Function (RTC_BytePack): '<S2229>/UnpackREQ' */
    PostProcessMuteSet_REQ_T* payloadREQ = (PostProcessMuteSet_REQ_T*)pREQBuf;
    Model_TargetPostProcessMuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessMuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetPostProcessMuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPostProcessMuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPostProcessMuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPostProcessMuteSet();

    /* Output and update for function-call system: '<S2221>/Response' */

    /* S-Function (RTC_BytePack): '<S2230>/PackRSP' */
    PostProcessMuteSet_RSP_T* payloadRSP = (PostProcessMuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessMuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetPostProcessMuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessMuteSet RTC NTF check complete '<S2221>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PostProcessMuteSet( void )
{
    /* Output and update for function-call system: '<S2221>/NtfCheck' */

    /* MATLAB Function: '<S2220>/TriggeredFunction' */
    /* MATLAB Function: '<S2220>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2226>:1' */
    /* '<S2226>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S2232>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S2232>:1:9' done = true; */
    Model_Target_PostProcess_B.done = true;

    /* '<S2232>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.PostProcessMuteTargetLinearGain !=
            Model_TargetControlDsms.PostProcessMuteCurrentGain)
    {
        /* '<S2232>:1:11' done = false; */
        Model_Target_PostProcess_B.done = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S2220>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S2219>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S2222>/In1' */
    Model_Target_PostProcess_B.In1 =
        Model_TargetPostProcessMuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S2219>/Triggered Subsystem' */
}

// PostProcessMuteSet RTC NTF message preparation and packing '<S2221>/NTF Trigger' ---------------------------------
void RtcNtfPack_PostProcessMuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2221>/Notification' */

    /* S-Function (RTC_BytePack): '<S2225>/PackNTF' */
    PostProcessMuteSet_NTF_T* payloadNTF = (PostProcessMuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPostProcessMuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_PostProcess_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PostProcessLimiterSoftclipParamSet RTC Request-Response Handler (RTC ID 0x10310002) '<S2185>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessLimiterSoftclipParamSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2185>/Request' */

    /* S-Function (RTC_BytePack): '<S2260>/UnpackREQ' */
    PostProcessLimiterSoftclipParamSet_REQ_T* payloadREQ =
        (PostProcessLimiterSoftclipParamSet_REQ_T*)pREQBuf;
    Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_paramSet =
        payloadREQ->paramSet;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2185>/Response' */

    /* S-Function (RTC_BytePack): '<S2261>/PackRSP' */
    PostProcessLimiterSoftclipParamSet_RSP_T* payloadRSP =
        (PostProcessLimiterSoftclipParamSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->paramSet =
        Model_TargetPostProcessLimiterSoftclipParamSetRtcOut.REQ_paramSet;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessLimiterSoftclipDisable RTC Request-Response Handler (RTC ID 0x10310001) '<S2186>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessLimiterSoftclipDisable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2186>/Request' */

    /* S-Function (RTC_BytePack): '<S2266>/UnpackREQ' */
    PostProcessLimiterSoftclipDisable_REQ_T* payloadREQ =
        (PostProcessLimiterSoftclipDisable_REQ_T*)pREQBuf;
    Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_disableMsg =
        payloadREQ->disableMsg;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2186>/Response' */

    /* S-Function (RTC_BytePack): '<S2267>/PackRSP' */
    PostProcessLimiterSoftclipDisable_RSP_T* payloadRSP =
        (PostProcessLimiterSoftclipDisable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->disableMsg =
        Model_TargetPostProcessLimiterSoftclipDisableRtcOut.REQ_disableMsg;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessEnergyLimiterEnableLimiter RTC Request-Response Handler (RTC ID 0x10300000) '<S2191>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessEnergyLimiterEnableLimiter(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S2191>/Request' */

    /* S-Function (RTC_BytePack): '<S2214>/UnpackREQ' */
    PostProcessEnergyLimiterEnableLimiter_REQ_T* payloadREQ =
        (PostProcessEnergyLimiterEnableLimiter_REQ_T*)pREQBuf;
    Model_TargetPostProcessEnergyLimiterEnableLimiterRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPostProcessEnergyLimiterEnableLimiterRtcOut.REQ_EnableGainLimiter
        = payloadREQ->EnableGainLimiter;
    (Model_TargetPostProcessEnergyLimiterEnableLimiterRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2191>/Response' */

    /* S-Function (RTC_BytePack): '<S2215>/PackRSP' */
    PostProcessEnergyLimiterEnableLimiter_RSP_T* payloadRSP =
        (PostProcessEnergyLimiterEnableLimiter_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessEnergyLimiterEnableLimiterRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PostProcessEnergyLimiterEnableLimiter RTC NTF check complete '<S2191>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PostProcessEnergyLimiterEnableLimiter( void )
{
    /* Output and update for function-call system: '<S2191>/NtfCheck' */

    /* Outputs for Function Call SubSystem: '<S2188>/Triggered Subsystem1' */
    /* Outputs for Function Call SubSystem: '<S2188>/Triggered Subsystem' */
    /* Switch: '<S2193>/Switch1' incorporates:
     *  Switch: '<S2194>/Switch1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2211>:1' */
    /* '<S2211>:1:3' go(); */
    if (Model_TargetPostProcessEnergyLimiterEnableLimiterRtcOut.REQ_EnableGainLimiter
        > 0U)
    {
        real32_T tmp;

        /* DataTypeConversion: '<S2193>/Data Type Conversion' */
        Model_Target_PostProcess_B.DataTypeConversion_f =
            (Model_Target_PostProcess_B.transition != 0.0F);

        /* DataTypeConversion: '<S2194>/Data Type Conversion' */
        tmp = fmodf(qhmath_floor_f(Model_Target_PostProcess_B.transition),
                    4.2949673E+9F);

        /* DataTypeConversion: '<S2194>/Data Type Conversion' */
        Model_Target_PostProcess_B.DataTypeConversion = tmp < 0.0F ? (uint32_T)
            -(int32_T)(uint32_T)-tmp : (uint32_T)tmp;
    }
    else
    {
        /* DataTypeConversion: '<S2193>/Data Type Conversion' incorporates:
         *  Constant: '<S2193>/Constant1'
         */
        Model_Target_PostProcess_B.DataTypeConversion_f = true;

        /* DataTypeConversion: '<S2194>/Data Type Conversion' incorporates:
         *  Constant: '<S2194>/Constant1'
         */
        Model_Target_PostProcess_B.DataTypeConversion = 5U;
    }

    /* End of Switch: '<S2193>/Switch1' */
    /* End of Outputs for SubSystem: '<S2188>/Triggered Subsystem' */
    /* End of Outputs for SubSystem: '<S2188>/Triggered Subsystem1' */
}

// PostProcessEnergyLimiterEnableLimiter RTC NTF message preparation and packing '<S2191>/NTF Trigger' ---------------------------------
void RtcNtfPack_PostProcessEnergyLimiterEnableLimiter(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2191>/Notification' */

    /* S-Function (RTC_BytePack): '<S2210>/PackNTF' */
    PostProcessEnergyLimiterEnableLimiter_NTF_T* payloadNTF =
        (PostProcessEnergyLimiterEnableLimiter_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPostProcessEnergyLimiterEnableLimiterRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->ELNotification = Model_Target_PostProcess_B.DataTypeConversion;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PostProcessPostLimiterEqShutdown RTC Request-Response Handler (RTC ID 0x10310004) '<S2244>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PostProcessPostLimiterEqShutdown(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2244>/Request' */

    /* S-Function (RTC_BytePack): '<S2254>/UnpackREQ' */
    PostProcessPostLimiterEqShutdown_REQ_T* payloadREQ =
        (PostProcessPostLimiterEqShutdown_REQ_T*)pREQBuf;
    Model_TargetPostProcessPostLimiterEqShutdownRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPostProcessPostLimiterEqShutdown();

    /* Output and update for function-call system: '<S2244>/Response' */

    /* S-Function (RTC_BytePack): '<S2255>/PackRSP' */
    PostProcessPostLimiterEqShutdown_RSP_T* payloadRSP =
        (PostProcessPostLimiterEqShutdown_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPostProcessPostLimiterEqShutdownRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// InputSelectRouterCfgSet RTC Request-Response Handler (RTC ID 0x10010000) '<S15>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_InputSelectRouterCfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S15>/Request' */

    /* S-Function (RTC_BytePack): '<S21>/UnpackREQ' */
    InputSelectRouterCfgSet_REQ_T* payloadREQ = (InputSelectRouterCfgSet_REQ_T*)
        pREQBuf;
    Model_TargetInputSelectRouterCfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[0]),
                 (uint8_t*)payloadREQ->routerMap, sizeof(int32_T)*5 );// copy 20 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S15>/Response' */

    /* S-Function (RTC_BytePack): '<S22>/PackRSP' */
    InputSelectRouterCfgSet_RSP_T* payloadRSP = (InputSelectRouterCfgSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetInputSelectRouterCfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    (void)memcpy((uint8_t*)payloadRSP->routerMap, (uint8_t*)
                 &(Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[0]),
                 sizeof(int32_T)*5 );  // copy 20 chars

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMuteControlSet RTC Request-Response Handler (RTC ID 0x19200001) '<S1390>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpMuteControlSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1390>/Request' */

    /* S-Function (RTC_BytePack): '<S1398>/UnpackREQ' */
    PreAmpMuteControlSet_REQ_T* payloadREQ = (PreAmpMuteControlSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpMuteControlSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpMuteControlSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpMuteControlSet();

    /* Output and update for function-call system: '<S1390>/Response' */

    /* S-Function (RTC_BytePack): '<S1399>/PackRSP' */
    PreAmpMuteControlSet_RSP_T* payloadRSP = (PreAmpMuteControlSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpMuteControlSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetPreAmpMuteControlSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpMuteControlSet RTC NTF check complete '<S1390>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpMuteControlSet( void )
{
    /* Output and update for function-call system: '<S1390>/NtfCheck' */
    {
        boolean_T done_f;
        boolean_T done_ig;

        /* MATLAB Function: '<S1400>/TriggeredFunction' */
        /* MATLAB Function: '<S1400>/TriggeredFunction' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1395>:1' */
        /* '<S1395>:1:3' go(); */
        /*  Function to check whether the ramp has completed.  */
        /*  If so, send out TRUE */
        /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S1402>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1402>:1:9' done = true; */
        done_f = true;

        /* '<S1402>:1:10' if (targetLinearGain ~= currentGain) */
        if (Model_TargetControlDsms.PreAmpMuteDRTargetLinearGain !=
                Model_TargetControlDsms.PreAmpMuteDRCurrentGain)
        {
            /* '<S1402>:1:11' done = false; */
            done_f = false;

            /*  just proved otherwise */
        }

        /* End of MATLAB Function: '<S1400>/TriggeredFunction' */

        /* MATLAB Function: '<S1413>/TriggeredFunction' */
        /* MATLAB Function: '<S1413>/TriggeredFunction' */
        /*  Function to check whether the ramp has completed.  */
        /*  If so, send out TRUE */
        /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S1415>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1415>:1:9' done = true; */
        done_ig = true;

        /* '<S1415>:1:10' if (targetLinearGain ~= currentGain) */
        if (Model_TargetControlDsms.PreAmpMuteFRTargetLinearGain !=
                Model_TargetControlDsms.PreAmpMuteFRCurrentGain)
        {
            /* '<S1415>:1:11' done = false; */
            done_ig = false;

            /*  just proved otherwise */
        }

        /* End of MATLAB Function: '<S1413>/TriggeredFunction' */

        /* Outputs for Function Call SubSystem: '<S1346>/Subsystem' */
        /* Logic: '<S1357>/AND' */
        Model_Target_B.AND = (done_f && done_ig);

        /* End of Outputs for SubSystem: '<S1346>/Subsystem' */

        /* Outputs for Function Call SubSystem: '<S1389>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1391>/In1' */
        Model_Target_B.In1_g20a =
            Model_TargetPreAmpMuteControlSetRtcOut.REQ_mute_switch;

        /* End of Outputs for SubSystem: '<S1389>/Triggered Subsystem' */
    }
}

// PreAmpMuteControlSet RTC NTF message preparation and packing '<S1390>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpMuteControlSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1390>/Notification' */

    /* S-Function (RTC_BytePack): '<S1394>/PackNTF' */
    PreAmpMuteControlSet_NTF_T* payloadNTF = (PreAmpMuteControlSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpMuteControlSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_g20a;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpFadeControlSet RTC Request-Response Handler (RTC ID 0x19200000) '<S1360>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpFadeControlSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1360>/Request' */

    /* S-Function (RTC_BytePack): '<S1373>/UnpackREQ' */
    PreAmpFadeControlSet_REQ_T* payloadREQ = (PreAmpFadeControlSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpFadeControlSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpFadeControlSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpFadeControlSet();

    /* Output and update for function-call system: '<S1360>/Response' */

    /* S-Function (RTC_BytePack): '<S1374>/PackRSP' */
    PreAmpFadeControlSet_RSP_T* payloadRSP = (PreAmpFadeControlSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpFadeControlSet RTC NTF check complete '<S1360>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpFadeControlSet( void )
{
    /* Output and update for function-call system: '<S1360>/NtfCheck' */

    /* Outputs for Function Call SubSystem: '<S1346>/Subsystem1' */
    /* MATLAB Function: '<S1375>/check done' */
    /* MATLAB Function: '<S1382>/check done' */
    /* Logic: '<S1358>/AND' incorporates:
     *  MATLAB Function: '<S1375>/check done'
     *  MATLAB Function: '<S1382>/check done'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1370>:1' */
    /* '<S1370>:1:3' go(); */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/SleepingBeauty/SleepingBeauty/Enabled/FadeRamperDR/InnerLink/check done': '<S1378>:1' */
    /*  Fading is done if both the 'Front' and the 'Rear' groups of channels  */
    /*  have ramped. */
    /* '<S1378>:1:8' done = Rampers(1).frameCount == 0 && Rampers(2).frameCount == 0; */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/SleepingBeauty/SleepingBeauty/Enabled/FadeRamperFR/InnerLink/check done': '<S1385>:1' */
    /*  Fading is done if both the 'Front' and the 'Rear' groups of channels  */
    /*  have ramped. */
    /* '<S1385>:1:8' done = Rampers(1).frameCount == 0 && Rampers(2).frameCount == 0; */
    Model_Target_B.AND_h = ((Model_TargetControlDsms.PreAmpFadeRamperDRRampers[0]
        .frameCount == 0) && (Model_TargetControlDsms.PreAmpFadeRamperDRRampers
        [1].frameCount == 0) &&
                            ((Model_TargetControlDsms.PreAmpFadeRamperFRRampers
        [0].frameCount == 0) &&
        (Model_TargetControlDsms.PreAmpFadeRamperFRRampers[1].frameCount == 0)));

    /* End of Outputs for SubSystem: '<S1346>/Subsystem1' */

    /* Outputs for Function Call SubSystem: '<S1359>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1361>/In1' */
    Model_Target_B.In1_g20as =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S1359>/Triggered Subsystem' */
}

// PreAmpFadeControlSet RTC NTF message preparation and packing '<S1360>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpFadeControlSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1360>/Notification' */

    /* S-Function (RTC_BytePack): '<S1369>/PackNTF' */
    PreAmpFadeControlSet_NTF_T* payloadNTF = (PreAmpFadeControlSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpFadeControlSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_g20as;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpSleepingBeautyDRSet RTC Request-Response Handler (RTC ID 0x19200003) '<S1433>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpSleepingBeautyDRSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1433>/Request' */

    /* S-Function (RTC_BytePack): '<S1450>/UnpackREQ' */
    PreAmpSleepingBeautyDRSet_REQ_T* payloadREQ =
        (PreAmpSleepingBeautyDRSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpSleepingBeautyDRSet();

    /* Output and update for function-call system: '<S1433>/Response' */

    /* S-Function (RTC_BytePack): '<S1451>/PackRSP' */
    PreAmpSleepingBeautyDRSet_RSP_T* payloadRSP =
        (PreAmpSleepingBeautyDRSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpSleepingBeautyDRSet RTC NTF check complete '<S1433>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpSleepingBeautyDRSet( void )
{
    /* Output and update for function-call system: '<S1433>/NtfCheck' */
    {
        int32_T i;
        boolean_T exitg1;

        /* MATLAB Function: '<S1432>/check sequence' */
        /* MATLAB Function: '<S1432>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1447>:1' */
        /* '<S1447>:1:3' go(); */
        /*   Function that checks whether all channels have completed their ramp to  */
        /*  target gain. */
        /*  If so, send out TRUE to RTC */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/SleepingBeauty/SleepingBeauty/Enabled/SleepingBeautyDR/InnerLink/check sequence': '<S1443>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1443>:1:9' done = true; */
        Model_Target_B.done_c = true;

        /* '<S1443>:1:11' for i=1:MaskNumRampers */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 4))
        {
            /* '<S1443>:1:12' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
            if (Model_TargetControlDsms.PreAmpSleepingBeautyDRRampers[i].
                    targetGain !=
                    Model_TargetControlDsms.PreAmpSleepingBeautyDRRampers[i].
                    currentGain)
            {
                /* '<S1443>:1:13' done = false; */
                Model_Target_B.done_c = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S1432>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1436>/In1' */
        Model_Target_B.In1_g20 =
            Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_gain_index;

        /* End of Outputs for SubSystem: '<S1432>/Triggered Subsystem' */
    }
}

// PreAmpSleepingBeautyDRSet RTC NTF message preparation and packing '<S1433>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpSleepingBeautyDRSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1433>/Notification' */

    /* S-Function (RTC_BytePack): '<S1446>/PackNTF' */
    PreAmpSleepingBeautyDRSet_NTF_T* payloadNTF =
        (PreAmpSleepingBeautyDRSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpSleepingBeautyDRSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_g20;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpSleepingBeautyFRSet RTC Request-Response Handler (RTC ID 0x19200004) '<S1453>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpSleepingBeautyFRSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1453>/Request' */

    /* S-Function (RTC_BytePack): '<S1470>/UnpackREQ' */
    PreAmpSleepingBeautyFRSet_REQ_T* payloadREQ =
        (PreAmpSleepingBeautyFRSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpSleepingBeautyFRSet();

    /* Output and update for function-call system: '<S1453>/Response' */

    /* S-Function (RTC_BytePack): '<S1471>/PackRSP' */
    PreAmpSleepingBeautyFRSet_RSP_T* payloadRSP =
        (PreAmpSleepingBeautyFRSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpSleepingBeautyFRSet RTC NTF check complete '<S1453>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpSleepingBeautyFRSet( void )
{
    /* Output and update for function-call system: '<S1453>/NtfCheck' */
    {
        int32_T i;
        boolean_T exitg1;

        /* MATLAB Function: '<S1452>/check sequence' */
        /* MATLAB Function: '<S1452>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S1467>:1' */
        /* '<S1467>:1:3' go(); */
        /*   Function that checks whether all channels have completed their ramp to  */
        /*  target gain. */
        /*  If so, send out TRUE to RTC */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/SleepingBeauty/SleepingBeauty/Enabled/SleepingBeautyFR/InnerLink/check sequence': '<S1463>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S1463>:1:9' done = true; */
        Model_Target_B.done_o = true;

        /* '<S1463>:1:11' for i=1:MaskNumRampers */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i < 4))
        {
            /* '<S1463>:1:12' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
            if (Model_TargetControlDsms.PreAmpSleepingBeautyFRRampers[i].
                    targetGain !=
                    Model_TargetControlDsms.PreAmpSleepingBeautyFRRampers[i].
                    currentGain)
            {
                /* '<S1463>:1:13' done = false; */
                Model_Target_B.done_o = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S1452>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S1456>/In1' */
        Model_Target_B.In1_g2 =
            Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_gain_index;

        /* End of Outputs for SubSystem: '<S1452>/Triggered Subsystem' */
    }
}

// PreAmpSleepingBeautyFRSet RTC NTF message preparation and packing '<S1453>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpSleepingBeautyFRSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1453>/Notification' */

    /* S-Function (RTC_BytePack): '<S1466>/PackNTF' */
    PreAmpSleepingBeautyFRSet_NTF_T* payloadNTF =
        (PreAmpSleepingBeautyFRSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpSleepingBeautyFRSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_g2;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpResetSleepingBeauty RTC Request-Response Handler (RTC ID 0x19210002) '<S1354>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpResetSleepingBeauty(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1354>/Request' */

    /* S-Function (RTC_BytePack): '<S1430>/UnpackREQ' */
    PreAmpResetSleepingBeauty_REQ_T* payloadREQ =
        (PreAmpResetSleepingBeauty_REQ_T*)pREQBuf;
    Model_TargetPreAmpResetSleepingBeautyRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1354>/Response' */

    /* S-Function (RTC_BytePack): '<S1431>/PackRSP' */
    PreAmpResetSleepingBeauty_RSP_T* payloadRSP =
        (PreAmpResetSleepingBeauty_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpResetSleepingBeautyRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterMainSelect RTC Request-Response Handler (RTC ID 0x10510004) '<S2279>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterMainSelect(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2279>/Request' */

    /* S-Function (RTC_BytePack): '<S2317>/UnpackREQ' */
    TestRouterASDRouterMainSelect_REQ_T* payloadREQ =
        (TestRouterASDRouterMainSelect_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_mainSelect
                   [0]), (uint8_t*)payloadREQ->mainSelect, sizeof(int32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2279>/Response' */

    /* S-Function (RTC_BytePack): '<S2318>/PackRSP' */
    TestRouterASDRouterMainSelect_RSP_T* payloadRSP =
        (TestRouterASDRouterMainSelect_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterMainGain RTC Request-Response Handler (RTC ID 0x10510003) '<S2278>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterMainGain(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2278>/Request' */

    /* S-Function (RTC_BytePack): '<S2311>/UnpackREQ' */
    TestRouterASDRouterMainGain_REQ_T* payloadREQ =
        (TestRouterASDRouterMainGain_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_mainGain[0]),
                 (uint8_t*)payloadREQ->mainGain, sizeof(real32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2278>/Response' */

    /* S-Function (RTC_BytePack): '<S2312>/PackRSP' */
    TestRouterASDRouterMainGain_RSP_T* payloadRSP =
        (TestRouterASDRouterMainGain_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterAuxEnable RTC Request-Response Handler (RTC ID 0x10510000) '<S2274>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterAuxEnable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2274>/Request' */

    /* S-Function (RTC_BytePack): '<S2287>/UnpackREQ' */
    TestRouterASDRouterAuxEnable_REQ_T* payloadREQ =
        (TestRouterASDRouterAuxEnable_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_EnableAuxFlag =
        payloadREQ->EnableAuxFlag;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2274>/Response' */

    /* S-Function (RTC_BytePack): '<S2288>/PackRSP' */
    TestRouterASDRouterAuxEnable_RSP_T* payloadRSP =
        (TestRouterASDRouterAuxEnable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterAuxSelect RTC Request-Response Handler (RTC ID 0x10510002) '<S2276>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterAuxSelect(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2276>/Request' */

    /* S-Function (RTC_BytePack): '<S2299>/UnpackREQ' */
    TestRouterASDRouterAuxSelect_REQ_T* payloadREQ =
        (TestRouterASDRouterAuxSelect_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_AuxSelect
                   [0]), (uint8_t*)payloadREQ->AuxSelect, sizeof(int32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2276>/Response' */

    /* S-Function (RTC_BytePack): '<S2300>/PackRSP' */
    TestRouterASDRouterAuxSelect_RSP_T* payloadRSP =
        (TestRouterASDRouterAuxSelect_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// TestRouterASDRouterAuxGain RTC Request-Response Handler (RTC ID 0x10510001) '<S2275>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_TestRouterASDRouterAuxGain(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2275>/Request' */

    /* S-Function (RTC_BytePack): '<S2293>/UnpackREQ' */
    TestRouterASDRouterAuxGain_REQ_T* payloadREQ =
        (TestRouterASDRouterAuxGain_REQ_T*)pREQBuf;
    Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)
                 &(Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_AuxGain[0]),
                 (uint8_t*)payloadREQ->AuxGain, sizeof(real32_T)*24 );// copy 96 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S2275>/Response' */

    /* S-Function (RTC_BytePack): '<S2294>/PackRSP' */
    TestRouterASDRouterAuxGain_RSP_T* payloadRSP =
        (TestRouterASDRouterAuxGain_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1VolumeSet RTC Request-Response Handler (RTC ID 0x10100002) '<S1908>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn1Ann1VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1908>/Request' */

    /* S-Function (RTC_BytePack): '<S1922>/UnpackREQ' */
    NearAnn1Ann1VolumeSet_REQ_T* payloadREQ = (NearAnn1Ann1VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn1Ann1VolumeSet();

    /* Output and update for function-call system: '<S1908>/Response' */

    /* S-Function (RTC_BytePack): '<S1923>/PackRSP' */
    NearAnn1Ann1VolumeSet_RSP_T* payloadRSP = (NearAnn1Ann1VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1VolumeSet RTC NTF check complete '<S1908>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn1Ann1VolumeSet( void )
{
    /* Output and update for function-call system: '<S1908>/NtfCheck' */

    /* MATLAB Function: '<S1926>/rgainx check sequence' */
    /* MATLAB Function: '<S1926>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1919>:1' */
    /* '<S1919>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S1931>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S1931>:1:7' done = true; */
    Model_Target_B.done_d1 = true;

    /* '<S1931>:1:8' for i=1:MaskNumRampers */
    /* '<S1931>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain)
    {
        /* '<S1931>:1:10' done = false; */
        Model_Target_B.done_d1 = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S1926>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S1855>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1910>/In1' */
    Model_Target_B.In1_f =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S1855>/Triggered Subsystem' */
}

// NearAnn1Ann1VolumeSet RTC NTF message preparation and packing '<S1908>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn1Ann1VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1908>/Notification' */

    /* S-Function (RTC_BytePack): '<S1918>/PackNTF' */
    NearAnn1Ann1VolumeSet_NTF_T* payloadNTF = (NearAnn1Ann1VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_f;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn2Ann2VolumeSet RTC Request-Response Handler (RTC ID 0x10100005) '<S1988>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn2Ann2VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1988>/Request' */

    /* S-Function (RTC_BytePack): '<S2002>/UnpackREQ' */
    NearAnn2Ann2VolumeSet_REQ_T* payloadREQ = (NearAnn2Ann2VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn2Ann2VolumeSet();

    /* Output and update for function-call system: '<S1988>/Response' */

    /* S-Function (RTC_BytePack): '<S2003>/PackRSP' */
    NearAnn2Ann2VolumeSet_RSP_T* payloadRSP = (NearAnn2Ann2VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn2Ann2VolumeSet RTC NTF check complete '<S1988>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn2Ann2VolumeSet( void )
{
    /* Output and update for function-call system: '<S1988>/NtfCheck' */

    /* MATLAB Function: '<S2006>/rgainx check sequence' */
    /* MATLAB Function: '<S2006>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1999>:1' */
    /* '<S1999>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S2011>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S2011>:1:7' done = true; */
    Model_Target_B.done_d = true;

    /* '<S2011>:1:8' for i=1:MaskNumRampers */
    /* '<S2011>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain)
    {
        /* '<S2011>:1:10' done = false; */
        Model_Target_B.done_d = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S2006>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S1935>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1990>/In1' */
    Model_Target_B.In1_g =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S1935>/Triggered Subsystem' */
}

// NearAnn2Ann2VolumeSet RTC NTF message preparation and packing '<S1988>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn2Ann2VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1988>/Notification' */

    /* S-Function (RTC_BytePack): '<S1998>/PackNTF' */
    NearAnn2Ann2VolumeSet_NTF_T* payloadNTF = (NearAnn2Ann2VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_g;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn3Ann3VolumeSet RTC Request-Response Handler (RTC ID 0x10100008) '<S2068>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn3Ann3VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2068>/Request' */

    /* S-Function (RTC_BytePack): '<S2082>/UnpackREQ' */
    NearAnn3Ann3VolumeSet_REQ_T* payloadREQ = (NearAnn3Ann3VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn3Ann3VolumeSet();

    /* Output and update for function-call system: '<S2068>/Response' */

    /* S-Function (RTC_BytePack): '<S2083>/PackRSP' */
    NearAnn3Ann3VolumeSet_RSP_T* payloadRSP = (NearAnn3Ann3VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn3Ann3VolumeSet RTC NTF check complete '<S2068>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn3Ann3VolumeSet( void )
{
    /* Output and update for function-call system: '<S2068>/NtfCheck' */

    /* MATLAB Function: '<S2086>/rgainx check sequence' */
    /* MATLAB Function: '<S2086>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2079>:1' */
    /* '<S2079>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S2091>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S2091>:1:7' done = true; */
    Model_Target_B.done_ix = true;

    /* '<S2091>:1:8' for i=1:MaskNumRampers */
    /* '<S2091>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain)
    {
        /* '<S2091>:1:10' done = false; */
        Model_Target_B.done_ix = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S2086>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S2015>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S2070>/In1' */
    Model_Target_B.In1_i =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S2015>/Triggered Subsystem' */
}

// NearAnn3Ann3VolumeSet RTC NTF message preparation and packing '<S2068>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn3Ann3VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2068>/Notification' */

    /* S-Function (RTC_BytePack): '<S2078>/PackNTF' */
    NearAnn3Ann3VolumeSet_NTF_T* payloadNTF = (NearAnn3Ann3VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_i;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn4Ann4VolumeSet RTC Request-Response Handler (RTC ID 0x1010000b) '<S2148>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn4Ann4VolumeSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2148>/Request' */

    /* S-Function (RTC_BytePack): '<S2162>/UnpackREQ' */
    NearAnn4Ann4VolumeSet_REQ_T* payloadREQ = (NearAnn4Ann4VolumeSet_REQ_T*)
        pREQBuf;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index =
        payloadREQ->volume_index;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_db_per_second =
        payloadREQ->db_per_second;
    Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn4Ann4VolumeSet();

    /* Output and update for function-call system: '<S2148>/Response' */

    /* S-Function (RTC_BytePack): '<S2163>/PackRSP' */
    NearAnn4Ann4VolumeSet_RSP_T* payloadRSP = (NearAnn4Ann4VolumeSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn4Ann4VolumeSet RTC NTF check complete '<S2148>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn4Ann4VolumeSet( void )
{
    /* Output and update for function-call system: '<S2148>/NtfCheck' */

    /* MATLAB Function: '<S2166>/rgainx check sequence' */
    /* MATLAB Function: '<S2166>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2159>:1' */
    /* '<S2159>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S2171>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S2171>:1:7' done = true; */
    Model_Target_B.done = true;

    /* '<S2171>:1:8' for i=1:MaskNumRampers */
    /* '<S2171>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.targetGain !=
            Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain)
    {
        /* '<S2171>:1:10' done = false; */
        Model_Target_B.done = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S2166>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S2095>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S2150>/In1' */
    Model_Target_B.In1 =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index;

    /* End of Outputs for SubSystem: '<S2095>/Triggered Subsystem' */
}

// NearAnn4Ann4VolumeSet RTC NTF message preparation and packing '<S2148>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn4Ann4VolumeSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2148>/Notification' */

    /* S-Function (RTC_BytePack): '<S2158>/PackNTF' */
    NearAnn4Ann4VolumeSet_NTF_T* payloadNTF = (NearAnn4Ann4VolumeSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn1Ann1NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x10110001) '<S1857>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn1Ann1NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S1857>/Request' */

    /* S-Function (RTC_BytePack): '<S1874>/UnpackREQ' */
    NearAnn1Ann1NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn1Ann1NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn1Ann1NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S1857>/Response' */

    /* S-Function (RTC_BytePack): '<S1875>/PackRSP' */
    NearAnn1Ann1NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn1Ann1NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1MuteSet RTC Request-Response Handler (RTC ID 0x10100000) '<S1886>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn1Ann1MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1886>/Request' */

    /* S-Function (RTC_BytePack): '<S1894>/UnpackREQ' */
    NearAnn1Ann1MuteSet_REQ_T* payloadREQ = (NearAnn1Ann1MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn1Ann1MuteSet();

    /* Output and update for function-call system: '<S1886>/Response' */

    /* S-Function (RTC_BytePack): '<S1895>/PackRSP' */
    NearAnn1Ann1MuteSet_RSP_T* payloadRSP = (NearAnn1Ann1MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn1Ann1MuteSet RTC NTF check complete '<S1886>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn1Ann1MuteSet( void )
{
    /* Output and update for function-call system: '<S1886>/NtfCheck' */

    /* MATLAB Function: '<S1885>/TriggeredFunction' */
    /* MATLAB Function: '<S1885>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1891>:1' */
    /* '<S1891>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S1897>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S1897>:1:9' done = true; */
    Model_Target_B.done_g = true;

    /* '<S1897>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn1MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn1MuteCurrentGain)
    {
        /* '<S1897>:1:11' done = false; */
        Model_Target_B.done_g = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S1885>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S1884>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1887>/In1' */
    Model_Target_B.In1_m = Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S1884>/Triggered Subsystem' */
}

// NearAnn1Ann1MuteSet RTC NTF message preparation and packing '<S1886>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn1Ann1MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1886>/Notification' */

    /* S-Function (RTC_BytePack): '<S1890>/PackNTF' */
    NearAnn1Ann1MuteSet_NTF_T* payloadNTF = (NearAnn1Ann1MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_m;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn2Ann2NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x10110004) '<S1937>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn2Ann2NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S1937>/Request' */

    /* S-Function (RTC_BytePack): '<S1954>/UnpackREQ' */
    NearAnn2Ann2NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn2Ann2NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn2Ann2NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S1937>/Response' */

    /* S-Function (RTC_BytePack): '<S1955>/PackRSP' */
    NearAnn2Ann2NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn2Ann2NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn2Ann2MuteSet RTC Request-Response Handler (RTC ID 0x10100003) '<S1966>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn2Ann2MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1966>/Request' */

    /* S-Function (RTC_BytePack): '<S1974>/UnpackREQ' */
    NearAnn2Ann2MuteSet_REQ_T* payloadREQ = (NearAnn2Ann2MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn2Ann2MuteSet();

    /* Output and update for function-call system: '<S1966>/Response' */

    /* S-Function (RTC_BytePack): '<S1975>/PackRSP' */
    NearAnn2Ann2MuteSet_RSP_T* payloadRSP = (NearAnn2Ann2MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn2Ann2MuteSet RTC NTF check complete '<S1966>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn2Ann2MuteSet( void )
{
    /* Output and update for function-call system: '<S1966>/NtfCheck' */

    /* MATLAB Function: '<S1965>/TriggeredFunction' */
    /* MATLAB Function: '<S1965>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S1971>:1' */
    /* '<S1971>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S1977>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S1977>:1:9' done = true; */
    Model_Target_B.done_n = true;

    /* '<S1977>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn2MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn2MuteCurrentGain)
    {
        /* '<S1977>:1:11' done = false; */
        Model_Target_B.done_n = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S1965>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S1964>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S1967>/In1' */
    Model_Target_B.In1_a = Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S1964>/Triggered Subsystem' */
}

// NearAnn2Ann2MuteSet RTC NTF message preparation and packing '<S1966>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn2Ann2MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S1966>/Notification' */

    /* S-Function (RTC_BytePack): '<S1970>/PackNTF' */
    NearAnn2Ann2MuteSet_NTF_T* payloadNTF = (NearAnn2Ann2MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_a;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn3Ann3NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x10110007) '<S2017>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn3Ann3NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S2017>/Request' */

    /* S-Function (RTC_BytePack): '<S2034>/UnpackREQ' */
    NearAnn3Ann3NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn3Ann3NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn3Ann3NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S2017>/Response' */

    /* S-Function (RTC_BytePack): '<S2035>/PackRSP' */
    NearAnn3Ann3NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn3Ann3NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn3Ann3MuteSet RTC Request-Response Handler (RTC ID 0x10100006) '<S2046>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn3Ann3MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2046>/Request' */

    /* S-Function (RTC_BytePack): '<S2054>/UnpackREQ' */
    NearAnn3Ann3MuteSet_REQ_T* payloadREQ = (NearAnn3Ann3MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn3Ann3MuteSet();

    /* Output and update for function-call system: '<S2046>/Response' */

    /* S-Function (RTC_BytePack): '<S2055>/PackRSP' */
    NearAnn3Ann3MuteSet_RSP_T* payloadRSP = (NearAnn3Ann3MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn3Ann3MuteSet RTC NTF check complete '<S2046>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn3Ann3MuteSet( void )
{
    /* Output and update for function-call system: '<S2046>/NtfCheck' */

    /* MATLAB Function: '<S2045>/TriggeredFunction' */
    /* MATLAB Function: '<S2045>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2051>:1' */
    /* '<S2051>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S2057>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S2057>:1:9' done = true; */
    Model_Target_B.done_e = true;

    /* '<S2057>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn3MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn3MuteCurrentGain)
    {
        /* '<S2057>:1:11' done = false; */
        Model_Target_B.done_e = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S2045>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S2044>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S2047>/In1' */
    Model_Target_B.In1_ib =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S2044>/Triggered Subsystem' */
}

// NearAnn3Ann3MuteSet RTC NTF message preparation and packing '<S2046>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn3Ann3MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2046>/Notification' */

    /* S-Function (RTC_BytePack): '<S2050>/PackNTF' */
    NearAnn3Ann3MuteSet_NTF_T* payloadNTF = (NearAnn3Ann3MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_ib;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnn4Ann4NonEntGainCalcvncEnableRTC RTC Request-Response Handler (RTC ID 0x1011000a) '<S2097>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn4Ann4NonEntGainCalcvncEnableRTC(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S2097>/Request' */

    /* S-Function (RTC_BytePack): '<S2114>/UnpackREQ' */
    NearAnn4Ann4NonEntGainCalcvncEnableRTC_REQ_T* payloadREQ =
        (NearAnn4Ann4NonEntGainCalcvncEnableRTC_REQ_T*)pREQBuf;
    Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable =
        payloadREQ->vncEnable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn4Ann4NonEntGainCalcvncEnableRTC();

    /* Output and update for function-call system: '<S2097>/Response' */

    /* S-Function (RTC_BytePack): '<S2115>/PackRSP' */
    NearAnn4Ann4NonEntGainCalcvncEnableRTC_RSP_T* payloadRSP =
        (NearAnn4Ann4NonEntGainCalcvncEnableRTC_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->enable =
        Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn4Ann4MuteSet RTC Request-Response Handler (RTC ID 0x10100009) '<S2126>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnn4Ann4MuteSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S2126>/Request' */

    /* S-Function (RTC_BytePack): '<S2134>/UnpackREQ' */
    NearAnn4Ann4MuteSet_REQ_T* payloadREQ = (NearAnn4Ann4MuteSet_REQ_T*)pREQBuf;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch =
        payloadREQ->mute_switch;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqNearAnn4Ann4MuteSet();

    /* Output and update for function-call system: '<S2126>/Response' */

    /* S-Function (RTC_BytePack): '<S2135>/PackRSP' */
    NearAnn4Ann4MuteSet_RSP_T* payloadRSP = (NearAnn4Ann4MuteSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->mute_switch =
        Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearAnn4Ann4MuteSet RTC NTF check complete '<S2126>/NTF Trigger' ---------------------------------
void RtcNtfCheck_NearAnn4Ann4MuteSet( void )
{
    /* Output and update for function-call system: '<S2126>/NtfCheck' */

    /* MATLAB Function: '<S2125>/TriggeredFunction' */
    /* MATLAB Function: '<S2125>/TriggeredFunction' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S2131>:1' */
    /* '<S2131>:1:3' go(); */
    /*  Function to check whether the ramp has completed.  */
    /*  If so, send out TRUE */
    /* MATLAB Function 'MuteRamper/TriggeredFunction': '<S2137>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S2137>:1:9' done = true; */
    Model_Target_B.done_i = true;

    /* '<S2137>:1:10' if (targetLinearGain ~= currentGain) */
    if (Model_TargetControlDsms.NearAnn4MuteTargetLinearGain !=
            Model_TargetControlDsms.NearAnn4MuteCurrentGain)
    {
        /* '<S2137>:1:11' done = false; */
        Model_Target_B.done_i = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S2125>/TriggeredFunction' */

    /* Outputs for Function Call SubSystem: '<S2124>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S2127>/In1' */
    Model_Target_B.In1_l = Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch;

    /* End of Outputs for SubSystem: '<S2124>/Triggered Subsystem' */
}

// NearAnn4Ann4MuteSet RTC NTF message preparation and packing '<S2126>/NTF Trigger' ---------------------------------
void RtcNtfPack_NearAnn4Ann4MuteSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S2126>/Notification' */

    /* S-Function (RTC_BytePack): '<S2130>/PackNTF' */
    NearAnn4Ann4MuteSet_NTF_T* payloadNTF = (NearAnn4Ann4MuteSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->mute_switch = Model_Target_B.In1_l;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// NearAnnNoiseLevel RTC Request-Response Handler (RTC ID 0x1012000c) '<S1784>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearAnnNoiseLevel(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1784>/Request' */

    /* S-Function (RTC_BytePack): '<S1850>/UnpackREQ' */
    NearAnnNoiseLevel_REQ_T* payloadREQ = (NearAnnNoiseLevel_REQ_T*)pREQBuf;
    Model_TargetNearAnnNoiseLevelRtcOut.REQ_NoiseSig = payloadREQ->NoiseSig;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1784>/Response' */

    /* S-Function (RTC_BytePack): '<S1851>/PackRSP' */
    /* Byte Packing: <S1851>/PackRSP : nothing to do */
}

// NearChannel1_Location RTC Request-Response Handler (RTC ID 0x1011000d) '<S1736>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel1_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1736>/Request' */

    /* S-Function (RTC_BytePack): '<S1749>/UnpackREQ' */
    NearChannel1_Location_REQ_T* payloadREQ = (NearChannel1_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel1_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel1_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1736>/Response' */

    /* S-Function (RTC_BytePack): '<S1750>/PackRSP' */
    NearChannel1_Location_RSP_T* payloadRSP = (NearChannel1_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel1_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearChannel2_Location RTC Request-Response Handler (RTC ID 0x1011000e) '<S1735>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel2_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1735>/Request' */

    /* S-Function (RTC_BytePack): '<S1743>/UnpackREQ' */
    NearChannel2_Location_REQ_T* payloadREQ = (NearChannel2_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel2_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel2_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1735>/Response' */

    /* S-Function (RTC_BytePack): '<S1744>/PackRSP' */
    NearChannel2_Location_RSP_T* payloadRSP = (NearChannel2_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel2_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearChannel3_Location RTC Request-Response Handler (RTC ID 0x1011000f) '<S1738>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel3_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1738>/Request' */

    /* S-Function (RTC_BytePack): '<S1761>/UnpackREQ' */
    NearChannel3_Location_REQ_T* payloadREQ = (NearChannel3_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel3_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel3_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1738>/Response' */

    /* S-Function (RTC_BytePack): '<S1762>/PackRSP' */
    NearChannel3_Location_RSP_T* payloadRSP = (NearChannel3_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel3_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearChannel4_Location RTC Request-Response Handler (RTC ID 0x10110010) '<S1737>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearChannel4_Location(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1737>/Request' */

    /* S-Function (RTC_BytePack): '<S1755>/UnpackREQ' */
    NearChannel4_Location_REQ_T* payloadREQ = (NearChannel4_Location_REQ_T*)
        pREQBuf;
    Model_TargetNearChannel4_LocationRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearChannel4_LocationRtcOut.REQ_loc[0]),
                 (uint8_t*)payloadREQ->loc, sizeof(real32_T)*2 );// copy 8 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1737>/Response' */

    /* S-Function (RTC_BytePack): '<S1756>/PackRSP' */
    NearChannel4_Location_RSP_T* payloadRSP = (NearChannel4_Location_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearChannel4_LocationRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearDr_RouterSet RTC Request-Response Handler (RTC ID 0x10110011) '<S1656>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearDr_RouterSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1656>/Request' */

    /* S-Function (RTC_BytePack): '<S1662>/UnpackREQ' */
    NearDr_RouterSet_REQ_T* payloadREQ = (NearDr_RouterSet_REQ_T*)pREQBuf;
    Model_TargetNearDr_RouterSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearDr_RouterSetRtcOut.REQ_routerMap[0]),
                 (uint8_t*)payloadREQ->routerMap, sizeof(int32_T)*18 );// copy 72 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1656>/Response' */

    /* S-Function (RTC_BytePack): '<S1663>/PackRSP' */
    NearDr_RouterSet_RSP_T* payloadRSP = (NearDr_RouterSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearDr_RouterSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    (void)memcpy((uint8_t*)payloadRSP->routerMap, (uint8_t*)
                 &(Model_TargetNearDr_RouterSetRtcOut.REQ_routerMap[0]), sizeof
                 (int32_T)*18 );       // copy 72 chars

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearEnable RTC Request-Response Handler (RTC ID 0x10110012) '<S1604>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearEnable(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1604>/Request' */

    /* S-Function (RTC_BytePack): '<S2176>/UnpackREQ' */
    NearEnable_REQ_T* payloadREQ = (NearEnable_REQ_T*)pREQBuf;
    Model_TargetNearEnableRtcOut.REQ_caller_handle = payloadREQ->caller_handle;
    Model_TargetNearEnableRtcOut.REQ_Enable = payloadREQ->Enable;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1604>/Response' */

    /* S-Function (RTC_BytePack): '<S2177>/PackRSP' */
    NearEnable_RSP_T* payloadRSP = (NearEnable_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle = Model_TargetNearEnableRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// NearFr_RouterSet RTC Request-Response Handler (RTC ID 0x10110013) '<S1714>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_NearFr_RouterSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S1714>/Request' */

    /* S-Function (RTC_BytePack): '<S1720>/UnpackREQ' */
    NearFr_RouterSet_REQ_T* payloadREQ = (NearFr_RouterSet_REQ_T*)pREQBuf;
    Model_TargetNearFr_RouterSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    (void)memcpy((uint8_t*)&(Model_TargetNearFr_RouterSetRtcOut.REQ_routerMap[0]),
                 (uint8_t*)payloadREQ->routerMap, sizeof(int32_T)*18 );// copy 72 chars

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S1714>/Response' */

    /* S-Function (RTC_BytePack): '<S1721>/PackRSP' */
    NearFr_RouterSet_RSP_T* payloadRSP = (NearFr_RouterSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetNearFr_RouterSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    (void)memcpy((uint8_t*)payloadRSP->routerMap, (uint8_t*)
                 &(Model_TargetNearFr_RouterSetRtcOut.REQ_routerMap[0]), sizeof
                 (int32_T)*18 );       // copy 72 chars

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotmuteReference RTC Request-Response Handler (RTC ID 0x14210004) '<S44>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotmuteReference(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S44>/Request' */

    /* S-Function (RTC_BytePack): '<S60>/UnpackREQ' */
    PreAmpAudiopilotmuteReference_REQ_T* payloadREQ =
        (PreAmpAudiopilotmuteReference_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_muteReference =
        payloadREQ->muteReference;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S44>/Response' */

    /* S-Function (RTC_BytePack): '<S61>/PackRSP' */
    PreAmpAudiopilotmuteReference_RSP_T* payloadRSP =
        (PreAmpAudiopilotmuteReference_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->muteReference =
        Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_muteReference;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetSpeedIn RTC Request-Response Handler (RTC ID 0x1422000d) '<S45>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetSpeedIn(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S45>/Request' */

    /* S-Function (RTC_BytePack): '<S66>/UnpackREQ' */
    PreAmpAudiopilotsetSpeedIn_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetSpeedIn_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn =
        payloadREQ->speedIn;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S45>/Response' */

    /* S-Function (RTC_BytePack): '<S67>/PackRSP' */
    /* Byte Packing: <S67>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetHVACSetting RTC Request-Response Handler (RTC ID 0x14220009) '<S48>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetHVACSetting(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S48>/Request' */

    /* S-Function (RTC_BytePack): '<S54>/UnpackREQ' */
    PreAmpAudiopilotsetHVACSetting_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetHVACSetting_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting =
        payloadREQ->HVACSetting;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpAudiopilotsetHVACSetting();

    /* Output and update for function-call system: '<S48>/Response' */

    /* S-Function (RTC_BytePack): '<S55>/PackRSP' */
    /* Byte Packing: <S55>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetDynEQBoostOverRide RTC Request-Response Handler (RTC ID 0x14220006) '<S142>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetDynEQBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S142>/Request' */

    /* S-Function (RTC_BytePack): '<S150>/UnpackREQ' */
    PreAmpAudiopilotsetDynEQBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetDynEQBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRideFlag
        = payloadREQ->DynEQBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRide
        = payloadREQ->DynEQBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S142>/Response' */

    /* S-Function (RTC_BytePack): '<S151>/PackRSP' */
    /* Byte Packing: <S151>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetVNCTrebleBoostOverRide RTC Request-Response Handler (RTC ID 0x14220011) '<S145>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCTrebleBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S145>/Request' */

    /* S-Function (RTC_BytePack): '<S168>/UnpackREQ' */
    PreAmpAudiopilotsetVNCTrebleBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCTrebleBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRideFlag
        = payloadREQ->VNCTrebleBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRide
        = payloadREQ->VNCTrebleBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S145>/Response' */

    /* S-Function (RTC_BytePack): '<S169>/PackRSP' */
    /* Byte Packing: <S169>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetLoudSignalOverRide RTC Request-Response Handler (RTC ID 0x1422000b) '<S171>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetLoudSignalOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S171>/Request' */

    /* S-Function (RTC_BytePack): '<S178>/UnpackREQ' */
    PreAmpAudiopilotsetLoudSignalOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetLoudSignalOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRideFlag
        = payloadREQ->LoudSignalOverRideFlag;
    Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRide
        = payloadREQ->LoudSignalOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S171>/Response' */

    /* S-Function (RTC_BytePack): '<S179>/PackRSP' */
    /* Byte Packing: <S179>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetVNCSignalOverRide RTC Request-Response Handler (RTC ID 0x14220010) '<S173>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCSignalOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S173>/Request' */

    /* S-Function (RTC_BytePack): '<S184>/UnpackREQ' */
    PreAmpAudiopilotsetVNCSignalOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCSignalOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRideFlag
        = payloadREQ->VNCSignalOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRide
        = payloadREQ->VNCSignalOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S173>/Response' */

    /* S-Function (RTC_BytePack): '<S185>/PackRSP' */
    /* Byte Packing: <S185>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetLFNoiseOverRide RTC Request-Response Handler (RTC ID 0x1422000a) '<S193>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetLFNoiseOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S193>/Request' */

    /* S-Function (RTC_BytePack): '<S207>/UnpackREQ' */
    PreAmpAudiopilotsetLFNoiseOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetLFNoiseOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRideFlag
        = payloadREQ->LFNoiseOverRideFlag;
    Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRide =
        payloadREQ->LFNoiseOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S193>/Response' */

    /* S-Function (RTC_BytePack): '<S208>/PackRSP' */
    /* Byte Packing: <S208>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetWBNoiseOverRide RTC Request-Response Handler (RTC ID 0x14220012) '<S196>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetWBNoiseOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S196>/Request' */

    /* S-Function (RTC_BytePack): '<S219>/UnpackREQ' */
    PreAmpAudiopilotsetWBNoiseOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetWBNoiseOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRideFlag
        = payloadREQ->WBNoiseOverRideFlag;
    Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRide =
        payloadREQ->WBNoiseOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S196>/Response' */

    /* S-Function (RTC_BytePack): '<S220>/PackRSP' */
    /* Byte Packing: <S220>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetHFNoiseOverRide RTC Request-Response Handler (RTC ID 0x14220008) '<S192>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetHFNoiseOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S192>/Request' */

    /* S-Function (RTC_BytePack): '<S201>/UnpackREQ' */
    PreAmpAudiopilotsetHFNoiseOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetHFNoiseOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRideFlag
        = payloadREQ->HFNoiseOverRideFlag;
    Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRide =
        payloadREQ->HFNoiseOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S192>/Response' */

    /* S-Function (RTC_BytePack): '<S202>/PackRSP' */
    /* Byte Packing: <S202>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetRatioOverRide RTC Request-Response Handler (RTC ID 0x1422000c) '<S195>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetRatioOverRide(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S195>/Request' */

    /* S-Function (RTC_BytePack): '<S213>/UnpackREQ' */
    PreAmpAudiopilotsetRatioOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetRatioOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRideFlag =
        payloadREQ->RatioOverRideFlag;
    Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRide =
        payloadREQ->RatioOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S195>/Response' */

    /* S-Function (RTC_BytePack): '<S214>/PackRSP' */
    /* Byte Packing: <S214>/PackRSP : nothing to do */
}

// PreAmpAudiopilotsetDyneqOn RTC Request-Response Handler (RTC ID 0x14210007) '<S232>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetDyneqOn(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S232>/Request' */

    /* S-Function (RTC_BytePack): '<S241>/UnpackREQ' */
    PreAmpAudiopilotsetDyneqOn_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetDyneqOn_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_dyneq_on =
        payloadREQ->dyneq_on;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S232>/Response' */

    /* S-Function (RTC_BytePack): '<S242>/PackRSP' */
    PreAmpAudiopilotsetDyneqOn_RSP_T* payloadRSP =
        (PreAmpAudiopilotsetDyneqOn_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->dyneq_on =
        Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_dyneq_on;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetAudioPilotOn RTC Request-Response Handler (RTC ID 0x14210005) '<S233>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetAudioPilotOn(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S233>/Request' */

    /* S-Function (RTC_BytePack): '<S247>/UnpackREQ' */
    PreAmpAudiopilotsetAudioPilotOn_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetAudioPilotOn_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_audiopilot_on =
        payloadREQ->audiopilot_on;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S233>/Response' */

    /* S-Function (RTC_BytePack): '<S248>/PackRSP' */
    PreAmpAudiopilotsetAudioPilotOn_RSP_T* payloadRSP =
        (PreAmpAudiopilotsetAudioPilotOn_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->audiopilot_on =
        Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_audiopilot_on;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetVNCBassBoostOverRide RTC Request-Response Handler (RTC ID 0x1422000e) '<S143>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCBassBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S143>/Request' */

    /* S-Function (RTC_BytePack): '<S156>/UnpackREQ' */
    PreAmpAudiopilotsetVNCBassBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCBassBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRideFlag
        = payloadREQ->VNCBassBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRide
        = payloadREQ->VNCBassBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S143>/Response' */

    /* S-Function (RTC_BytePack): '<S157>/PackRSP' */
    /* Byte Packing: <S157>/PackRSP : nothing to do */
}

// PreAmpAudiopilotgetBassBoost RTC Request-Response Handler (RTC ID 0x14210001) '<S69>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetBassBoost(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S69>/Request' */

    /* S-Function (RTC_BytePack): '<S90>/UnpackREQ' */
    PreAmpAudiopilotgetBassBoost_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetBassBoost_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetBassBoostRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S69>/Response' */

    /* S-Function (RTC_BytePack): '<S91>/PackRSP' */
    PreAmpAudiopilotgetBassBoost_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetBassBoost_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetBassBoostRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->bassBoost = Model_Target_B.Min;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotsetVNCMidBoostOverRide RTC Request-Response Handler (RTC ID 0x1422000f) '<S144>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotsetVNCMidBoostOverRide(void* pREQBuf, void
    * pRSPBuf)
{
    /* Output and update for function-call system: '<S144>/Request' */

    /* S-Function (RTC_BytePack): '<S162>/UnpackREQ' */
    PreAmpAudiopilotsetVNCMidBoostOverRide_REQ_T* payloadREQ =
        (PreAmpAudiopilotsetVNCMidBoostOverRide_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRideFlag
        = payloadREQ->VNCMidBoostOverRideFlag;
    Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRide
        = payloadREQ->VNCMidBoostOverRide;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S144>/Response' */

    /* S-Function (RTC_BytePack): '<S163>/PackRSP' */
    /* Byte Packing: <S163>/PackRSP : nothing to do */
}

// PreAmpAudiopilotgetMidBoost RTC Request-Response Handler (RTC ID 0x14210002) '<S70>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetMidBoost(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S70>/Request' */

    /* S-Function (RTC_BytePack): '<S96>/UnpackREQ' */
    PreAmpAudiopilotgetMidBoost_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetMidBoost_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetMidBoostRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S70>/Response' */

    /* S-Function (RTC_BytePack): '<S97>/PackRSP' */
    PreAmpAudiopilotgetMidBoost_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetMidBoost_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetMidBoostRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->midBoost = Model_Target_B.Product1;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotgetTrebleBoost RTC Request-Response Handler (RTC ID 0x14210003) '<S71>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetTrebleBoost(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S71>/Request' */

    /* S-Function (RTC_BytePack): '<S102>/UnpackREQ' */
    PreAmpAudiopilotgetTrebleBoost_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetTrebleBoost_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetTrebleBoostRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */

    /* Output and update for function-call system: '<S71>/Response' */

    /* S-Function (RTC_BytePack): '<S103>/PackRSP' */
    PreAmpAudiopilotgetTrebleBoost_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetTrebleBoost_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetTrebleBoostRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->trebleBoost = Model_Target_B.Product_h5;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpAudiopilotgetAverageAudioPilotBoostLevel RTC Request-Response Handler (RTC ID 0x14210000) '<S107>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpAudiopilotgetAverageAudioPilotBoostLevel(void* pREQBuf,
    void* pRSPBuf)
{
    /* Output and update for function-call system: '<S107>/Request' */

    /* S-Function (RTC_BytePack): '<S190>/UnpackREQ' */
    PreAmpAudiopilotgetAverageAudioPilotBoostLevel_REQ_T* payloadREQ =
        (PreAmpAudiopilotgetAverageAudioPilotBoostLevel_REQ_T*)pREQBuf;
    Model_TargetPreAmpAudiopilotgetAverageAudioPilotBoostLevelRtcOut.REQ_caller_handle
        = payloadREQ->caller_handle;

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpAudiopilotgetAverageAudioPilotBoostLevel();

    /* Output and update for function-call system: '<S107>/Response' */

    /* S-Function (RTC_BytePack): '<S191>/PackRSP' */
    PreAmpAudiopilotgetAverageAudioPilotBoostLevel_RSP_T* payloadRSP =
        (PreAmpAudiopilotgetAverageAudioPilotBoostLevel_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpAudiopilotgetAverageAudioPilotBoostLevelRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->level = Model_Target_B.boostAverage;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpVolumeCfgSet RTC Request-Response Handler (RTC ID 0x14200013) '<S535>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpVolumeCfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S535>/Request' */

    /* S-Function (RTC_BytePack): '<S547>/UnpackREQ' */
    PreAmpVolumeCfgSet_REQ_T* payloadREQ = (PreAmpVolumeCfgSet_REQ_T*)pREQBuf;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index = payloadREQ->gain_index;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_offset =
        payloadREQ->gain_offset;
    (Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpVolumeCfgSet();

    /* Output and update for function-call system: '<S535>/Response' */

    /* S-Function (RTC_BytePack): '<S548>/PackRSP' */
    PreAmpVolumeCfgSet_RSP_T* payloadRSP = (PreAmpVolumeCfgSet_RSP_T*)pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index = Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpVolumeCfgSet RTC NTF check complete '<S535>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpVolumeCfgSet( void )
{
    /* Output and update for function-call system: '<S535>/NtfCheck' */

    /* MATLAB Function: '<S551>/rgainx check sequence' */
    /* MATLAB Function: '<S551>/rgainx check sequence' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/NtfCheck': '<S544>:1' */
    /* '<S544>:1:3' go(); */
    /*  Check if the ramping is done by comparing the target and current gains. */
    /* MATLAB Function 'Rgainy/NtfCheckSubsystem/rgainx check sequence': '<S556>:1' */
    /*  Assume the work is complete until proven otherwise */
    /* '<S556>:1:7' done = true; */
    Model_Target_B.done_ef = true;

    /* '<S556>:1:8' for i=1:MaskNumRampers */
    /* '<S556>:1:9' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
    if (Model_TargetControlDsms.PreAmpVolumeCfgRampers.targetGain !=
            Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain)
    {
        /* '<S556>:1:10' done = false; */
        Model_Target_B.done_ef = false;

        /*  just proved otherwise */
    }

    /* End of MATLAB Function: '<S551>/rgainx check sequence' */

    /* Outputs for Function Call SubSystem: '<S36>/Triggered Subsystem' */
    /* SignalConversion generated from: '<S537>/In1' */
    Model_Target_B.In1_o = Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index;

    /* End of Outputs for SubSystem: '<S36>/Triggered Subsystem' */
}

// PreAmpVolumeCfgSet RTC NTF message preparation and packing '<S535>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpVolumeCfgSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S535>/Notification' */

    /* S-Function (RTC_BytePack): '<S543>/PackNTF' */
    PreAmpVolumeCfgSet_NTF_T* payloadNTF = (PreAmpVolumeCfgSet_NTF_T*)pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_o;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

// PreAmpBalance_CfgSet RTC Request-Response Handler (RTC ID 0x1b200000) '<S564>/RTC Request Response Trigger' ---------------------------
void RtcReqRsp_PreAmpBalance_CfgSet(void* pREQBuf, void* pRSPBuf)
{
    /* Output and update for function-call system: '<S564>/Request' */

    /* S-Function (RTC_BytePack): '<S583>/UnpackREQ' */
    PreAmpBalance_CfgSet_REQ_T* payloadREQ = (PreAmpBalance_CfgSet_REQ_T*)
        pREQBuf;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_caller_handle =
        payloadREQ->caller_handle;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index =
        payloadREQ->gain_index;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_db_per_second =
        payloadREQ->ramp_db_per_second;
    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_milliseconds =
        payloadREQ->ramp_milliseconds;
    (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_sequence)++;// Increment sequence

    /* End of S-Function (RTC_BytePack) REQ unpacking */
    HandleReqPreAmpBalance_CfgSet();

    /* Output and update for function-call system: '<S564>/Response' */

    /* S-Function (RTC_BytePack): '<S584>/PackRSP' */
    PreAmpBalance_CfgSet_RSP_T* payloadRSP = (PreAmpBalance_CfgSet_RSP_T*)
        pRSPBuf;
    payloadRSP->caller_handle =
        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_caller_handle;
    payloadRSP->status_code = 0;
    payloadRSP->gain_index =
        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index;

    /* End of S-Function (RTC_BytePack) RSP packing */
}

// PreAmpBalance_CfgSet RTC NTF check complete '<S564>/NTF Trigger' ---------------------------------
void RtcNtfCheck_PreAmpBalance_CfgSet( void )
{
    /* Output and update for function-call system: '<S564>/NtfCheck' */
    {
        int32_T i;
        boolean_T exitg1;

        /* MATLAB Function: '<S563>/check sequence' */
        /* MATLAB Function: '<S563>/check sequence' */
        /*  Invoke the function trigger output */
        /* MATLAB Function 'RTC/NtfCheck': '<S580>:1' */
        /* '<S580>:1:3' go(); */
        /*  Function which checks if the notification sequence */
        /*  has completed successfully  */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/Balance/Balance/check sequence': '<S577>:1' */
        /*  Assume the work is complete until proven otherwise */
        /* '<S577>:1:8' done = true; */
        Model_Target_B.done_p = true;

        /* '<S577>:1:10' for i=1:MaskNumRampers */
        i = 0;
        exitg1 = false;
        while ((!exitg1) && (i <= 3))
        {
            /* '<S577>:1:11' if (Rampers(i).targetGain ~= Rampers(i).currentGain) */
            if (Model_TargetControlDsms.PreAmpBalance_CfgRampers[i].targetGain
                    != Model_TargetControlDsms.PreAmpBalance_CfgRampers[i].
                    currentGain)
            {
                /* '<S577>:1:12' done = false; */
                Model_Target_B.done_p = false;

                /*  just proved otherwise */
                exitg1 = true;
            }
            else
            {
                i++;
            }
        }

        /* Outputs for Function Call SubSystem: '<S563>/Triggered Subsystem' */
        /* SignalConversion generated from: '<S567>/In1' */
        Model_Target_B.In1_j =
            Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index;

        /* End of Outputs for SubSystem: '<S563>/Triggered Subsystem' */
    }
}

// PreAmpBalance_CfgSet RTC NTF message preparation and packing '<S564>/NTF Trigger' ---------------------------------
void RtcNtfPack_PreAmpBalance_CfgSet(void* pNTFBuf)
{
    // This message does not specify any special signal preparation
    // Package the notification signals

    /* Output and update for function-call system: '<S564>/Notification' */

    /* S-Function (RTC_BytePack): '<S579>/PackNTF' */
    PreAmpBalance_CfgSet_NTF_T* payloadNTF = (PreAmpBalance_CfgSet_NTF_T*)
        pNTFBuf;
    payloadNTF->caller_handle =
        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_caller_handle;
    payloadNTF->status_code = 0;
    payloadNTF->gain_index = Model_Target_B.In1_j;

    /* End of S-Function (RTC_BytePack) NTF packing */
}

int32_T div_nde_s32_floor(int32_T numerator, int32_T denominator)
{
    return (((numerator < 0) != (denominator < 0)) && (numerator % denominator
             != 0) ? -1 : 0) + numerator / denominator;
}

int32_T div_nzp_s32_floor(int32_T numerator, int32_T denominator)
{
    uint32_T absDenominator;
    uint32_T absNumerator;
    uint32_T tempAbsQuotient;
    boolean_T quotientNeedsNegation;
    absNumerator = numerator < 0 ? ~(uint32_T)numerator + 1U : (uint32_T)
        numerator;
    absDenominator = denominator < 0 ? ~(uint32_T)denominator + 1U : (uint32_T)
        denominator;
    quotientNeedsNegation = ((numerator < 0) != (denominator < 0));
    tempAbsQuotient = absNumerator / absDenominator;
    if (quotientNeedsNegation)
    {
        absNumerator %= absDenominator;
        if (absNumerator > 0U)
        {
            tempAbsQuotient++;
        }
    }

    return quotientNeedsNegation ? -(int32_T)tempAbsQuotient : (int32_T)
        tempAbsQuotient;
}

/*
 * Set which subrates need to run this base step (base rate always runs).
 * This function must be called prior to calling the model step function
 * in order to remember which rates need to run this base step.  The
 * buffering of events allows for overlapping preemption.
 */
void Model_Target_SetEventsForThisBaseStep(boolean_T *eventFlags)
{
    /* Task runs when its counter is zero, computed via rtmStepTask macro */
    eventFlags[1] = ((boolean_T)rtmStepTask(Model_Target_M, 1));
    eventFlags[2] = ((boolean_T)rtmStepTask(Model_Target_M, 2));
    eventFlags[3] = ((boolean_T)rtmStepTask(Model_Target_M, 3));
    eventFlags[4] = ((boolean_T)rtmStepTask(Model_Target_M, 4));
    eventFlags[5] = ((boolean_T)rtmStepTask(Model_Target_M, 5));
    eventFlags[6] = ((boolean_T)rtmStepTask(Model_Target_M, 6));
    eventFlags[7] = ((boolean_T)rtmStepTask(Model_Target_M, 7));
    eventFlags[8] = ((boolean_T)rtmStepTask(Model_Target_M, 8));
}

/*
 *         This function updates active task flag for each subrate
 *         and rate transition flags for tasks that exchange data.
 *         The function assumes rate-monotonic multitasking scheduler.
 *         The function must be called at model base rate so that
 *         the generated code self-manages all its subrates and rate
 *         transition flags.
 */
static void rate_monotonic_scheduler(void)
{
    /* To ensure a deterministic data transfer between two rates,
     * data is transferred at the priority of a fast task and the frequency
     * of the slow task.  The following flags indicate when the data transfer
     * happens.  That is, a rate interaction flag is set true when both rates
     * will run, and false otherwise.
     */

    /* tid 2 shares data with slower tid rate: 6 */
    if (Model_Target_M->Timing.TaskCounters.TID[2] == 0)
    {
        Model_Target_M->Timing.RateInteraction.TID2_6 =
            (Model_Target_M->Timing.TaskCounters.TID[6] == 0);
    }

    /* tid 7 shares data with slower tid rate: 8 */
    if (Model_Target_M->Timing.TaskCounters.TID[7] == 0)
    {
        Model_Target_M->Timing.RateInteraction.TID7_8 =
            (Model_Target_M->Timing.TaskCounters.TID[8] == 0);
    }

    /* Compute which subrates run during the next base time step.  Subrates
     * are an integer multiple of the base rate counter.  Therefore, the subtask
     * counter is reset when it reaches its limit (zero means run).
     */
    (Model_Target_M->Timing.TaskCounters.TID[1])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[1]) > 11)
    {                         /* Sample time: [0.00066666666666666664s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[1] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[2])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[2]) > 12)
    {                         /* Sample time: [0.00072222222222222219s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[2] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[3])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[3]) > 25)
    {                          /* Sample time: [0.0014444444444444444s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[3] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[4])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[4]) > 51)
    {                          /* Sample time: [0.0028888888888888892s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[4] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[5])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[5]) > 207)
    {                           /* Sample time: [0.011555555555555557s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[5] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[6])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[6]) > 831)
    {                            /* Sample time: [0.04622222222222222s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[6] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[7])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[7]) > 3327)
    {                            /* Sample time: [0.18488888888888888s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[7] = 0;
    }

    (Model_Target_M->Timing.TaskCounters.TID[8])++;
    if ((Model_Target_M->Timing.TaskCounters.TID[8]) > 9983)
    {                            /* Sample time: [0.55466666666666664s, 0.0s] */
        Model_Target_M->Timing.TaskCounters.TID[8] = 0;
    }
}

/* System initialize for atomic system: '<Root>/InputSelect' */
void Model_Target_InputSelect_Init(void)
{
    /* user code (Initialize function Body) */

    // Hook up partition roots into global async routing table
    Model_Target_InitPartitions();
}

/* Output and update for atomic system: '<Root>/InputSelect' */
void Model_Target_InputSelect(void)
{
    int32_T rtb_FindNonzeroElements[5];
    int32_T rtb_routerMapOut[5];
    int32_T ind;
    int32_T rtb_routerMapOut_h;
    int_T linIx;
    real32_T rtb_Assignment[160];
    boolean_T rtb_OR[5];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S15>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S12>/MATLAB Function' incorporates:
     *  S-Function (TOP_MEX): '<S12>/TOP'
     */
    /*  tuneTopMap is provided via a tune variable. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages. */
    /* MATLAB Function 'InputSelect/Router/MATLAB Function': '<S14>:1' */
    /* '<S14>:1:7' Numiters=size(rtcMap,1); */
    /* '<S14>:1:8' routerMapOut = int32(tuneTopMap); */
    /* '<S14>:1:9' for ind=1:Numiters */
    for (ind = 0; ind < 5; ind++)
    {
        rtb_routerMapOut[ind] =
            Model_Target_InputSelect_p0_b0.RouterCfgOutMap[ind];

        /* '<S14>:1:10' if (rtcMap(ind)) */
        if (Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[ind] != 0)
        {
            /* '<S14>:1:11' routerMapOut(ind) = rtcMap(ind); */
            rtb_routerMapOut[ind] =
                Model_TargetInputSelectRouterCfgSetRtcOut.REQ_routerMap[ind];
        }
    }

    /* End of MATLAB Function: '<S12>/MATLAB Function' */
    /* End of Outputs for S-Function (RTC_NTF): '<S15>/NTF Trigger' */
    for (ind = 0; ind < 5; ind++)
    {
        /* S-Function (sdspperm2): '<S16>/Variable Selector' incorporates:
         *  Assignment: '<S16>/Assignment'
         *  SignalConversion generated from: '<S8>/In'
         */
        rtb_routerMapOut_h = rtb_routerMapOut[ind];
        linIx = rtb_routerMapOut_h;
        if (rtb_routerMapOut_h - 1 < 0)
        {
            linIx = 1;
        }
        else if (rtb_routerMapOut_h - 1 >= 5)
        {
            linIx = 5;
        }

        memcpy(&rtb_Assignment[ind << 5], &Model_Target_B.In[(linIx << 5) + -32],
               sizeof(real32_T) << 5U);

        /* End of S-Function (sdspperm2): '<S16>/Variable Selector' */

        /* Logic: '<S16>/OR' incorporates:
         *  Constant: '<S23>/Constant'
         *  Constant: '<S24>/Constant'
         *  RelationalOperator: '<S23>/Compare'
         *  RelationalOperator: '<S24>/Compare'
         */
        rtb_OR[ind] = ((rtb_routerMapOut_h <= 0) || (rtb_routerMapOut_h > 5));
    }

    /* Find: '<S16>/Find Nonzero Elements' incorporates:
     *  Logic: '<S16>/OR'
     */
    ind = 0;
    linIx = 0;
    for (rtb_routerMapOut_h = 0; rtb_routerMapOut_h < 5; rtb_routerMapOut_h++)
    {
        if (rtb_OR[linIx])
        {
            rtb_FindNonzeroElements[ind] = rtb_routerMapOut_h + 1;
            ind++;
        }

        linIx++;
    }

    Model_Target_DW.FindNonzeroElements_DIMS1_fm = ind;

    /* End of Find: '<S16>/Find Nonzero Elements' */

    /* Assignment: '<S16>/Assignment' incorporates:
     *  Constant: '<S16>/Constant3'
     *  Find: '<S16>/Find Nonzero Elements'
     */
    for (ind = 0; ind < Model_Target_DW.FindNonzeroElements_DIMS1_fm; ind++)
    {
        for (rtb_routerMapOut_h = 0; rtb_routerMapOut_h < 32; rtb_routerMapOut_h
                ++)
        {
            rtb_Assignment[rtb_routerMapOut_h + ((rtb_FindNonzeroElements[ind] -
                1) << 5)] = 0.0F;
        }
    }

    /* End of Assignment: '<S16>/Assignment' */
    /* S-Function (sdspperm2): '<S3>/Variable Selector1' incorporates:
     *  Assignment: '<S16>/Assignment'
     */
    for (ind = 0; ind < 2; ind++)
    {
        linIx = Model_Target_ConstP.VariableSelector1_Elements[ind];
        if (Model_Target_ConstP.VariableSelector1_Elements[ind] < 0)
        {
            linIx = 0;
        }
        else if (Model_Target_ConstP.VariableSelector1_Elements[ind] >= 5)
        {
            linIx = 4;
        }

        memcpy(&Model_Target_B.VariableSelector1[ind << 5],
               &rtb_Assignment[linIx << 5], sizeof(real32_T) << 5U);
    }

    /* End of S-Function (sdspperm2): '<S3>/Variable Selector1' */

    /* S-Function (sdspperm2): '<S3>/Variable Selector2' incorporates:
     *  Assignment: '<S16>/Assignment'
     */
    memcpy(&Model_Target_B.VariableSelector2[0], &rtb_Assignment[0], sizeof
           (real32_T) << 6U);

    /* S-Function (sdspperm2): '<S3>/Variable Selector3' incorporates:
     *  Assignment: '<S16>/Assignment'
     */
    memcpy(&Model_Target_B.VariableSelector3[0], &rtb_Assignment[128], sizeof
           (real32_T) << 5U);

    /* M-S-Function: '<S3>/FeaturePath' */
    /* MATLAB Function 'InputSelect/cross-partition buffer': '<S13>:1' */
    /* '<S13>:1:3' y = u; */
}

/* Output and update for function-call system: '<S48>/REQ' */
void HandleReqPreAmpAudiopilotsetHVACSetting(void)
{
    int32_T idx;
    int32_T low_i;
    int32_T low_ip1;
    int32_T mid_i;
    int32_T y_size_idx_0;
    real32_T b_x_data[16];
    real32_T y_data[16];
    real32_T r;
    real32_T xtmp;
    int8_T ii_data[16];
    boolean_T x[16];
    boolean_T exitg1;

    /* MATLAB Function: '<S43>/MATLAB Function' */
    /* MATLAB Function: '<S43>/MATLAB Function' incorporates:
     *  S-Function (TOP_MEX): '<S49>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S53>:1' */
    /* '<S53>:1:3' go(); */
    r = Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting;

    /*  "hvacSetting": Float value between [0,1.0], coming in as a control message */
    /*  "table": Table containing noise values corresponding to different */
    /*           HVAC settings */
    /*  "hvacDbspl": Interpolated HVAC noise value (dBSPL) */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/ConfigurationRtcInputs/Hvac/MATLAB Function': '<S47>:1' */
    /*  Ensuring the RTC hvac setting is always in the range [0,1.0] */
    /* '<S47>:1:10' if (hvacSettingRTC < 0.0) */
    if (Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting < 0.0F)
    {
        /* '<S47>:1:11' hvacSettingRTC = single(0.0); */
        r = 0.0F;
    }
    else if (Model_TargetPreAmpAudiopilotsetHVACSettingRtcOut.REQ_HVACSetting >
             1.0F)
    {
        /* '<S47>:1:12' elseif (hvacSettingRTC > 1.0) */
        /* '<S47>:1:13' hvacSettingRTC = single(1.0); */
        r = 1.0F;
    }

    /*  Since the HVACtable size is variable, the tune variable translation fills */
    /*  the empty elements with 0s. The tune translation ensures that the first */
    /*  HVAC setting will be a 0.0. Hence we extract the table upto the index of */
    /*  the trailing zero. */
    /* '<S47>:1:20' zeroIdx = find(table(:,1) == 0); */
    for (idx = 0; idx < 16; idx++)
    {
        x[idx] = (Model_Target_PreAmp_p4_b0.AudiopilotHvacTable[idx] == 0.0F);
    }

    idx = 0;
    low_i = 0;
    exitg1 = false;
    while ((!exitg1) && (low_i < 16))
    {
        if (x[low_i])
        {
            idx++;
            ii_data[idx - 1] = (int8_T)(low_i + 1);
            if (idx >= 16)
            {
                exitg1 = true;
            }
            else
            {
                low_i++;
            }
        }
        else
        {
            low_i++;
        }
    }

    if (idx < 1)
    {
        idx = 0;
    }

    /* '<S47>:1:21' if length(zeroIdx) > 1 */
    if (idx > 1)
    {
        /* '<S47>:1:22' trailingZeroIdx = zeroIdx(2); */
        /* '<S47>:1:23' tableSetting = table(1: trailingZeroIdx-1,1); */
        if (ii_data[1] - 1 < 1)
        {
            low_i = -1;
        }
        else
        {
            low_i = ii_data[1] - 2;
        }

        idx = low_i + 1;
        if (low_i >= 0)
        {
            memcpy(&b_x_data[0],
                   &(Model_Target_PreAmp_p4_b0.AudiopilotHvacTable[0]),
                   (uint32_T)(low_i + 1) * sizeof(real32_T));
        }

        /* '<S47>:1:24' tableNoise   = table(1: trailingZeroIdx-1,2); */
        if (ii_data[1] - 1 < 1)
        {
            low_i = -1;
        }
        else
        {
            low_i = ii_data[1] - 2;
        }

        y_size_idx_0 = low_i + 1;
        if (low_i >= 0)
        {
            memcpy(&y_data[0], &(Model_Target_PreAmp_p4_b0.AudiopilotHvacTable
                                 [16]), (uint32_T)(low_i + 1) * sizeof(real32_T));
        }
    }
    else
    {
        /* '<S47>:1:25' else */
        /* '<S47>:1:26' tableSetting = table(:,1); */
        idx = 16;

        /* '<S47>:1:27' tableNoise   = table(:,2); */
        y_size_idx_0 = 16;
        memcpy(&b_x_data[0], &(Model_Target_PreAmp_p4_b0.AudiopilotHvacTable[0]),
               sizeof(real32_T) << 4U);
        memcpy(&y_data[0], &(Model_Target_PreAmp_p4_b0.AudiopilotHvacTable[16]),
               sizeof(real32_T) << 4U);
    }

    /*  [tableSetting, idx] = unique(table(:,1)); */
    /*  tableNoise = table(idx,2); */
    /*  Interpolate to find where the incoming */
    /*  hvacSetting lies in the noise table. */
    /* '<S47>:1:34' hvacDbspl = interp1(tableSetting, tableNoise, hvacSettingRTC); */
    if (b_x_data[1] < b_x_data[0])
    {
        low_i = idx >> 1;
        for (low_ip1 = 0; low_ip1 < low_i; low_ip1++)
        {
            xtmp = b_x_data[low_ip1];
            b_x_data[low_ip1] = b_x_data[(idx - low_ip1) - 1];
            b_x_data[(idx - low_ip1) - 1] = xtmp;
        }

        if ((y_size_idx_0 != 0) && (y_size_idx_0 > 1))
        {
            low_i = y_size_idx_0 >> 1;
            for (low_ip1 = 0; low_ip1 < low_i; low_ip1++)
            {
                xtmp = y_data[low_ip1];
                mid_i = (y_size_idx_0 - low_ip1) - 1;
                y_data[low_ip1] = y_data[mid_i];
                y_data[mid_i] = xtmp;
            }
        }
    }

    Model_Target_B.hvacDbspl = 0.0F;
    if ((r <= b_x_data[idx - 1]) && (r >= b_x_data[0]))
    {
        low_i = 1;
        low_ip1 = 2;
        while (idx > low_ip1)
        {
            mid_i = (low_i >> 1) + (idx >> 1);
            if (((low_i & 1) == 1) && ((idx & 1) == 1))
            {
                mid_i++;
            }

            if (r >= b_x_data[mid_i - 1])
            {
                low_i = mid_i;
                low_ip1 = mid_i + 1;
            }
            else
            {
                idx = mid_i;
            }
        }

        xtmp = b_x_data[low_i - 1];
        r = qhmath_div_f(r - xtmp, b_x_data[low_i] - xtmp);
        if (r == 0.0F)
        {
            Model_Target_B.hvacDbspl = y_data[low_i - 1];
        }
        else if (r == 1.0F)
        {
            Model_Target_B.hvacDbspl = y_data[low_i];
        }
        else
        {
            xtmp = y_data[low_i - 1];
            if (xtmp == y_data[low_i])
            {
                Model_Target_B.hvacDbspl = xtmp;
            }
            else
            {
                Model_Target_B.hvacDbspl = (1.0F - r) * xtmp + r * y_data[low_i];
            }
        }
    }

    /* End of MATLAB Function: '<S43>/MATLAB Function' */
}

/*
 * Output and update for atomic system:
 *    '<S68>/ApplyBpfGain'
 *    '<S68>/ApplyLpfGain'
 */
void Model_Target_ApplyBpfGain(const real32_T rtu_audio[64], const real32_T
    rtu_gain[32], B_ApplyBpfGain_Model_Target_T *localB)
{
    int32_T i;
    real32_T rtu_gain_0[64];

    /*  This applies a frame of gains to the input audio */
    /*  It should work for any number of channels */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainApplication/Compensation/ApplyBpfGain': '<S73>:1' */
    /* '<S73>:1:5' numchan = size(audio,2); */
    /* '<S73>:1:6' out = audio .* (gain * ones(1,numchan)); */
    for (i = 0; i < 2; i++)
    {
        memcpy(&rtu_gain_0[i << 5], &rtu_gain[0], sizeof(real32_T) << 5U);
    }

    for (i = 0; i < 64; i++)
    {
        localB->out[i] = rtu_audio[i] * rtu_gain_0[i];
    }
}

/* Output and update for function-call system: '<S107>/REQ' */
void HandleReqPreAmpAudiopilotgetAverageAudioPilotBoostLevel(void)
{
    int32_T count;
    real32_T divBass;
    real32_T divMid;
    real32_T divTreble;

    /* MATLAB Function: '<S39>/AverageBoostLevel' */
    /* MATLAB Function: '<S39>/AverageBoostLevel' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S189>:1' */
    /* '<S189>:1:3' go(); */
    /*  This function calculates the average boost value for a given set of bass, */
    /*  mid, and treble boost values. A boost value is included in the average if */
    /*  the corresponding maximum boost value is greater than a threshold. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/AverageBoostLevel': '<S104>:1' */
    /*  Constants */
    /* '<S104>:1:8' cTHRESHOLD = single(1e-12); */
    /* '<S104>:1:9' cONE = single(1); */
    /*  States */
    /* '<S104>:1:13' count = single(0); */
    count = 0;

    /* '<S104>:1:14' divBass = single(0); */
    divBass = 0.0F;

    /* '<S104>:1:15' divMid = single(0); */
    divMid = 0.0F;

    /* '<S104>:1:16' divTreble = single(0); */
    divTreble = 0.0F;

    /*  The value formulates the boost as a percentage/fraction  */
    /*  of the maximum. */
    /*  If the max boost for the band is zero,  */
    /*  that band is disabled and not counted towards the average. */
    /* '<S104>:1:23' if (maxBassBoost > cTHRESHOLD) */
    if (Model_Target_PreAmp_p4_b0.AudiopilotBassMaxAudiopilotBoostDb > 1.0E-12F)
    {
        /* '<S104>:1:24' divBass = bassBoost/maxBassBoost; */
        divBass = qhmath_div_f(Model_Target_B.Product2,
                               Model_Target_PreAmp_p4_b0.AudiopilotBassMaxAudiopilotBoostDb);

        /* '<S104>:1:25' count = count + 1; */
        count = 1;
    }

    /* '<S104>:1:28' if (maxMidBoost > cTHRESHOLD) */
    if (Model_Target_PreAmp_p4_b0.AudiopilotMidrangeMaxTotalBoostDb > 1.0E-12F)
    {
        /* '<S104>:1:29' divMid = midBoost/maxMidBoost; */
        divMid = qhmath_div_f(Model_Target_B.Product1,
                              Model_Target_PreAmp_p4_b0.AudiopilotMidrangeMaxTotalBoostDb);

        /* '<S104>:1:30' count = count + 1; */
        count++;
    }

    /* '<S104>:1:33' if (maxTrebleBoost > cTHRESHOLD) */
    if (Model_Target_PreAmp_p4_b0.AudiopilotTrebleMaxTotalBoostDb > 1.0E-12F)
    {
        /* '<S104>:1:34' divTreble = trebleBoost/maxTrebleBoost; */
        divTreble = qhmath_div_f(Model_Target_B.Product_h5,
            Model_Target_PreAmp_p4_b0.AudiopilotTrebleMaxTotalBoostDb);

        /* '<S104>:1:35' count = count + 1; */
        count++;
    }

    /*  Calculate the average */
    /* '<S104>:1:40' boostAverage = (divBass + divMid + divTreble); */
    Model_Target_B.boostAverage = (divBass + divMid) + divTreble;

    /* '<S104>:1:42' if (count > cONE) */
    if (count > 1)
    {
        /* '<S104>:1:43' boostAverage = boostAverage/count; */
        Model_Target_B.boostAverage = qhmath_div_f(Model_Target_B.boostAverage,
            (real32_T)count);
    }

    /* End of MATLAB Function: '<S39>/AverageBoostLevel' */
}

/* Output and update for function-call system: '<S277>/init' */
void InitTrigger_Model_117_516_1977_115_100(void)
{
    /* MATLAB Function: '<S276>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S280>:1' */
    /* '<S280>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function': '<S278>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S278>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&RfftRefRfftBufferTwiddle1[0], &RfftRefRfftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S320>/init' */
void InitTrigger_Model_117_516_1849_50_172_156(void)
{
    /* MATLAB Function: '<S319>/PoolIirInit' */
    /* MATLAB Function: '<S319>/PoolIirInit' incorporates:
     *  Product: '<S256>/Product1'
     *  S-Function (TOP_MEX): '<S316>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S325>:1' */
    /* '<S325>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S322>:1' */
    /*  Extract configuration information from inputs */
    /* '<S322>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S322>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S322>:1:24' VariantStr = char(VariantUint8); */
    /* '<S322>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S322>:1:28' else */
    /* '<S322>:1:29' switch(VariantStr) */
    /* '<S322>:1:30' case{"Hexagon"} */
    /* '<S322>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S322>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S322>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&HFAA13856states[0], &HFAA49482PoolIirAudioIn[0], 32U, 5U,
                 &(Model_Target_PreAmp_p4_b0.AudiopilotHfNoisePreprocessAntiAliasPooliirNumStages
                   [0]), &HFAA24880PoolIirCoeffs[0], &HFAA13856states[0], 97U,
                 1U, 40U);

    /* '<S322>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S328>/init' */
void InitTrigger_Model_117_516_1849_50_172_192(void)
{
    /* MATLAB Function: '<S327>/SignalBreakFcn' */
    /* MATLAB Function: '<S327>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S316>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S330>:1' */
    /* '<S330>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S329>:1' */
    /* '<S329>:1:3' y = u; */
    memcpy(&HFAA24880PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p4_b0.AudiopilotHfNoisePreprocessAntiAliaspooliirCoeffs
             [0]), 45U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S336>/init' */
void InitTrigger_Model_117_516_1847_50_172_156(void)
{
    /* MATLAB Function: '<S335>/PoolIirInit' */
    /* MATLAB Function: '<S335>/PoolIirInit' incorporates:
     *  Concatenate: '<S256>/Matrix Concatenate'
     *  S-Function (TOP_MEX): '<S332>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S341>:1' */
    /* '<S341>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S338>:1' */
    /*  Extract configuration information from inputs */
    /* '<S338>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S338>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S338>:1:24' VariantStr = char(VariantUint8); */
    /* '<S338>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S338>:1:28' else */
    /* '<S338>:1:29' switch(VariantStr) */
    /* '<S338>:1:30' case{"Hexagon"} */
    /* '<S338>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S338>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S338>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&HFBPFilt30618states[0], &HFBPFilt37133PoolIirAudioIn[0], 32U,
                 5U,
                 &(Model_Target_PreAmp_p4_b0.AudiopilotHfNoisePreprocessBandpassLowpassPooliirNumStages
                   [0]), &HFBPFilt63687PoolIirCoeffs[0], &HFBPFilt30618states[0],
                 161U, 1U, 72U);

    /* '<S338>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S344>/init' */
void InitTrigger_Model_117_516_1847_50_172_192(void)
{
    /* MATLAB Function: '<S343>/SignalBreakFcn' */
    /* MATLAB Function: '<S343>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S332>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S346>:1' */
    /* '<S346>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S345>:1' */
    /* '<S345>:1:3' y = u; */
    memcpy(&HFBPFilt63687PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p4_b0.AudiopilotHfNoisePreprocessBandpassLowpasspooliirCoeffs
             [0]), 77U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S378>/init' */
void InitTrigger_Model_117_517_563_115_100(void)
{
    /* MATLAB Function: '<S377>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S381>:1' */
    /* '<S381>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function': '<S379>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S379>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&LfRfftWindowRfftBufferTwiddle1[0],
              &LfRfftWindowRfftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S402>/init' */
void InitTrigger_Model_117_517_515_50_172_156(void)
{
    /* MATLAB Function: '<S401>/PoolIirInit' */
    /* MATLAB Function: '<S401>/PoolIirInit' incorporates:
     *  Gain: '<S397>/Gain'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S407>:1' */
    /* '<S407>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S404>:1' */
    /*  Extract configuration information from inputs */
    /* '<S404>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S404>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S404>:1:24' VariantStr = char(VariantUint8); */
    /* '<S404>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S404>:1:28' else */
    /* '<S404>:1:29' switch(VariantStr) */
    /* '<S404>:1:30' case{"Hexagon"} */
    /* '<S404>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S404>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S404>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&LPMicFilt61359states[0], &LPMicFilt1725PoolIirAudioIn[0], 32U,
                 1U,
                 &(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseMicPooliirNumStages),
                 &LPMicFilt39390PoolIirCoeffs[0], &LPMicFilt61359states[0], 41U,
                 1U, 12U);

    /* '<S404>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S410>/init' */
void InitTrigger_Model_117_517_515_50_172_192(void)
{
    int32_T i;

    /* MATLAB Function: '<S409>/SignalBreakFcn' */
    /* MATLAB Function: '<S409>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S398>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S412>:1' */
    /* '<S412>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S411>:1' */
    /* '<S411>:1:3' y = u; */
    for (i = 0; i < 13; i++)
    {
        LPMicFilt39390PoolIirCoeffs[i] =
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseMicpooliirCoeffs[i];
    }

    /* End of MATLAB Function: '<S409>/SignalBreakFcn' */
}

/* Output and update for function-call system: '<S418>/init' */
void InitTrigger_Model_117_517_516_50_172_156(void)
{
    /* MATLAB Function: '<S417>/PoolIirInit' */
    /* MATLAB Function: '<S417>/PoolIirInit' incorporates:
     *  Product: '<S249>/MuteLF'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S423>:1' */
    /* '<S423>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S420>:1' */
    /*  Extract configuration information from inputs */
    /* '<S420>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S420>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S420>:1:24' VariantStr = char(VariantUint8); */
    /* '<S420>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S420>:1:28' else */
    /* '<S420>:1:29' switch(VariantStr) */
    /* '<S420>:1:30' case{"Hexagon"} */
    /* '<S420>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S420>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S420>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&LFRefFilt15698states[0], &LFRefFilt33927PoolIirAudioIn[0], 32U,
                 1U,
                 &(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseRefPooliirNumStages),
                 &LFRefFilt39774PoolIirCoeffs[0], &LFRefFilt15698states[0], 41U,
                 1U, 12U);

    /* '<S420>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S426>/init' */
void InitTrigger_Model_117_517_516_50_172_192(void)
{
    int32_T i;

    /* MATLAB Function: '<S425>/SignalBreakFcn' */
    /* MATLAB Function: '<S425>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S414>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S428>:1' */
    /* '<S428>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S427>:1' */
    /* '<S427>:1:3' y = u; */
    for (i = 0; i < 13; i++)
    {
        LFRefFilt39774PoolIirCoeffs[i] =
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseRefpooliirCoeffs[i];
    }

    /* End of MATLAB Function: '<S425>/SignalBreakFcn' */
}

/*
 * System initialize for atomic system:
 *    '<S491>/InnerLink'
 *    '<S504>/InnerLink'
 */
void Model_Target_InnerLink_Init(DW_InnerLink_Model_Target_T *localDW)
{
    localDW->holdFlag = 1.0;
}

/*
 * Output and update for atomic system:
 *    '<S491>/InnerLink'
 *    '<S504>/InnerLink'
 */
void Model_Target_InnerLink(real32_T rtu_rmsInput, real32_T rtu_peakInput,
    real32_T rtu_predictionDbspl, real32_T rtu_slowDecayDbPerSample, real32_T
    rtu_holdMarginDb, real32_T rtu_holdTimeSamples, real32_T
    rtu_fastDecayDbPerSample, real32_T rtu_minVolumeDb, real32_T rtu_maxVolumeDb,
    real32_T rtu_volumeDb, real_T rtu_AnnTrigger, real32_T rtu_mode1,
    B_InnerLink_Model_Target_T *localB, DW_InnerLink_Model_Target_T *localDW)
{
    real32_T input1;
    input1 = rtu_rmsInput;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'LevelDetector': '<S495>:1' */
    /*  States */
    /* '<S495>:1:11' if (isempty(holdFlag)) */
    if (!localDW->holdFlag_not_empty)
    {
        /* '<S495>:1:12' holdFlag = 1; */
        localDW->holdFlag_not_empty = true;

        /* '<S495>:1:13' holdState = 0; */
        /* '<S495>:1:14' envelope1 = -abs(minVolumeDb); */
        localDW->envelope1 = -qhmath_abs_f(rtu_minVolumeDb);
    }

    /*  By default we use the RMS input */
    /* '<S495>:1:18' input1 = rmsInput; */
    /* '<S495>:1:19' level = single(0.0); */
    localB->level = 0.0F;

    /* '<S495>:1:21' if mode1 >= 0.0 */
    if (rtu_mode1 >= 0.0F)
    {
        real32_T delta;

        /*  Choose input1 based on mode1 */
        /* '<S495>:1:23' if (mode1 > 0.0) */
        if (rtu_mode1 > 0.0F)
        {
            /* '<S495>:1:24' input1 = peakInput; */
            input1 = rtu_peakInput;
        }

        /* '<S495>:1:26' delta = single( envelope1 - input1 ); */
        delta = localDW->envelope1 - input1;

        /* '<S495>:1:27' if ( delta <= single(0) ) */
        if (delta <= 0.0F)
        {
            /*  Attack phase */
            /* '<S495>:1:29' envelope1 = input1; */
            localDW->envelope1 = input1;

            /* '<S495>:1:30' holdState = 0; */
            localDW->holdState = 0.0;

            /* '<S495>:1:31' holdFlag = 1; */
            localDW->holdFlag = 1.0;
        }
        else
        {
            /* '<S495>:1:32' else */
            /*  Slow Decay phase */
            /* '<S495>:1:34' coef = slowDecayDbPerSample; */
            input1 = rtu_slowDecayDbPerSample;

            /*  Hold phase */
            /* '<S495>:1:37' if ( delta >= holdMarginDb ) */
            if (delta >= rtu_holdMarginDb)
            {
                /* '<S495>:1:38' holdState = holdState + 1; */
                localDW->holdState++;

                /* '<S495>:1:39' if ( holdState > holdTimeSamples ) */
                if (localDW->holdState > rtu_holdTimeSamples)
                {
                    /* '<S495>:1:40' holdFlag = 0; */
                    localDW->holdFlag = 0.0;
                }
            }
            else
            {
                /* '<S495>:1:42' else */
                /* '<S495>:1:43' holdState = 0; */
                localDW->holdState = 0.0;
            }

            /*  Fast decay phase */
            /* '<S495>:1:47' if holdFlag == 0 */
            if (localDW->holdFlag == 0.0)
            {
                /* '<S495>:1:48' coef = fastDecayDbPerSample; */
                input1 = rtu_fastDecayDbPerSample;
            }

            /*  Super fast decay phase */
            /* '<S495>:1:52' if ( AnnTrigger > AnnTriggerThreshold ) */
            if (rtu_AnnTrigger > 0.5)
            {
                /* '<S495>:1:53' coef = SuperFastDecayMultiplier * fastDecayDbPerSample; */
                input1 = Model_Target_SuperFastDecayMultiplier *
                    rtu_fastDecayDbPerSample;
            }

            /*  Update the envelope1 */
            /* '<S495>:1:57' envelope1 = envelope1 + coef; */
            localDW->envelope1 += input1;
        }

        /*  Boundary Check */
        /* '<S495>:1:60' envelope1 = max(minVolumeDb, envelope1); */
        localDW->envelope1 = fmaxf(rtu_minVolumeDb, localDW->envelope1);

        /* '<S495>:1:61' envelope1 = min(maxVolumeDb, envelope1); */
        localDW->envelope1 = fminf(rtu_maxVolumeDb, localDW->envelope1);

        /*  dBSPL Conversion */
        /* '<S495>:1:64' level = max(0, envelope1 + predictionDbspl + volumeDb); */
        localB->level = fmaxf(0.0F, (localDW->envelope1 + rtu_predictionDbspl) +
                              rtu_volumeDb);
    }
}

/* Output and update for function-call system: '<S523>/init' */
void InitTrigger_Model_120_422_50_172_156(void)
{
    /* MATLAB Function: '<S522>/PoolIirInit' */
    /* MATLAB Function: '<S522>/PoolIirInit' incorporates:
     *  Gain: '<S518>/Gain'
     *  S-Function (TOP_MEX): '<S519>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S528>:1' */
    /* '<S528>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S525>:1' */
    /*  Extract configuration information from inputs */
    /* '<S525>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S525>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S525>:1:24' VariantStr = char(VariantUint8); */
    /* '<S525>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S525>:1:28' else */
    /* '<S525>:1:29' switch(VariantStr) */
    /* '<S525>:1:30' case{"Hexagon"} */
    /* '<S525>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S525>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S525>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&Default13908states[0], &Default59515PoolIirAudioIn[0], 32U, 2U,
                 &(Model_Target_PreAmp_p4_b0.LevelDetectPreemphasisPooliirNumStages
                   [0]), &Default16984PoolIirCoeffs[0], &Default13908states[0],
                 33U, 1U, 8U);

    /* '<S525>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S531>/init' */
void InitTrigger_Model_120_422_50_172_192(void)
{
    int32_T i;

    /* MATLAB Function: '<S530>/SignalBreakFcn' */
    /* MATLAB Function: '<S530>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S519>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S533>:1' */
    /* '<S533>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S532>:1' */
    /* '<S532>:1:3' y = u; */
    for (i = 0; i < 10; i++)
    {
        Default16984PoolIirCoeffs[i] =
            Model_Target_PreAmp_p4_b0.LevelDetectPreemphasispooliirCoeffs[i];
    }

    /* End of MATLAB Function: '<S530>/SignalBreakFcn' */
}

/* Output and update for function-call system: '<S534>/lookup db from index' */
void Model_Target_lookupdbfromindex(const uint32_T rtu_volTableIdx[8], const
    real32_T rtu_volTabledB[8], uint32_T rtu_idx, int32_T rtu_db_offset,
    real32_T rtu_maxgain, B_lookupdbfromindex_Model_Target_T *localB)
{
    int32_T db_offset;
    int32_T tmp;
    real32_T percent;
    uint32_T idx;
    uint8_T j;
    boolean_T exitg1;
    idx = rtu_idx;
    db_offset = rtu_db_offset;

    /*  */
    /*  Lookup volume table  */
    /*  Output Gain vlue from table */
    /*  */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Volume/Index2DbTable/lookup db from index': '<S542>:1' */
    /* '<S542>:1:8' j = uint8(1); */
    j = 1U;

    /* '<S542>:1:9' gain_value = single(0.0); */
    localB->gain_value = 0.0F;

    /* '<S542>:1:10' interpolated_gain_dB=single(0.0); */
    /* '<S542>:1:11' interpolated_gain_dB_with_offset=single(0.0); */
    /*  workaround to type problem */
    /* '<S542>:1:14' idx = cast(idx, class(volTableIdx(end))); */
    /*   bounds checking for vol - clip to max idx */
    /* '<S542>:1:17' if (idx > volTableIdx(end)) */
    if (rtu_idx > rtu_volTableIdx[7])
    {
        /* '<S542>:1:18' idx = volTableIdx(end); */
        idx = rtu_volTableIdx[7];
    }

    /*   bounds checking for gain offset(No Boost) - clip to max offset level */
    /* '<S542>:1:21' if (db_offset > int32(maxgain)) */
    percent = roundf(rtu_maxgain);
    if (percent < 2.14748365E+9F)
    {
        if (percent >= -2.14748365E+9F)
        {
            tmp = (int32_T)percent;
        }
        else
        {
            tmp = MIN_int32_T;
        }
    }
    else
    {
        tmp = MAX_int32_T;
    }

    if (rtu_db_offset > tmp)
    {
        /* '<S542>:1:22' db_offset = int32(maxgain); */
        if (percent < 2.14748365E+9F)
        {
            if (percent >= -2.14748365E+9F)
            {
                db_offset = (int32_T)percent;
            }
            else
            {
                db_offset = MIN_int32_T;
            }
        }
        else
        {
            db_offset = MAX_int32_T;
        }
    }

    /* '<S542>:1:24' if (db_offset < int32(-10.0)) */
    if (db_offset < -10)
    {
        /* '<S542>:1:25' db_offset = int32(-10.0); */
        db_offset = -10;
    }

    /*  search through volume table to find index closest to vol */
    /* '<S542>:1:29' while (j <= numel(volTableIdx)) */
    exitg1 = false;
    while ((!exitg1) && (j <= 8))
    {
        uint32_T q0;

        /* '<S542>:1:30' if (idx <= volTableIdx(j)) */
        q0 = rtu_volTableIdx[j - 1];
        if (idx <= q0)
        {
            /* '<S542>:1:31' if (j <= 1) */
            if (j <= 1)
            {
                /*  first indexed value is linearly interpolated to zero */
                /* '<S542>:1:32' if (volTableIdx(j)) */
                if (rtu_volTableIdx[0] != 0U)
                {
                    /* '<S542>:1:33' percent = single(idx) / single(volTableIdx(j)); */
                    percent = qhmath_div_f((real32_T)idx, (real32_T)
                                           rtu_volTableIdx[0]);
                }
                else
                {
                    /* '<S542>:1:34' else */
                    /* '<S542>:1:35' percent = single(1); */
                    percent = 1.0F;
                }

                /* '<S542>:1:37' gain_value = percent * 10 ^ ( (volTabledB(j)+ single(db_offset)) / 20); */
                localB->gain_value = qhmath_pow_f(10.0F, qhmath_div_f
                    (rtu_volTabledB[0] + (real32_T)db_offset, 20.0F)) * percent;
            }
            else
            {
                uint32_T qY;
                uint32_T qY_tmp;

                /* '<S542>:1:38' else */
                /*  other values are interpolated in db space */
                /* '<S542>:1:39' lastIdx = volTableIdx(j-1); */
                /* '<S542>:1:40' percent = single(idx - lastIdx) / single(volTableIdx(j) - lastIdx); */
                /* '<S542>:1:41' interpolated_gain_dB = (percent * (volTabledB(j) - volTabledB(j-1) ) ) + volTabledB(j-1); */
                /* '<S542>:1:42' interpolated_gain_dB_with_offset= interpolated_gain_dB + single(db_offset); */
                /* '<S542>:1:43' gain_value = 10 ^ ( (interpolated_gain_dB_with_offset) / 20); */
                qY_tmp = rtu_volTableIdx[j - 2];
                qY = idx - /*MW:OvSatOk*/ qY_tmp;
                if (qY > idx)
                {
                    qY = 0U;
                }

                idx = q0 - /*MW:OvSatOk*/ qY_tmp;
                if (idx > q0)
                {
                    idx = 0U;
                }

                percent = rtu_volTabledB[j - 2];
                localB->gain_value = qhmath_pow_f(10.0F, qhmath_div_f
                    (((rtu_volTabledB[j - 1] - percent) * qhmath_div_f((real32_T)
                    qY, (real32_T)idx) + percent) + (real32_T)db_offset, 20.0F));
            }

            exitg1 = true;
        }
        else
        {
            /* '<S542>:1:46' else */
            /* '<S542>:1:47' j = j + 1; */
            j++;
        }
    }
}

/* Output and update for function-call system: '<S36>/ramp parameters' */
void Model_Target_rampparameters(uint32_T rtu_rampRateRTC, uint32_T
    rtu_rampTimeRTC, real32_T rtu_rampTimeTune, B_rampparameters_Model_Target_T *
    localB)
{
    real32_T y;
    y = rtu_rampTimeTune;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Volume/ramp parameters': '<S539>:1' */
    /*  Ramp time and rate are provided to the block through RTC messages. However  */
    /*  in case neither of them are provided, the block will use the default ramp  */
    /*  time given in the tune variables. */
    /* '<S539>:1:9' ramptime = single(rampTimeTune); */
    /* '<S539>:1:10' rampRate = single(0); */
    localB->rampRate = 0.0F;

    /* '<S539>:1:12' if (rampRateRTC) */
    if (rtu_rampRateRTC != 0U)
    {
        /* '<S539>:1:13' rampRate = single(rampRateRTC); */
        /* '<S539>:1:14' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S539>:1:15' rampRate = min(rampRateBounds(2), rampRate); */
        localB->rampRate = fminf(50000.0F, fmaxf(5.0F, (real32_T)rtu_rampRateRTC));
    }

    /* '<S539>:1:17' if (rampTimeRTC) */
    if (rtu_rampTimeRTC != 0U)
    {
        /* '<S539>:1:18' ramptime = single(rampTimeRTC); */
        y = (real32_T)rtu_rampTimeRTC;
    }

    /* '<S539>:1:20' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S539>:1:21' ramptime = min(rampTimeBounds(2), ramptime); */
    localB->ramptime = fminf(3000.0F, fmaxf(1.0F, y));
}

/*
 * Output and update for function-call system:
 *    '<S550>/SetDsm'
 *    '<S550>/SetDsm1'
 */
void Model_Target_SetDsm(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S553>/Data Store Write' incorporates:
     *  Constant: '<S553>/Constant'
     */
    Model_TargetControlDsms.PreAmpVolumeCfgFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S550>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol(real32_T rtu_target_gains_linear, real32_T
    rtu_db_per_sec, real32_T rtu_ramp_times_ms, real32_T
    rtu_sample_rate_in_hertz, real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S555>:1' */
    /* '<S555>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S555>:1:23' numGains = numel(target_gains_linear); */
    /* '<S555>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S555>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S555>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.PreAmpVolumeCfgRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S555>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S555>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = rtu_ramp_times_ms;

        /* '<S555>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S555>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain,
             5.0118723E-7F);

        /* '<S555>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S555>:1:49' if (ramp_dbPerSec) */
        if (rtu_db_per_sec != 0.0F)
        {
            /* '<S555>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S555>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S555>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S555>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)),
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S555>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S555>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S555>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S555>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S555>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S555>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.PreAmpVolumeCfgRampers.rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain, currentGain)),
                          qhmath_div_f(numFrames * quantum_ms *
               rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S555>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount = (int32_T)
            numFrames;

        /* '<S555>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S555>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S555>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain = currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S535>/REQ' */
void HandleReqPreAmpVolumeCfgSet(void)
{
    /* MATLAB Function: '<S534>/lookup db from index' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S546>:1' */
    /* '<S546>:1:3' go(); */
    Model_Target_lookupdbfromindex
        (&(Model_Target_PreAmp_p4_b0.VolumeCfgTable_Idx[0]),
         &(Model_Target_PreAmp_p4_b0.VolumeCfgTable_dB[0]),
         Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_index,
         Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_gain_offset,
         Model_Target_PreAmp_p4_b0.VolumeCfgmaxgain,
         &Model_Target_B.sf_lookupdbfromindex);

    /* MATLAB Function: '<S36>/ramp parameters' */
    Model_Target_rampparameters
        (Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetPreAmpVolumeCfgSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_PreAmp_p4_b0.VolumeCfgRampTime,
         &Model_Target_B.sf_rampparameters);

    /* Outputs for Function Call SubSystem: '<S550>/SetDsm' */
    Model_Target_SetDsm(1U);

    /* End of Outputs for SubSystem: '<S550>/SetDsm' */

    /* MATLAB Function: '<S550>/rgainy ramper control' */
    /* MATLAB Function: '<S550>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S550>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol
        (Model_Target_B.sf_lookupdbfromindex.gain_value,
         Model_Target_B.sf_rampparameters.rampRate,
         Model_Target_B.sf_rampparameters.ramptime, 44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S550>/SetDsm1' */
    Model_Target_SetDsm(0U);

    /* End of Outputs for SubSystem: '<S550>/SetDsm1' */
}

/* Output and update for atomic system: '<S549>/rgainy process' */
void Model_Target_rgainyprocess(const uint8_T rtu_rampToChanMap[3], const
    real32_T rtu_audioIn[64], B_rgainyprocess_Model_Target_T *localB)
{
    int32_T b_tmp;
    int32_T chanCount;
    int32_T n;
    real32_T gain;
    real32_T k;
    uint8_T d;
    uint8_T noRampChannel;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S552>:1' */
    /*  set the size of the output buffer */
    /* '<S552>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S552>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S552>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut[0] = 1.0F;
    localB->gainOut[1] = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S552>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S552>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S552>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S552>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain;

    /* '<S552>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.PreAmpVolumeCfgFreeze == 0U)
    {
        /* '<S552>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S552>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.PreAmpVolumeCfgRampers.targetGain;
        }
        else
        {
            /* '<S552>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S552>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpVolumeCfgRampers.rampCoeff;

            /* '<S552>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount =
                Model_TargetControlDsms.PreAmpVolumeCfgRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S552>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S552>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S552>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        for (chanCount = 0; chanCount < b_tmp; chanCount++)
        {
            int32_T audioOut_tmp;

            /* '<S552>:1:38' chanIdx = rampToChanMap(chanIterator + chanCount); */
            /* '<S552>:1:39' audioOut(n,chanIdx) = audioIn(n,chanIdx) * gain; */
            audioOut_tmp = ((rtu_rampToChanMap[(uint8_T)((uint32_T)chanCount +
                              2U) - 1] - 1) << 5) + n;
            localB->audioOut[audioOut_tmp] = rtu_audioIn[audioOut_tmp] * gain;
        }
    }

    /* '<S552>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S552>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S552>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut[rtu_rampToChanMap[(uint8_T)((uint32_T)n + 2U) - 1] - 1] =
            gain;
    }

    /* '<S552>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpVolumeCfgRampers.currentGain = gain;

    /* '<S552>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S552>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    d = (uint8_T)(rtu_rampToChanMap[0] + 2U);
    for (noRampChannel = d; noRampChannel < 4; noRampChannel++)
    {
        uint8_T chanIdx;

        /* '<S552>:1:51' chanIdx = rampToChanMap(noRampChannel); */
        chanIdx = rtu_rampToChanMap[noRampChannel - 1];

        /* '<S552>:1:52' for n=1:frame_size */
        /* '<S552>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[(chanIdx << 5) + -32], &rtu_audioIn[(chanIdx <<
                5) + -32], sizeof(real32_T) << 5U);
    }
}

/*
 * Output and update for function-call system:
 *    '<S563>/SetDsm'
 *    '<S563>/SetDsm1'
 */
void Model_Target_SetDsm_c(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S565>/Data Store Write' incorporates:
     *  Constant: '<S565>/Constant'
     */
    Model_TargetControlDsms.PreAmpBalance_CfgFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S563>/control' */
void Model_Target_control(const real32_T rtu_targetGainLinear[4], real32_T
    rtu_rampdbPerSec, real32_T rtu_rampTimesMs, real32_T rtu_sampleRateInHertz,
    real32_T rtu_frameSize)
{
    real32_T currentGainLinear_idx_0;
    real32_T currentGainLinear_idx_1;
    real32_T currentGainLinear_idx_2;
    real32_T currentGainLinear_idx_3;
    real32_T diff_idx_0;
    real32_T diff_idx_1;
    real32_T diff_idx_2;
    real32_T diff_idx_3;
    real32_T quantumMs;
    real32_T targetGainLinear;
    real32_T targetGainLinear_0;
    real32_T targetGainLinear_1;
    real32_T targetGainLinear_2;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/Balance/Balance/control': '<S578>:1' */
    /*  CONTROL LOGIC: */
    /*  Shift of 'balance' between the 'Right' and 'Left' channel groups is */
    /*  achieved by multiplying the corresponding 'cut' or 'boost' gain. As the */
    /*  index increases from 0, the balance shifts from left to right. Channels */
    /*  corresponding to the 'center' group are not modified.  */
    /*  rampdbPerSec takes precidence: */
    /*  If dbPerSec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the dbPerSec is used to determine ramper timing. */
    /*  Inputs: */
    /*    targetGainLinear: Indicates the gain (in linear scale) which needs to */
    /*        be applied to the audio. Gain values can be mapped to the ramper */
    /*        configuration. */
    /*    rampTimeMs: Indicates the time in milliseconds in which the gain of the */
    /*        rampers must change from their current to target values. */
    /*    rampdbPerSecond: Indicates the rate in dB/second at which the gain of the */
    /*        rampers must change from their current to target values. If this */
    /*        value is non-zero, it is used to compute the ramp time and */
    /*        'rampTimeMs' is discarded (if specified). */
    /*    rgain_SILENT_GAIN: Parameter defined in the initFcn callback. */
    /*  Control Data: */
    /*    Freeze(1) freezes the processing during this control operation */
    /*    Rampers(1) is the ramper for the 'Left' group. Boost vs. cut  */
    /*         is determined by the value of the balance index. */
    /*    Rampers(2) is the ramper for the 'Right' group. Boost vs. cut is determined by */
    /*         the value of the balance index. */
    /*    Rampers(3) is the ramper for the 'Center' group. Boost vs. cut is determined by */
    /*         the value of the balance index. */
    /*    Rampers(4) is the ramper for the 'Mono' group (supporting "Sleeping */
    /*        Beauty Mutes Bass"). Boost vs. cut is determined by the value of  */
    /*        the balance index. */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /*  This block replaces much of rgainy, but uses its own silent gain value. */
    /*  The reason why is not documented, but it does impact all the test cases. */
    /*  Use this special value instead of RgainBusUtil.GetSilentGainLinear */
    /* '<S578>:1:46' rgain_SILENT_GAIN = single(10^(-126/20)); */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /*  UPDATE: This will now loop over 4 rampers */
    /* '<S578>:1:57' currentGainLinear = zeros(1,MaskNumRampers,'single'); */
    /* '<S578>:1:58' for i = 1:MaskNumRampers */
    /* '<S578>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_0 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].currentGain,
         5.0118723E-7F);

    /* '<S578>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear = fmaxf(rtu_targetGainLinear[0], 5.0118723E-7F);

    /* '<S578>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_1 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].currentGain,
         5.0118723E-7F);

    /* '<S578>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear_0 = fmaxf(rtu_targetGainLinear[1], 5.0118723E-7F);

    /* '<S578>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_2 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].currentGain,
         5.0118723E-7F);

    /* '<S578>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear_1 = fmaxf(rtu_targetGainLinear[2], 5.0118723E-7F);

    /* '<S578>:1:59' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
    currentGainLinear_idx_3 = fmaxf
        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].currentGain,
         5.0118723E-7F);

    /* '<S578>:1:60' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
    targetGainLinear_2 = fmaxf(rtu_targetGainLinear[3], 5.0118723E-7F);

    /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
    /*  and instead calculate a new ramp time that matches the slope. */
    /* '<S578>:1:65' rampMs = zeros(1,MaskNumRampers,'single'); */
    /* '<S578>:1:66' if (rampdbPerSec) */
    if (rtu_rampdbPerSec != 0.0F)
    {
        /* '<S578>:1:67' currentGainDb = 20*log10(currentGainLinear); */
        /* '<S578>:1:68' targetGainDb = 20*log10(targetGainLinear); */
        /* '<S578>:1:69' diff = abs(currentGainDb - targetGainDb); */
        /* '<S578>:1:70' rampMs = diff / single(rampdbPerSec) * 1000; */
        diff_idx_0 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_0) - 20.0F * qhmath_log10_f(targetGainLinear)),
            rtu_rampdbPerSec) * 1000.0F;
        diff_idx_1 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_1) - 20.0F * qhmath_log10_f
            (targetGainLinear_0)), rtu_rampdbPerSec) * 1000.0F;
        diff_idx_2 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_2) - 20.0F * qhmath_log10_f
            (targetGainLinear_1)), rtu_rampdbPerSec) * 1000.0F;
        diff_idx_3 = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
            (currentGainLinear_idx_3) - 20.0F * qhmath_log10_f
            (targetGainLinear_2)), rtu_rampdbPerSec) * 1000.0F;
    }
    else
    {
        /* '<S578>:1:71' else */
        /* '<S578>:1:72' rampMs(:) = single(rampTimesMs); */
        diff_idx_0 = rtu_rampTimesMs;
        diff_idx_1 = rtu_rampTimesMs;
        diff_idx_2 = rtu_rampTimesMs;
        diff_idx_3 = rtu_rampTimesMs;
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S578>:1:79' quantumMs = 1000 * frameSize / sampleRateInHertz; */
    quantumMs = qhmath_div_f(1000.0F * rtu_frameSize, rtu_sampleRateInHertz);

    /* '<S578>:1:80' numFrames = rampMs / quantumMs; */
    /* '<S578>:1:81' numFrames = max (1, ceil(numFrames)); */
    /* '<S578>:1:82' quantizedRampTimeMs = numFrames * quantumMs; */
    /*  UPDATE: Loop over 4 rampers now (L, R, C, and Mono) */
    /* '<S578>:1:85' for ramper=1:MaskNumRampers */
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_0, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S578>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S578>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S578>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].frameCount = (int32_T)
        diff_idx_0;

    /* '<S578>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].targetGain =
        targetGainLinear;

    /* '<S578>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear,
            currentGainLinear_idx_0)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S578>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[0].currentGain =
        currentGainLinear_idx_0;
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_1, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S578>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S578>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S578>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].frameCount = (int32_T)
        diff_idx_0;

    /* '<S578>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].targetGain =
        targetGainLinear_0;

    /* '<S578>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear_0,
            currentGainLinear_idx_1)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S578>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[1].currentGain =
        currentGainLinear_idx_1;
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_2, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S578>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S578>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S578>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].frameCount = (int32_T)
        diff_idx_0;

    /* '<S578>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].targetGain =
        targetGainLinear_1;

    /* '<S578>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear_1,
            currentGainLinear_idx_2)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S578>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[2].currentGain =
        currentGainLinear_idx_2;
    diff_idx_0 = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(diff_idx_3, quantumMs)));

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S578>:1:98' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
    /* '<S578>:1:99' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
    /*  Output control signals */
    /* '<S578>:1:102' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].frameCount = (int32_T)
        diff_idx_0;

    /* '<S578>:1:103' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].targetGain =
        targetGainLinear_2;

    /* '<S578>:1:104' Rampers(ramper).rampCoeff = single(RampCoef); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].rampCoeff = qhmath_exp_f
        (qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGainLinear_2,
            currentGainLinear_idx_3)), qhmath_div_f(diff_idx_0 * quantumMs *
           rtu_sampleRateInHertz, 1000.0F)));

    /* '<S578>:1:105' Rampers(ramper).currentGain = currentGainLinear(ramper); */
    Model_TargetControlDsms.PreAmpBalance_CfgRampers[3].currentGain =
        currentGainLinear_idx_3;

    /*  unfreeze the gain (This step is done outside on canvas now) */
}

/* Output and update for function-call system: '<S564>/REQ' */
void HandleReqPreAmpBalance_CfgSet(void)
{
    real32_T targetGains_h[4];
    real32_T boost_linear;
    real32_T cut_linear;
    real32_T left;
    uint8_T j;
    boolean_T exitg1;

    /* MATLAB Function: '<S563>/calculate_balance_gain' */
    /* MATLAB Function: '<S563>/calculate_balance_gain' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S582>:1' */
    /* '<S582>:1:3' go(); */
    /*  Computes the balance gains for the 'left' and 'right' channel groups.  */
    /*  Based on the position of the balance index in 'balanceTableIdx', the  */
    /*  corresponding 'cut' gain is computed from the 'balanceTableDb'. If the  */
    /*  index lies between two entries in the table, the gain is computed by  */
    /*  linear interpolation between the corresponding gain table entries.  */
    /*  The 'boost' gain is computed based from the 'cut' gain depending on the */
    /*  value of the tune variable, 'boostDisable'. If set to '1', boost is 0 dB  */
    /*  and if '0', in order to preserve energy, the boost is computed based on */
    /*  the following equation: Boost^2 + Cut^2 = 2.  */
    /*  If 'silent extreme' is enabled and the index at either extreme is */
    /*  requested, channels belonging to the group which receives a gain 'cut' */
    /*  are muted. */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/Balance/Balance/calculate_balance_gain': '<S575>:1' */
    /* '<S575>:1:18' j = uint8(1); */
    j = 1U;

    /* '<S575>:1:19' cut_linear = single(0.0); */
    cut_linear = 0.0F;

    /* '<S575>:1:21' targetGains = coder.nullcopy(ones(1,MaskNumRampers,'single')); */
    /* '<S575>:1:22' balanceIndex = single(balanceIndex); */
    /*  random comment */
    /*  Find the left and the right gains */
    /*  Based on the balance table, the dB value of the index is calculated */
    /* '<S575>:1:28' while (j <= numel(balanceTableIdx)) */
    exitg1 = false;
    while ((!exitg1) && (j <= 30))
    {
        /* '<S575>:1:29' if (balanceIndex <= balanceTableIdx(j)) */
        boost_linear = Model_Target_PreAmp_p11_b0.Balance_CfgTableIdx[j - 1];
        if (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index <=
                boost_linear)
        {
            /* '<S575>:1:30' if (j <= 1) */
            if (j <= 1)
            {
                /*  first indexed value is linearly interpolated to zero */
                /* '<S575>:1:31' if (balanceTableIdx(j)) */
                if (Model_Target_PreAmp_p11_b0.Balance_CfgTableIdx[0] != 0.0F)
                {
                    /* '<S575>:1:32' percent = balanceIndex / balanceTableIdx(j); */
                    cut_linear = qhmath_div_f((real32_T)
                        Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index,
                        Model_Target_PreAmp_p11_b0.Balance_CfgTableIdx[0]);
                }
                else
                {
                    /* '<S575>:1:33' else */
                    /* '<S575>:1:34' percent = single(1); */
                    cut_linear = 1.0F;
                }

                /* '<S575>:1:36' cut_linear = percent * 10 ^ (balanceTableDb(j) / 20); */
                cut_linear *= qhmath_pow_f(10.0F, qhmath_div_f
                    (Model_Target_PreAmp_p11_b0.Balance_CfgTableDb[0], 20.0F));
            }
            else
            {
                /* '<S575>:1:37' else */
                /*  other values are interpolated in db space */
                /* '<S575>:1:38' lastIdx = single(balanceTableIdx(j-1)); */
                /* '<S575>:1:39' percent = (balanceIndex - lastIdx) / (balanceTableIdx(j) - lastIdx); */
                /* '<S575>:1:40' cut_linear = 10 ^ (((percent * (balanceTableDb(j) - balanceTableDb(j-1))) + balanceTableDb(j-1)) / 20); */
                cut_linear = Model_Target_PreAmp_p11_b0.Balance_CfgTableIdx[j -
                    2];
                left = Model_Target_PreAmp_p11_b0.Balance_CfgTableDb[j - 2];
                cut_linear = qhmath_pow_f(10.0F, qhmath_div_f
                    ((Model_Target_PreAmp_p11_b0.Balance_CfgTableDb[j - 1] -
                      left) * qhmath_div_f((real32_T)
                    Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index -
                    cut_linear, boost_linear - cut_linear) + left, 20.0F));
            }

            exitg1 = true;
        }
        else
        {
            /* '<S575>:1:43' else */
            /* '<S575>:1:44' j = j + 1; */
            j++;
        }
    }

    /*  Boost of > 0 dB is dependant on tuning. If the tune variable is SET (1), */
    /*  boost of 0 dB is applied (i.e. linear value of 1). If the tune variable */
    /*  is RESET (0), a boost of 3 dB is applied */
    /* '<S575>:1:51' if boostDisable == 0 */
    if (Model_Target_PreAmp_p11_b0.Balance_CfgBoostDisable == 0.0F)
    {
        /* '<S575>:1:52' boost_linear = sqrt(2.0 - cut_linear^2); */
        boost_linear = qhmath_sqrt_f(2.0F - cut_linear * cut_linear);
    }
    else
    {
        /* '<S575>:1:53' else */
        /* '<S575>:1:54' boost_linear = single(1); */
        boost_linear = 1.0F;
    }

    /*  % if silent extreme is enabled and we're extreme, make the cut complete */
    /*  % (Sleeping Beauty) */
    /* '<S575>:1:59' if (EnableSilentExtreme && abs(balanceIndex - indexOffset) >= (indexOffset-1)) */
    if ((Model_Target_PreAmp_p11_b0.Balance_CfgEnableSilentExtreme != 0.0F) &&
            (qhmath_abs_f((real32_T)
                          Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index
                          - Model_Target_PreAmp_p11_b0.Balance_CfgOffset) >=
             Model_Target_PreAmp_p11_b0.Balance_CfgOffset - 1.0F))
    {
        /* '<S575>:1:60' cut_linear = single(0); */
        cut_linear = 0.0F;
    }

    /*  Assign left and right Gain Values */
    /* '<S575>:1:64' if (balanceIndex - indexOffset) > 0 */
    if ((real32_T)Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index -
            Model_Target_PreAmp_p11_b0.Balance_CfgOffset > 0.0F)
    {
        /*  Left speakers attenuated */
        /* '<S575>:1:65' left = single(cut_linear); */
        left = cut_linear;

        /* '<S575>:1:66' right = single(boost_linear); */
        cut_linear = boost_linear;
    }
    else
    {
        /* '<S575>:1:67' else */
        /* '<S575>:1:68' left = single(boost_linear); */
        left = boost_linear;

        /* '<S575>:1:69' right = single(cut_linear); */
    }

    /*  Assign remaining gain values  */
    /* '<S575>:1:73' center = (left + right) * 0.5; */
    boost_linear = (left + cut_linear) * 0.5F;

    /* '<S575>:1:74' mono = center; */
    /*  Number to Content Key */
    /* '<S575>:1:77' targetGains(1) = left; */
    targetGains_h[0] = left;

    /* '<S575>:1:78' targetGains(2) = right; */
    targetGains_h[1] = cut_linear;

    /* '<S575>:1:79' targetGains(3) = center; */
    targetGains_h[2] = boost_linear;

    /* '<S575>:1:80' targetGains(4) = mono; */
    targetGains_h[3] = boost_linear;

    /*  (Sleeping Beauty) */
    /*  if silent extreme is enabled and we're extreme, cut center freqs */
    /* '<S575>:1:84' if (EnableSilentExtreme && abs(balanceIndex - indexOffset) >= (indexOffset-1)) */
    if ((Model_Target_PreAmp_p11_b0.Balance_CfgEnableSilentExtreme != 0.0F) &&
            (qhmath_abs_f((real32_T)
                          Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_gain_index
                          - Model_Target_PreAmp_p11_b0.Balance_CfgOffset) >=
             Model_Target_PreAmp_p11_b0.Balance_CfgOffset - 1.0F))
    {
        /* '<S575>:1:85' targetGains(3) = 0; */
        targetGains_h[2] = 0.0F;

        /* '<S575>:1:86' if (SleepingBeautyMutesBass) */
        if (Model_Target_PreAmp_p11_b0.Balance_CfgSleepingBeautyMutesBass !=
                0.0F)
        {
            /* '<S575>:1:87' targetGains(4) = 0; */
            targetGains_h[3] = 0.0F;
        }
    }

    /* End of MATLAB Function: '<S563>/calculate_balance_gain' */

    /* MATLAB Function: '<S563>/calculate_ramp_parameters' */
    /* MATLAB Function: '<S563>/calculate_ramp_parameters' */
    cut_linear = Model_Target_PreAmp_p11_b0.Balance_CfgRampTime;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/Balance/Balance/calculate_ramp_parameters': '<S576>:1' */
    /*  Ramp time and rate are provided to the block through RTC messages. However  */
    /*  in case neither of them are provided, the block will use the default ramp  */
    /*  time given in the tune variables. */
    /* '<S576>:1:9' ramptime = single(rampTimeTune); */
    /* '<S576>:1:10' rampRate = single(0); */
    left = 0.0F;

    /* '<S576>:1:12' if (rampRateRTC) */
    if (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_db_per_second != 0U)
    {
        /* '<S576>:1:13' rampRate = single(rampRateRTC); */
        /* '<S576>:1:14' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S576>:1:15' rampRate = min(rampRateBounds(2), rampRate); */
        left = fminf(50000.0F, fmaxf(5.0F, (real32_T)
                      Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_db_per_second));
    }

    /* '<S576>:1:17' if (rampTimeRTC) */
    if (Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_milliseconds != 0U)
    {
        /* '<S576>:1:18' ramptime = single(rampTimeRTC); */
        cut_linear = (real32_T)
            Model_TargetPreAmpBalance_CfgSetRtcOut.REQ_ramp_milliseconds;
    }

    /* Outputs for Function Call SubSystem: '<S563>/SetDsm' */
    /* '<S576>:1:20' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S576>:1:21' ramptime = min(rampTimeBounds(2), ramptime); */
    Model_Target_SetDsm_c(1U);

    /* End of Outputs for SubSystem: '<S563>/SetDsm' */

    /* MATLAB Function: '<S563>/control' */
    /* MATLAB Function: '<S563>/calculate_ramp_parameters' */
    /* MATLAB Function: '<S563>/control' incorporates:
     *  MATLAB Function: '<S563>/calculate_ramp_parameters'
     *  S-Function (AudioStats_MEX): '<S563>/Audio Stats1'
     */
    Model_Target_control(targetGains_h, left, fminf(3000.0F, fmaxf(1.0F,
                           cut_linear)), 44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S563>/SetDsm1' */
    Model_Target_SetDsm_c(0U);

    /* End of Outputs for SubSystem: '<S563>/SetDsm1' */
}

/* Output and update for function-call system: '<S604>/init' */
void InitTrigger_Model_141_246_141_172_156(void)
{
    /* MATLAB Function: '<S603>/PoolIirInit' */
    /* MATLAB Function: '<S603>/PoolIirInit' incorporates:
     *  Gain: '<S595>/Gain'
     *  S-Function (TOP_MEX): '<S600>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S609>:1' */
    /* '<S609>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S606>:1' */
    /*  Extract configuration information from inputs */
    /* '<S606>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S606>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S606>:1:24' VariantStr = char(VariantUint8); */
    /* '<S606>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S606>:1:28' else */
    /* '<S606>:1:29' switch(VariantStr) */
    /* '<S606>:1:30' case{"Hexagon"} */
    /* '<S606>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S606>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S606>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaBassMgrHpf37858states[0],
                 &MedusaBassMgrHpf48329PoolIirAudioIn[0], 32U, 2U,
                 &(Model_Target_PreAmp_p2_b0.MedusaBassManagerHpfPooliirNumStages
                   [0]), &MedusaBassMgrHpf48748PoolIirCoeffs[0],
                 &MedusaBassMgrHpf37858states[0], 41U, 1U, 24U);

    /* '<S606>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S612>/init' */
void InitTrigger_Model_141_246_141_172_192(void)
{
    /* MATLAB Function: '<S611>/SignalBreakFcn' */
    /* MATLAB Function: '<S611>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S600>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S614>:1' */
    /* '<S614>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S613>:1' */
    /* '<S613>:1:3' y = u; */
    memcpy(&MedusaBassMgrHpf48748PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p2_b0.MedusaBassManagerHpfpooliirCoeffs[0]),
           26U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S619>/init' */
void InitTrigger_Model_141_246_148_172_156(void)
{
    /* MATLAB Function: '<S618>/PoolIirInit' */
    /* MATLAB Function: '<S618>/PoolIirInit' incorporates:
     *  Gain: '<S596>/Gain'
     *  S-Function (TOP_MEX): '<S615>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S624>:1' */
    /* '<S624>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S621>:1' */
    /*  Extract configuration information from inputs */
    /* '<S621>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S621>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S621>:1:24' VariantStr = char(VariantUint8); */
    /* '<S621>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S621>:1:28' else */
    /* '<S621>:1:29' switch(VariantStr) */
    /* '<S621>:1:30' case{"Hexagon"} */
    /* '<S621>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S621>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S621>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaBassMgrLpf16381states[0],
                 &MedusaBassMgrLpf20780PoolIirAudioIn[0], 32U, 2U,
                 &(Model_Target_PreAmp_p2_b0.MedusaBassManagerLpfPooliirNumStages
                   [0]), &MedusaBassMgrLpf35518PoolIirCoeffs[0],
                 &MedusaBassMgrLpf16381states[0], 41U, 1U, 24U);

    /* '<S621>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S627>/init' */
void InitTrigger_Model_141_246_148_172_192(void)
{
    /* MATLAB Function: '<S626>/SignalBreakFcn' */
    /* MATLAB Function: '<S626>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S615>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S629>:1' */
    /* '<S629>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S628>:1' */
    /* '<S628>:1:3' y = u; */
    memcpy(&MedusaBassMgrLpf35518PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p2_b0.MedusaBassManagerLpfpooliirCoeffs[0]),
           26U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S641>/init' */
void InitTrigger_Model_141_248_38_65(void)
{
    /* MATLAB Function: '<S638>/FirEvenInit' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S644>:1' */
    /* '<S644>:1:3' init(); */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenInit': '<S639>:1' */
    /* '<S639>:1:4' [FilterLength, NumFilters] = size(FlippedCoefficients); */
    /* '<S639>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Simulation  */
    /* '<S639>:1:10' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S639>:1:12' else */
    /* '<S639>:1:13' y = fireven_hexagon_init(uint32(FrameSize), uint32(NumChannels), uint32(NumFilters), uint32(FilterLength), single(FlippedCoefficients), uint32(CodeWorkMemory), uint32(MaxNumOfThreds)); */
    fireven_init(&MedusaBandSplitImgRej21290CodeWorkMemory[0], 32U, 2U, 1U, 24U,
                 &MedusaBandSplitImgRej44511FirEvenCoeffs[0],
                 &MedusaBandSplitImgRej21290CodeWorkMemory[0], 1U);

    /*  NOTE: The CRL mechanism requires an output for the function call, */
    /*  and appears to be optimized out if that return value isn't used.  */
    /*  This is a dummy operation to make sure CRL ends up in generated code */
    /* '<S639>:1:17' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S642>/init' */
void InitTrigger_Model_141_248_38_84(void)
{
    /* MATLAB Function: '<S638>/SignalBreak' */
    /* MATLAB Function: '<S638>/SignalBreak' incorporates:
     *  Constant: '<S593>/Image Rejection Filter Coeffs'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S645>:1' */
    /* '<S645>:1:3' init(); */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/SignalBreak': '<S643>:1' */
    /* '<S643>:1:3' y = u; */
    memcpy(&MedusaBandSplitImgRej44511FirEvenCoeffs[0],
           &Model_Target_ConstP.ImageRejectionFilterCoeffs_Value[0], 24U *
           sizeof(real32_T));
}

/* System initialize for atomic system: '<S558>/Medusa5H1 Part 1' */
void Model_Target_Medusa5H1Part1_Init(void)
{
    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S612>/ITC1' */
    InitTrigger_Model_141_246_141_172_192();

    /* InitTriggerControl '<S604>/ITC1' */
    InitTrigger_Model_141_246_141_172_156();

    /* InitTriggerControl '<S627>/ITC1' */
    InitTrigger_Model_141_246_148_172_192();

    /* InitTriggerControl '<S619>/ITC1' */
    InitTrigger_Model_141_246_148_172_156();

    /* InitTriggerControl '<S642>/ITC1' */
    InitTrigger_Model_141_248_38_84();

    /* InitTriggerControl '<S641>/ITC1' */
    InitTrigger_Model_141_248_38_65();
}

/* Output and update for atomic system: '<S558>/Medusa5H1 Part 1' */
void Model_Target_Medusa5H1Part1(void)
{
    int32_T i;
    int32_T m;
    int32_T outidx;
    int_T frameIdx;
    real32_T rtb_BandSeparationDelay[64];
    real32_T rtb_ReconstructionFilter[64];
    real32_T y_a[64];

    /* Gain: '<S595>/Gain' */
    memcpy(&MedusaBassMgrHpf48329PoolIirAudioIn[0], &Model_Target_B.audioOut_n4
           [0], sizeof(real32_T) << 6U);

    /* End of Outputs for S-Function (InitTriggerControl): '<S612>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S604>/ITC1' */

    /* MATLAB Function: '<S603>/PoolIirProcess' incorporates:
     *  Gain: '<S595>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S607>:1' */
    /*  Extract configuration information from inputs */
    /* '<S607>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S607>:1:20' VariantStr = char(VariantUint8); */
    /* '<S607>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S607>:1:29' else */
    /* '<S607>:1:30' switch(VariantStr) */
    /* '<S607>:1:31' case{"Hexagon"} */
    /* '<S607>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&MedusaBassMgrHpf9323PoolIirAudioOut[0],
                    &MedusaBassMgrHpf48329PoolIirAudioIn[0],
                    &MedusaBassMgrHpf37858states[0]);

    /* Gain: '<S596>/Gain' incorporates:
     *  MATLAB Function: '<S591>/WeightedSum'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 1/Bass Manager Stereo/WeightedSum': '<S599>:1' */
    /* '<S599>:1:2' LeftIn = AudioIn(:, LeftIndices); */
    /* '<S599>:1:3' LeftOut = LeftIn*LeftMixWeights'; */
    /* '<S599>:1:5' RightIn = AudioIn(:, RightIndices); */
    /* '<S599>:1:6' RightOut = RightIn*RightMixWeights'; */
    /* '<S599>:1:8' WeightedOut = [LeftOut RightOut]; */
    /* '<S599>:1:9' Mono = mean(WeightedOut, 2); */
    for (i = 0; i < 32; i++)
    {
        MedusaBassMgrLpf20780PoolIirAudioIn[i] = Model_Target_B.audioOut_n4[i] *
            Model_Target_PreAmp_p2_b0.MedusaBassManagerLeftMixWeights;
        MedusaBassMgrLpf20780PoolIirAudioIn[i + 32] =
            Model_Target_B.audioOut_n4[i + 32] *
            Model_Target_PreAmp_p2_b0.MedusaBassManagerRightMixWeights;
    }

    /* End of Gain: '<S596>/Gain' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S627>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S619>/ITC1' */

    /* MATLAB Function: '<S618>/PoolIirProcess' incorporates:
     *  Gain: '<S596>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S622>:1' */
    /*  Extract configuration information from inputs */
    /* '<S622>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S622>:1:20' VariantStr = char(VariantUint8); */
    /* '<S622>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S622>:1:29' else */
    /* '<S622>:1:30' switch(VariantStr) */
    /* '<S622>:1:31' case{"Hexagon"} */
    /* '<S622>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&MedusaBassMgrLpf31798PoolIirAudioOut[0],
                    &MedusaBassMgrLpf20780PoolIirAudioIn[0],
                    &MedusaBassMgrLpf16381states[0]);

    /* Constant: '<S631>/Constant3' */
    Model_Target_B.Constant3 = 0;

    /* S-Function (sdspstatfcns): '<S585>/Mean' */
    outidx = 0;
    for (frameIdx = 0; frameIdx < 32; frameIdx++)
    {
        Model_Target_DW.Mean_AccVal[outidx] =
            Model_Target_B.audioOut_n4[frameIdx];
        Model_Target_DW.Mean_AccVal[outidx] +=
            Model_Target_B.audioOut_n4[frameIdx + 32];
        Model_Target_B.Mean[outidx] = qhmath_div_f
            (Model_Target_DW.Mean_AccVal[outidx], 2.0F);
        outidx++;
    }

    /* End of S-Function (sdspstatfcns): '<S585>/Mean' */

    /* Delay: '<S593>/Band Separation Delay' */
    for (i = 0; i < 2; i++)
    {
        memcpy(&rtb_BandSeparationDelay[i << 5],
               &Model_Target_DW.BandSeparationDelay_DSTATE_a[i * 136], sizeof
               (real32_T) << 5U);
    }

    /* End of Delay: '<S593>/Band Separation Delay' */

    /* Outputs for Atomic SubSystem: '<S593>/Ifir' */
    Model_Target_Ifir();

    /* End of Outputs for SubSystem: '<S593>/Ifir' */

    /* Gain: '<S635>/Gain' incorporates:
     *  Sum: '<S593>/Sum'
     */
    memcpy(&MedusaBandSplitImgRej18508FirEvenInput[0], &Model_Target_B.Sum_a[0],
           sizeof(real32_T) << 6U);

    /* MATLAB Function: '<S638>/FirEvenProcess' incorporates:
     *  Constant: '<S593>/Constant'
     *  Gain: '<S635>/Gain'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenProcess': '<S640>:1' */
    /* '<S640>:1:4' [FilterLength, ~] = size(FlippedCoeffs); */
    /* '<S640>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Initialize variables */
    /*  persistent States; */
    /*  if isempty(States) */
    /*      States = single(zeros(FilterLength + FrameSize*2 + 2, NumChannels)); */
    /*  end */
    /*  Set correct data types */
    /* '<S640>:1:17' FilterLength = uint32(FilterLength); */
    /* '<S640>:1:18' FrameSize = uint32(FrameSize); */
    /* '<S640>:1:19' ActiveCoeffSet = uint32(ActiveCoeffSet); */
    /* '<S640>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S640>:1:25' else */
    /*  FIR EVEN HEXAGON */
    /* '<S640>:1:27' if (FilterLength > FrameSize) */
    /* '<S640>:1:29' else */
    /* '<S640>:1:30' y = fireven_hexagon_process_lt(single(u), uint32(ActiveCoeffSet), single(States), uint32(CodeWorkMemory)); */
    fireven_process_lt(&y_a[0], &MedusaBandSplitImgRej18508FirEvenInput[0],
                       &Model_Target_ConstP.pooled101[0],
                       &MedusaBandSplitImgRej56502States[0],
                       &MedusaBandSplitImgRej21290CodeWorkMemory[0]);

    /* DownSample: '<S593>/Downsample' incorporates:
     *  Selector: '<S586>/Selector1'
     */
    for (i = 0; i < 16; i++)
    {
        Model_Target_B.LoRoLimpRimp[i] = y_a[i << 2];
    }

    /* End of DownSample: '<S593>/Downsample' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S642>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S641>/ITC1' */

    /* S-Function (sdspupfir2): '<S593>/Reconstruction Filter' */
    /* Loop over each input channel */
    for (outidx = 0; outidx < 2; outidx++)
    {
        int32_T dataInArrayIdx;
        int32_T dataOutArrayIdx;
        int32_T delayBuffIdx;
        delayBuffIdx = outidx * 34;
        dataInArrayIdx = outidx << 3;
        dataOutArrayIdx = dataInArrayIdx << 2;
        for (m = 0; m < 4; m++)
        {
            int32_T coefArrayIdx;
            int32_T oIdx;
            oIdx = dataOutArrayIdx + m;
            coefArrayIdx = m * 35;

            /* Consume delay line and beginning of input samples */
            for (i = 0; i < 8; i++)
            {
                real32_T accumulator;
                accumulator = 0.0F;
                for (frameIdx = 0; frameIdx < i + 1; frameIdx++)
                {
                    accumulator += Model_Target_B.LoRoLimpRimp[(dataInArrayIdx +
                        i) - frameIdx] *
                        Model_Target_ConstP.ReconstructionFilter_FILTER_COEFF[coefArrayIdx
                        + frameIdx];
                }

                for (frameIdx = 0; frameIdx < 34 - i; frameIdx++)
                {
                    accumulator +=
                        Model_Target_ConstP.ReconstructionFilter_FILTER_COEFF
                        [((coefArrayIdx + i) + frameIdx) + 1] *
                        Model_Target_DW.ReconstructionFilter_TapDelayBuff_d[delayBuffIdx
                        + frameIdx];
                }

                rtb_ReconstructionFilter[oIdx] = accumulator;
                oIdx += 4;
            }
        }

        /* Update delay line for next frame */
        for (i = delayBuffIdx + 25; i >= delayBuffIdx; i--)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff_d[i + 8] =
                Model_Target_DW.ReconstructionFilter_TapDelayBuff_d[i];
        }

        for (i = 0; i < 8; i++)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff_d[(delayBuffIdx -
                i) + 7] = Model_Target_B.LoRoLimpRimp[dataInArrayIdx + i];
        }
    }

    /* End of S-Function (sdspupfir2): '<S593>/Reconstruction Filter' */

    /* Sum: '<S593>/Sum' incorporates:
     *  Delay: '<S593>/Band Separation Delay'
     *  S-Function (sdspupfir2): '<S593>/Reconstruction Filter'
     */
    for (i = 0; i < 64; i++)
    {
        Model_Target_B.Sum_a[i] = rtb_BandSeparationDelay[i] -
            rtb_ReconstructionFilter[i];
    }

    /* End of Sum: '<S593>/Sum' */
    /* Update for M-S-Function: '<S632>/TSP' incorporates:
     *  Constant: '<S631>/Constant'
     */
    // TSP advanced triggered capture for PreAmpMedusaDummyState '<S632>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0202, 0, &Model_Target_ConstP.pooled34);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for Delay: '<S593>/Band Separation Delay' */
    for (i = 0; i < 2; i++)
    {
        for (frameIdx = 0; frameIdx < 104; frameIdx++)
        {
            outidx = i * 136 + frameIdx;
            Model_Target_DW.BandSeparationDelay_DSTATE_a[outidx] =
                Model_Target_DW.BandSeparationDelay_DSTATE_a[outidx + 32];
        }
    }

    for (i = 0; i < 2; i++)
    {
        memcpy(&Model_Target_DW.BandSeparationDelay_DSTATE_a[i * 136 + 104],
               &MedusaBassMgrHpf9323PoolIirAudioOut[i << 5], sizeof(real32_T) <<
               5U);
    }

    /* End of Update for Delay: '<S593>/Band Separation Delay' */
}

/* Output and update for atomic system: '<S586>/Alignment Delay' */
void Model_Target_AlignmentDelay(void)
{
    int32_T bufferIndex;
    int32_T channel;
    int32_T sample;
    int32_T writeIndex;

    /* MATLAB Function: '<S652>/MATLAB Function' incorporates:
     *  Sum: '<S593>/Sum'
     */
    /* [Param:maxDelay] */
    /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S653>:1' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /*  figure out the frame size and channel count */
    /* '<S653>:1:9' [frameSize, numChannels] = size(audioIn); */
    /* '<S653>:1:10' frameSize = int32(frameSize); */
    /* '<S653>:1:11' stateLen = int32(maxDelay)+frameSize; */
    /* '<S653>:1:12' totalLen = int32(stateLen * numChannels); */
    /* '<S653>:1:13' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S653>:1:17' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S653>:1:24' bufferIndex = delayIndex; */
    bufferIndex = Model_Target_AlignmentDelay_DW.delayIndex;

    /* '<S653>:1:26' for channel = 1:numChannels */
    for (channel = 0; channel < 2; channel++)
    {
        /*  Save writeIndex for next channel */
        /* '<S653>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(bufferIndex, 0, 8552);

        /* '<S653>:1:31' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S653>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            TrebleDelay[writeIndex] = Model_Target_B.Sum_a[(channel << 5) +
                sample];

            /*  increment write pointer */
            /* '<S653>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 8552);
        }

        /*  Advance buffer index for next channel */
        /* '<S653>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 4276, 8552);
    }

    /*  Reset */
    /* '<S653>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_AlignmentDelay_DW.delayIndex, 32, 8552);

    /* '<S653>:1:46' delayIndex = bufferIndex; */
    Model_Target_AlignmentDelay_DW.delayIndex = bufferIndex;

    /*  Read samples from delay line */
    /* '<S653>:1:49' for channel = 1:numChannels */
    for (channel = 0; channel < 2; channel++)
    {
        /*  Setup read pointer */
        /* '<S653>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        writeIndex = circindex(bufferIndex,
                               -(Model_Target_PreAmp_p3_b0.MedusaTrebleDelay +
                                32), 8552);

        /* '<S653>:1:54' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S653>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_AlignmentDelay_B.audioOut[sample + (channel << 5)] =
                TrebleDelay[writeIndex];

            /*  increment write pointer */
            /* '<S653>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 8552);
        }

        /*  Advance buffer index for next channel */
        /* '<S653>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 4276, 8552);
    }

    /* End of MATLAB Function: '<S652>/MATLAB Function' */
}

/*
 * Output and update for atomic system:
 *    '<S663>/Coeffs 1st Stage'
 *    '<S759>/Coeffs 1st Stage'
 */
void Model_Target_Coeffs1stStage(const creal32_T rtu_Lin[129], const creal32_T
    rtu_Rin[129], B_Coeffs1stStage_Model_Target_T *localB)
{
    int32_T k;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Coeffs 1st Stage': '<S664>:1' */
    /* '<S664>:1:4' epsf = single(eps); */
    /*  Magnitude calculations */
    /* '<S664>:1:7' absLi = abs(Lin) + epsf; */
    /* '<S664>:1:8' absRi = abs(Rin) + epsf; */
    /* '<S664>:1:9' minAbsLiRi = min(absLi, absRi); */
    /*  Excess coefficients (after removing far left/right) */
    /* '<S664>:1:12' Lxk = minAbsLiRi ./ absLi; */
    /* '<S664>:1:13' Rxk = minAbsLiRi ./ absRi; */
    /*  Far left/right coefficients */
    /* '<S664>:1:16' Lok = 1 - Lxk; */
    /*  1 - min(|L|,|R|)/|L| */
    /* '<S664>:1:17' Rok = 1 - Rxk; */
    /*  1 - min(|L|,|R|)/|R| */
    /*  Surround Phase Selectivity computation */
    /*  New SPS = |Lx - Rx|/(|Lx| + |Rx|) */
    /* '<S664>:1:21' Lx = Lin .* Lxk; */
    /* '<S664>:1:22' Rx = Rin .* Rxk; */
    /* '<S664>:1:23' SPS = abs(Lx - Rx) ./ (abs(Lx) + abs(Rx) + epsf); */
    for (k = 0; k < 129; k++)
    {
        real32_T absLi_tmp;
        real32_T absLi_tmp_0;
        real32_T absRi_tmp;
        real32_T absRi_tmp_0;
        real32_T b_z;
        real32_T minval;
        real32_T z;
        absLi_tmp = rtu_Lin[k].re;
        absLi_tmp_0 = rtu_Lin[k].im;
        localB->absLi[k] = qhmath_hypot_f(absLi_tmp, absLi_tmp_0);
        localB->absLi[k] += 2.22044605E-16F;
        absRi_tmp = rtu_Rin[k].re;
        absRi_tmp_0 = rtu_Rin[k].im;
        localB->absRi[k] = qhmath_hypot_f(absRi_tmp, absRi_tmp_0);
        localB->absRi[k] += 2.22044605E-16F;
        minval = fminf(localB->absLi[k], localB->absRi[k]);
        z = qhmath_div_f(minval, localB->absLi[k]);
        b_z = qhmath_div_f(minval, localB->absRi[k]);
        localB->Lok[k] = 1.0F - z;
        localB->Rok[k] = 1.0F - b_z;
        absLi_tmp *= z;
        absLi_tmp_0 *= z;
        absRi_tmp *= b_z;
        absRi_tmp_0 *= b_z;
        localB->SPS[k] = qhmath_hypot_f(absLi_tmp - absRi_tmp, absLi_tmp_0 -
            absRi_tmp_0);
        localB->SPS[k] = qhmath_div_f(localB->SPS[k], (qhmath_hypot_f(absLi_tmp,
            absLi_tmp_0) + qhmath_hypot_f(absRi_tmp, absRi_tmp_0)) +
            2.22044605E-16F);
        localB->Lxk[k] = z;
        localB->Rxk[k] = b_z;
        localB->minAbsLiRi[k] = minval;
    }
}

/*
 * Output and update for atomic system:
 *    '<S675>/MATLAB Function'
 *    '<S677>/MATLAB Function'
 *    '<S682>/MATLAB Function'
 *    '<S683>/MATLAB Function'
 *    '<S686>/MATLAB Function'
 *    '<S687>/MATLAB Function'
 *    '<S691>/MATLAB Function'
 *    '<S692>/MATLAB Function'
 *    '<S701>/MATLAB Function'
 *    '<S703>/MATLAB Function'
 *    ...
 */
void Model_Target_MATLABFunction(const real32_T rtu_x[129], real32_T rtu_pole,
    real32_T rtu_gain, B_MATLABFunction_Model_Target_T *localB,
    DW_MATLABFunction_Model_Target_T *localDW)
{
    int32_T i;

    /* MATLAB Function 'LeastSquareSmooth/MATLAB Function': '<S676>:1' */
    /* '<S676>:1:3' if isempty(xLast) */
    /* '<S676>:1:8' if isempty(yLast) */
    /* '<S676>:1:12' y = (gain * (x + xLast)) + (pole * yLast); */
    /*  Update states */
    /* '<S676>:1:15' xLast = x; */
    /* '<S676>:1:16' yLast = y; */
    for (i = 0; i < 129; i++)
    {
        localB->y[i] = (rtu_x[i] + localDW->xLast[i]) * rtu_gain + rtu_pole *
            localDW->yLast[i];
        localDW->xLast[i] = rtu_x[i];
        localDW->yLast[i] = localB->y[i];
    }
}

/*
 * Output and update for atomic system:
 *    '<S671>/Update Steering Coeffs'
 *    '<S766>/Update Steering Coeffs'
 */
void Model_Target_UpdateSteeringCoeffs(const real32_T rtu_Lstrks[129], const
    real32_T rtu_Rstrks[129], const real32_T rtu_Loks[129], const real32_T
    rtu_Roks[129], const real32_T rtu_Lxks[129], const real32_T rtu_Rxks[129],
    B_UpdateSteeringCoeffs_Model_Target_T *localB)
{
    int32_T i;

    /*  Update the steering coeffs using final stretch coeffs */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Updated Stretch Coeffs and Steering Coeffs/Update Steering Coeffs': '<S698>:1' */
    /*  Update Lok/Rok */
    /* '<S698>:1:5' Lok = Loks + ((2 - Rstrks) .* Lstrks) .* Lxks; */
    /* '<S698>:1:6' Rok = Roks + ((2 - Lstrks) .* Rstrks) .* Rxks; */
    /*  Update Lxk/Rxk */
    /* '<S698>:1:9' LxRxStretchFactor = (1 - Lstrks) .* (1 - Rstrks); */
    /* '<S698>:1:10' Lxk = LxRxStretchFactor .* Lxks; */
    /* '<S698>:1:11' Rxk = LxRxStretchFactor .* Rxks; */
    for (i = 0; i < 129; i++)
    {
        localB->Lok[i] = (2.0F - rtu_Rstrks[i]) * rtu_Lstrks[i] * rtu_Lxks[i] +
            rtu_Loks[i];
        localB->Rok[i] = (2.0F - rtu_Lstrks[i]) * rtu_Rstrks[i] * rtu_Rxks[i] +
            rtu_Roks[i];
        localB->Rxk[i] = (1.0F - rtu_Lstrks[i]) * (1.0F - rtu_Rstrks[i]);
        localB->Lxk[i] = localB->Rxk[i] * rtu_Lxks[i];
        localB->Rxk[i] *= rtu_Rxks[i];
    }
}

/* Output and update for function-call system: '<S738>/init' */
void InitTrigger_Model_141_2210_65(void)
{
    /* MATLAB Function: '<S737>/MATLAB Function1' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S741>:1' */
    /* '<S741>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function1': '<S740>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S740>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpDeciRateRifftRifftBufferTwiddle1[0],
              &MedusaFdpDeciRateRifftRifftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S746>/init' */
void InitTrigger_Model_141_2215_100(void)
{
    /* MATLAB Function: '<S745>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S749>:1' */
    /* '<S749>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function': '<S747>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S747>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpDeciRateRfftRfftBufferTwiddle1[0],
              &MedusaFdpDeciRateRfftRfftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S822>/init' */
void InitTrigger_Model_141_2876_65(void)
{
    /* MATLAB Function: '<S821>/MATLAB Function1' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S825>:1' */
    /* '<S825>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function1': '<S824>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S824>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpFullRateRifftRifftBufferTwiddle1[0],
              &MedusaFdpFullRateRifftRifftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S830>/init' */
void InitTrigger_Model_141_2881_100(void)
{
    /* MATLAB Function: '<S829>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S833>:1' */
    /* '<S833>:1:3' init(); */
    /*  Initializes the Twiddle factors used for RFFT computation */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function': '<S831>:1' */
    /*  Intialize Twiddle Factors */
    /* '<S831>:1:8' [Twiddle1, Twiddle2] = rfft_init(int32(fftSize)); */
    rfft_init(&MedusaFdpFullRateRfftRfftBufferTwiddle1[0],
              &MedusaFdpFullRateRfftRfftBufferTwiddle2[0], 256);
}

/* Output and update for function-call system: '<S845>/init' */
void InitTrigger_Model_141_2934_156(void)
{
    /* MATLAB Function: '<S844>/PoolIirInit' */
    /* MATLAB Function: '<S844>/PoolIirInit' incorporates:
     *  S-Function (TOP_MEX): '<S842>/TOP10'
     *  Selector: '<S586>/Selector'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S850>:1' */
    /* '<S850>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S847>:1' */
    /*  Extract configuration information from inputs */
    /* '<S847>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S847>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S847>:1:24' VariantStr = char(VariantUint8); */
    /* '<S847>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S847>:1:28' else */
    /* '<S847>:1:29' switch(VariantStr) */
    /* '<S847>:1:30' case{"Hexagon"} */
    /* '<S847>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S847>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S847>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaMonoDetectorHpf61492states[0],
                 &MedusaMonoDetectorHpf28317PoolIirAudioIn[0], 32U, 2U,
                 &(Model_Target_PreAmp_p3_b0.MedusaMonoDetectorHPFNumStages[0]),
                 &MedusaMonoDetectorHpf26135PoolIirCoeffs[0],
                 &MedusaMonoDetectorHpf61492states[0], 33U, 1U, 8U);

    /* '<S847>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S853>/init' */
void InitTrigger_Model_141_2934_192(void)
{
    int32_T i;

    /* MATLAB Function: '<S852>/SignalBreakFcn' */
    /* MATLAB Function: '<S852>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S842>/TOP11'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S855>:1' */
    /* '<S855>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S854>:1' */
    /* '<S854>:1:3' y = u; */
    for (i = 0; i < 10; i++)
    {
        MedusaMonoDetectorHpf26135PoolIirCoeffs[i] =
            Model_Target_PreAmp_p3_b0.MedusaMonoDetectorHPFCoeffs[i];
    }

    /* End of MATLAB Function: '<S852>/SignalBreakFcn' */
}

/* Output and update for function-call system: '<S874>/init' */
void InitTrigger_Model_141_3073_50_172_156(void)
{
    /* MATLAB Function: '<S873>/PoolIirInit' */
    /* MATLAB Function: '<S873>/PoolIirInit' incorporates:
     *  Gain: '<S869>/Gain'
     *  S-Function (TOP_MEX): '<S870>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S879>:1' */
    /* '<S879>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S876>:1' */
    /*  Extract configuration information from inputs */
    /* '<S876>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S876>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S876>:1:24' VariantStr = char(VariantUint8); */
    /* '<S876>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S876>:1:28' else */
    /* '<S876>:1:29' switch(VariantStr) */
    /* '<S876>:1:30' case{"Hexagon"} */
    /* '<S876>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S876>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S876>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&SPUMDecayIir53406states[0], &SPUMDecayIir2637PoolIirAudioIn[0],
                 32U, 2U,
                 &(Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstHPFPooliirNumStages
                   [0]), &SPUMDecayIir32251PoolIirCoeffs[0],
                 &SPUMDecayIir53406states[0], 113U, 1U, 48U);

    /* '<S876>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S882>/init' */
void InitTrigger_Model_141_3073_50_172_192(void)
{
    /* MATLAB Function: '<S881>/SignalBreakFcn' */
    /* MATLAB Function: '<S881>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S870>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S884>:1' */
    /* '<S884>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S883>:1' */
    /* '<S883>:1:3' y = u; */
    memcpy(&SPUMDecayIir32251PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstHPFpooliirCoeffs[0]),
           50U * sizeof(real32_T));
}

/* System initialize for atomic system: '<S558>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2_Init(void)
{
    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S738>/ITC1' */
    InitTrigger_Model_141_2210_65();

    /* InitTriggerControl '<S746>/ITC1' */
    InitTrigger_Model_141_2215_100();

    /* InitTriggerControl '<S822>/ITC1' */
    InitTrigger_Model_141_2876_65();

    /* InitTriggerControl '<S830>/ITC1' */
    InitTrigger_Model_141_2881_100();

    /* InitTriggerControl '<S882>/ITC1' */
    InitTrigger_Model_141_3073_50_172_192();

    /* InitTriggerControl '<S874>/ITC1' */
    InitTrigger_Model_141_3073_50_172_156();

    /* Start for SwitchCase: '<S649>/Switch Case' */
    Model_Target_DW.SwitchCase_ActiveSubsystem = -1;

    /* InitializeConditions for Buffer: '<S647>/BufferIn' */
    Model_Target_DW.BufferIn_inBufPtrIdx = 128;

    /* InitializeConditions for Buffer: '<S647>/BufferOut' */
    Model_Target_DW.BufferOut_inBufPtrIdx = 128;

    /* InitializeConditions for Buffer: '<S648>/BufferIn' */
    Model_Target_DW.BufferIn_inBufPtrIdx_e = 128;

    /* InitializeConditions for Buffer: '<S648>/BufferOut' */
    Model_Target_DW.BufferOut_inBufPtrIdx_a = 128;

    /* InitializeConditions for Buffer: '<S650>/Buffer' */
    Model_Target_DW.Buffer_inBufPtrIdx = 128;

    /* SystemInitialize for IfAction SubSystem: '<S649>/Mono Detector' */
    /* '<S718>:1:5' ; */
    /* '<S718>:1:5' counter = 0; */
    /* '<S718>:1:6' ; */
    /* '<S718>:1:6' state = 0; */
    /* '<S729>:1:5' ; */
    /* '<S729>:1:5' counter = 0; */
    /* '<S729>:1:6' ; */
    /* '<S729>:1:6' state = 0; */
    /* '<S739>:1:13' outputOverlap = single(zeros(numOverlap, numChannels)); */
    /* '<S743>:1:9' InputOverlap = single(zeros(Overlap, NumChannels)); */
    /* '<S802>:1:5' ; */
    /* '<S802>:1:5' counter = 0; */
    /* '<S802>:1:6' ; */
    /* '<S802>:1:6' state = 0; */
    /* '<S813>:1:5' ; */
    /* '<S813>:1:5' counter = 0; */
    /* '<S813>:1:6' ; */
    /* '<S813>:1:6' state = 0; */
    /* '<S823>:1:13' outputOverlap = single(zeros(numOverlap, numChannels)); */
    /* '<S827>:1:9' InputOverlap = single(zeros(Overlap, NumChannels)); */

    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S853>/ITC1' */
    InitTrigger_Model_141_2934_192();

    /* InitTriggerControl '<S845>/ITC1' */
    InitTrigger_Model_141_2934_156();

    /* SystemInitialize for MATLAB Function: '<S835>/Mono Detector' */
    /* '<S839>:1:13' ; */
    /* '<S839>:1:13' zeroLevelCount = 0; */
    /* '<S839>:1:14' ; */
    /* '<S839>:1:14' Llevel = single(0); */
    /* '<S839>:1:15' ; */
    /* '<S839>:1:15' Rlevel = single(0); */
    /* '<S839>:1:16' ; */
    /* '<S839>:1:16' smoothedSumOfEnergies = single(0); */
    /* '<S839>:1:17' ; */
    /* '<S839>:1:17' smoothedEnergyOfSum = single(0); */
    /* '<S839>:1:18' ; */
    /* '<S839>:1:18' levelCenter = single(0); */
    /* '<S839>:1:19' ; */
    /* '<S839>:1:19' lastSpumOn = true; */
    Model_Target_DW.lastSpumOn = true;

    /* End of SystemInitialize for SubSystem: '<S649>/Mono Detector' */

    /* SystemInitialize for MATLAB Function: '<S856>/Estimate Decay' */
    /* '<S859>:1:14' ; */
    /* '<S859>:1:14' onsetOn = 0; */
    /* '<S859>:1:15' ; */
    /* '<S859>:1:15' onsetOff = 0; */
    /* '<S859>:1:16' ; */
    /* '<S859>:1:16' onsetCounter = 0; */
    /* '<S859>:1:17' ; */
    /* '<S859>:1:17' noOnsetOnOffCounter = 0; */
    /* '<S859>:1:18' ; */
    /* '<S859>:1:18' prevDecay = decayConst.decayDefaultSlope; */
    Model_Target_DW.prevDecay = -0.173333332F;

    /* '<S859>:1:19' ; */
    /* '<S859>:1:19' smoothedDecay = decayConst.decayDefaultSlope; */
    Model_Target_DW.smoothedDecay = -0.173333332F;

    /* '<S859>:1:21' thresholdForFrameEnergy = decayConst.minGateFrameEnergydB; */
    Model_Target_DW.thresholdForFrameEnergy = -25.0F;

    /* '<S860>:1:8' ; */
    /* '<S860>:1:8' prevDelta = single(0); */
    /* '<S860>:1:9' ; */
    /* '<S860>:1:9' prevStepSize = single(0); */
}

/* Output and update for atomic system: '<S558>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2TID2(void)
{
    int32_T chanIdx;
    int32_T currentOffset;
    int32_T i;
    int32_T offsetFromMemBase;
    int32_T uIdx;
    int8_T rtAction;
    int8_T rtPrevAction;
    static const int8_T tmp[4] =
    {
        0, 1, 2, 4
    };

    /* Outputs for Atomic SubSystem: '<S586>/Alignment Delay' */
    Model_Target_AlignmentDelay();

    /* End of Outputs for SubSystem: '<S586>/Alignment Delay' */

    /* Buffer: '<S647>/BufferIn' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 2; chanIdx++)
    {
        offsetFromMemBase = (chanIdx << 8) +
            Model_Target_DW.BufferIn_inBufPtrIdx;
        for (i = 0; i < 8; i++)
        {
            Model_Target_DW.BufferIn_CircBuf[offsetFromMemBase + i] =
                Model_Target_B.crossfadedOutput[uIdx + i];
        }

        uIdx += 8;
    }

    Model_Target_DW.BufferIn_inBufPtrIdx += 8;
    if (Model_Target_DW.BufferIn_inBufPtrIdx >= 256)
    {
        Model_Target_DW.BufferIn_inBufPtrIdx -= 256;
    }

    /* End of Buffer: '<S647>/BufferIn' */

    /* Buffer: '<S647>/BufferOut' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 8; chanIdx++)
    {
        currentOffset = (chanIdx << 8) + Model_Target_DW.BufferOut_outBufPtrIdx;
        for (i = 0; i < 8; i++)
        {
            Model_Target_B.BufferOut[uIdx + i] =
                Model_Target_DW.BufferOut_CircBuf[currentOffset + i];
        }

        uIdx += 8;
        currentOffset = Model_Target_DW.BufferOut_outBufPtrIdx + 8;
    }

    if (currentOffset == 256)
    {
        currentOffset = 0;
    }

    Model_Target_DW.BufferOut_outBufPtrIdx = currentOffset;

    /* End of Buffer: '<S647>/BufferOut' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S738>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S746>/ITC1' */
    /* Buffer: '<S648>/BufferIn' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 2; chanIdx++)
    {
        offsetFromMemBase = (chanIdx << 8) +
            Model_Target_DW.BufferIn_inBufPtrIdx_e;
        memcpy(&Model_Target_DW.BufferIn_CircBuf_l[offsetFromMemBase],
               &Model_Target_AlignmentDelay_B.audioOut[uIdx], sizeof(real32_T) <<
               5U);
        uIdx += 32;
    }

    Model_Target_DW.BufferIn_inBufPtrIdx_e += 32;
    if (Model_Target_DW.BufferIn_inBufPtrIdx_e >= 256)
    {
        Model_Target_DW.BufferIn_inBufPtrIdx_e -= 256;
    }

    /* End of Buffer: '<S648>/BufferIn' */

    /* Buffer: '<S648>/BufferOut' */
    uIdx = 0;
    offsetFromMemBase = Model_Target_DW.BufferOut_outBufPtrIdx_e + 32;
    for (chanIdx = 0; chanIdx < 6; chanIdx++)
    {
        currentOffset = (chanIdx << 8) +
            Model_Target_DW.BufferOut_outBufPtrIdx_e;
        memcpy(&Model_Target_B.BufferOut_c[uIdx],
               &Model_Target_DW.BufferOut_CircBuf_j[currentOffset], sizeof
               (real32_T) << 5U);
        uIdx += 32;
    }

    if (Model_Target_DW.BufferOut_outBufPtrIdx_e + 32 == 256)
    {
        offsetFromMemBase = 0;
    }

    Model_Target_DW.BufferOut_outBufPtrIdx_e = offsetFromMemBase;

    /* End of Buffer: '<S648>/BufferOut' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S822>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S830>/ITC1' */
    /* Selector: '<S586>/Selector' */
    memcpy(&MedusaMonoDetectorHpf28317PoolIirAudioIn[0],
           &Model_Target_B.audioOut_n4[0], sizeof(real32_T) << 6U);

    /* SwitchCase: '<S649>/Switch Case' */
    rtPrevAction = Model_Target_DW.SwitchCase_ActiveSubsystem;
    if (Model_Target_PreAmp_p3_b0.MedusaMonoDetectorEnable == 1)
    {
        rtAction = 0;
    }
    else
    {
        rtAction = 1;
    }

    Model_Target_DW.SwitchCase_ActiveSubsystem = rtAction;
    if ((rtPrevAction != rtAction) && (rtPrevAction == 0))
    {
    }

    if (rtAction == 0)
    {
        real32_T absLeft;
        real32_T absRight;
        real32_T curL;
        real32_T curR;
        real32_T sumOfEnergies;
        if (rtPrevAction != 0)
        {
        }

        /* MATLAB Function: '<S844>/PoolIirProcess' incorporates:
         *  Selector: '<S586>/Selector'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S848>:1' */
        /*  Extract configuration information from inputs */
        /* '<S848>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S848>:1:20' VariantStr = char(VariantUint8); */
        /* '<S848>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S848>:1:29' else */
        /* '<S848>:1:30' switch(VariantStr) */
        /* '<S848>:1:31' case{"Hexagon"} */
        /* '<S848>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        pooliir_process(&MedusaMonoDetectorHpf58663PoolIirAudioOut[0],
                        &MedusaMonoDetectorHpf28317PoolIirAudioIn[0],
                        &MedusaMonoDetectorHpf61492states[0]);

        /* MATLAB Function: '<S835>/Mono Detector' incorporates:
         *  BusCreator generated from: '<S835>/Mono Detector'
         *  DownSample: '<S835>/Downsample'
         *  DownSample: '<S835>/Downsample1'
         *  Selector: '<S586>/Selector'
         */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Mono Detector/Mono Detector/Mono Detector': '<S839>:1' */
        /*  basically isStereo, since we turn on SPUM if input is stereo */
        /* '<S839>:1:13' if isempty(zeroLevelCount) */
        /* '<S839>:1:14' if isempty(Llevel) */
        /* '<S839>:1:15' if isempty(Rlevel) */
        /* '<S839>:1:16' if isempty(smoothedSumOfEnergies) */
        /* '<S839>:1:17' if isempty(smoothedEnergyOfSum) */
        /* '<S839>:1:18' if isempty(levelCenter) */
        /* '<S839>:1:19' if isempty(lastSpumOn) */
        /* '<S839>:1:21' absLeft = abs(L); */
        absLeft = qhmath_abs_f(MedusaMonoDetectorHpf28317PoolIirAudioIn[0]);

        /* '<S839>:1:22' absRight = abs(R); */
        absRight = qhmath_abs_f(MedusaMonoDetectorHpf28317PoolIirAudioIn[32]);

        /*  Recursive averaging */
        /* '<S839>:1:25' a1 = monoDetectorTunable.levelPole; */
        /* '<S839>:1:26' b0 = monoDetectorTunable.levelGain; */
        /* '<S839>:1:27' Llevel = Llevel * a1 +  absLeft * b0; */
        Model_Target_DW.Llevel = Model_Target_DW.Llevel *
            Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLevelPole + absLeft *
            Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLevelGain;

        /* '<S839>:1:28' Rlevel = Rlevel * a1 +  absRight * b0; */
        Model_Target_DW.Rlevel = Model_Target_DW.Rlevel *
            Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLevelPole + absRight *
            Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLevelGain;

        /*  Compute saturated signals from predetermined miss-match tolerance */
        /* '<S839>:1:31' LlevelSat = min(Llevel, Rlevel*monoDetectorTunable.leftRightMatchTolerance); */
        /* '<S839>:1:32' RlevelSat = min(Rlevel, Llevel*monoDetectorTunable.leftRightMatchTolerance); */
        /*  Compute mono content variables */
        /* '<S839>:1:35' curL = hpfL * RlevelSat; */
        curL = fminf(Model_Target_DW.Rlevel, Model_Target_DW.Llevel *
                     Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLRMatchTolerance)
            * MedusaMonoDetectorHpf58663PoolIirAudioOut[0];

        /* '<S839>:1:36' curR = hpfR * LlevelSat; */
        curR = fminf(Model_Target_DW.Llevel, Model_Target_DW.Rlevel *
                     Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLRMatchTolerance)
            * MedusaMonoDetectorHpf58663PoolIirAudioOut[32];

        /* '<S839>:1:37' sumOfEnergies = curL^2 + curR^2; */
        sumOfEnergies = curL * curL + curR * curR;

        /*  tgtX2 */
        /* '<S839>:1:38' energyOfSum = 0.5*(curL + curR)^2; */
        curL += curR;
        curL = curL * curL * 0.5F;

        /*  tgtX2Center */
        /*  Check if signal has been low for awhile */
        /* '<S839>:1:41' if (absLeft + absRight) < monoDetectorTunable.thresholdZeroLevel */
        if (absLeft + absRight <
                Model_Target_PreAmp_p3_b0.MedusaMonoDetectorThresholdZeroLevel)
        {
            /* '<S839>:1:42' zeroLevelCount = zeroLevelCount + 1; */
            Model_Target_DW.zeroLevelCount++;
        }
        else
        {
            /* '<S839>:1:43' else */
            /* '<S839>:1:44' zeroLevelCount = 0; */
            Model_Target_DW.zeroLevelCount = 0.0;
        }

        /*  Pole selection (determine LPF coefficient) for least square smoothing */
        /*  If the signal level is very low (or zero) for awhile, rest params and  */
        /*  select correct poles so that we don't miss fast changes in input */
        /* '<S839>:1:50' if zeroLevelCount > maxZeroLevelCount */
        if (Model_Target_DW.zeroLevelCount > Model_Target_maxZeroLevelCount)
        {
            /* '<S839>:1:51' sumOfEnergies = single(0); */
            sumOfEnergies = 0.0F;

            /* '<S839>:1:52' energyOfSum = single(0); */
            curL = 0.0F;

            /* '<S839>:1:53' smoothedSumOfEnergies = single(0); */
            Model_Target_DW.smoothedSumOfEnergies = 0.0F;

            /* '<S839>:1:54' smoothedEnergyOfSum = single(0); */
            Model_Target_DW.smoothedEnergyOfSum = 0.0F;

            /* '<S839>:1:55' lsPole = monoDetectorTunable.lsSmoothResetPole; */
            absLeft =
                Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLSSmoothResetPole;

            /* '<S839>:1:56' lsGain = monoDetectorTunable.lsSmoothResetGain; */
            absRight =
                Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLSSmoothResetGain;

            /* '<S839>:1:57' zeroLevelCount = maxZeroLevelCount + 1; */
            Model_Target_DW.zeroLevelCount = 694.0;
        }
        else
        {
            /* '<S839>:1:58' else */
            /* '<S839>:1:59' lsPole = monoDetectorTunable.lsSmoothPole; */
            absLeft = Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLSSmoothPole;

            /* '<S839>:1:60' lsGain = monoDetectorTunable.lsSmoothGain; */
            absRight = Model_Target_PreAmp_p3_b0.MedusaMonoDetectorLSSmoothGain;
        }

        /*  Least square smoothing  */
        /* '<S839>:1:64' smoothedSumOfEnergies = lsPole * smoothedSumOfEnergies + lsGain * sumOfEnergies; */
        Model_Target_DW.smoothedSumOfEnergies = absLeft *
            Model_Target_DW.smoothedSumOfEnergies + absRight * sumOfEnergies;

        /* '<S839>:1:65' smoothedEnergyOfSum = lsPole * smoothedEnergyOfSum + lsGain * energyOfSum; */
        Model_Target_DW.smoothedEnergyOfSum = absLeft *
            Model_Target_DW.smoothedEnergyOfSum + absRight * curL;

        /*  Compute measure of center (or mono) level */
        /* '<S839>:1:68' levelCenter = smoothedEnergyOfSum/(smoothedSumOfEnergies + single(eps)); */
        sumOfEnergies = qhmath_div_f(Model_Target_DW.smoothedEnergyOfSum,
            Model_Target_DW.smoothedSumOfEnergies + 2.22044605E-16F);

        /*  Determine if input is stereo and turn SPUM on/off accordingly */
        /*  stereo case 1: was stereo last time (SPUM on) and this mono level < mono threhold */
        /*  stereo case 2: was mono last time (SPUM off) and this mono level < stereo threshold */
        /* '<S839>:1:73' lastSpumOn = (lastSpumOn && (levelCenter < monoDetectorTunable.thresholdMono)) ... */
        /* '<S839>:1:74'     || (~lastSpumOn && (levelCenter <= monoDetectorTunable.thresholdStereo)); */
        Model_Target_DW.lastSpumOn = ((Model_Target_DW.lastSpumOn &&
            (sumOfEnergies <
             Model_Target_PreAmp_p3_b0.MedusaMonoDetectorThresholdMono)) ||
            ((!Model_Target_DW.lastSpumOn) && (sumOfEnergies <=
            Model_Target_PreAmp_p3_b0.MedusaMonoDetectorThresholdStereo)));

        /* '<S839>:1:76' spumOn = uint32(lastSpumOn); */
        /*  equivalent to isStereo */
        /* '<S839>:1:78' center = levelCenter; */
        Model_Target_B.center = sumOfEnergies;

        /* Merge: '<S649>/Merge' incorporates:
         *  MATLAB Function: '<S835>/Mono Detector'
         *  SignalConversion generated from: '<S835>/IsStereo'
         */
        Model_Target_B.Merge = Model_Target_DW.lastSpumOn;

        /* End of Outputs for S-Function (InitTriggerControl): '<S853>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S845>/ITC1' */

        /* Update for M-S-Function: '<S841>/TSP' */
        // TSP advanced triggered capture for PreAmpMedusaMonoDetectorLevelCenter '<S841>/TSP':
#if TSP_ENABLE_ADVANCED

        TSP_StepCapture(TspDispatchTable0203, 2, &Model_Target_B.center);

#endif                                 //TSP_ENABLE_ADVANCED

        /* End of Outputs for SubSystem: '<S649>/Mono Detector' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S649>/Bypass' incorporates:
         *  ActionPort: '<S834>/Action Port'
         */
        /* Merge: '<S649>/Merge' incorporates:
         *  Constant: '<S834>/Constant'
         *  SignalConversion generated from: '<S834>/IsStereo'
         */
        Model_Target_B.Merge = 1U;

        /* End of Outputs for SubSystem: '<S649>/Bypass' */
    }

    /* End of SwitchCase: '<S649>/Switch Case' */
    /* Gain: '<S869>/Gain' incorporates:
     *  Sum: '<S593>/Sum'
     */
    memcpy(&SPUMDecayIir2637PoolIirAudioIn[0], &Model_Target_B.Sum_a[0], sizeof
           (real32_T) << 6U);

    /* MATLAB Function: '<S873>/PoolIirProcess' incorporates:
     *  Gain: '<S869>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S877>:1' */
    /*  Extract configuration information from inputs */
    /* '<S877>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S877>:1:20' VariantStr = char(VariantUint8); */
    /* '<S877>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S877>:1:29' else */
    /* '<S877>:1:30' switch(VariantStr) */
    /* '<S877>:1:31' case{"Hexagon"} */
    /* '<S877>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&SPUMDecayIir22216PoolIirAudioOut[0],
                    &SPUMDecayIir2637PoolIirAudioIn[0],
                    &SPUMDecayIir53406states[0]);

    /* Buffer: '<S650>/Buffer' */
    uIdx = 0;
    for (chanIdx = 0; chanIdx < 2; chanIdx++)
    {
        offsetFromMemBase = (chanIdx << 8) + Model_Target_DW.Buffer_inBufPtrIdx;
        memcpy(&Model_Target_DW.Buffer_CircBuf[offsetFromMemBase],
               &SPUMDecayIir22216PoolIirAudioOut[uIdx], sizeof(real32_T) << 5U);
        uIdx += 32;
    }

    Model_Target_DW.Buffer_inBufPtrIdx += 32;
    if (Model_Target_DW.Buffer_inBufPtrIdx >= 256)
    {
        Model_Target_DW.Buffer_inBufPtrIdx -= 256;
    }

    /* End of Buffer: '<S650>/Buffer' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S882>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S874>/ITC1' */
    /* Selector: '<S586>/Selector1' incorporates:
     *  Buffer: '<S648>/BufferOut'
     */
    for (uIdx = 0; uIdx < 4; uIdx++)
    {
        for (chanIdx = 0; chanIdx < 32; chanIdx++)
        {
            Model_Target_B.LoRoLimpRimp[chanIdx + (uIdx << 5)] =
                Model_Target_B.BufferOut_c[(tmp[uIdx] << 5) + chanIdx];
        }
    }

    /* End of Selector: '<S586>/Selector1' */
    /* Update for M-S-Function: '<S836>/TSP' */
    // TSP advanced triggered capture for PreAmpMedusaMonoDetectorIsStereo '<S836>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0203, 1, &Model_Target_B.Merge);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S837>/TSP' */
    // TSP advanced triggered capture for PreAmpMedusaMonoDetectorIsActive '<S837>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0203, 0,
                    &(Model_Target_PreAmp_p3_b0.MedusaMonoDetectorEnable));

#endif                                 //TSP_ENABLE_ADVANCED

}

/* Output and update for atomic system: '<S558>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2TID4(void)
{
    int32_T currentOffset;
    int32_T delayLen;
    int32_T i;
    int32_T memIdx;
    int32_T row;
    int32_T rtb_isImpulsive_g;
    real32_T rtb_Add1_k3[129];
    real32_T rtb_Add1_ma[129];
    real32_T rtb_Rxks[129];
    real32_T y[5];
    real32_T maxXp;
    real32_T minXp;
    real32_T minXp_tmp;
    real32_T rtb_Delay_og;
    real32_T rtb_R_im_tmp;
    real32_T rtb_R_re;
    real32_T rtb_R_re_tmp;
    real32_T rtb_Sumhighfrequencyenergy;
    real32_T slewedStepSize;
    real32_T updatedLokRokScaleFactor;
    real32_T updatedLokRokScaleFactor_tmp;
    static const real32_T b[128] =
    {
        0.0F, 0.0122715384F, 0.024541229F, 0.0368072242F, 0.0490676761F,
        0.061320737F, 0.0735645667F, 0.0857973099F, 0.0980171412F, 0.110222206F,
        0.122410677F, 0.134580702F, 0.146730468F, 0.15885815F, 0.170961887F,
        0.183039889F, 0.195090324F, 0.207111374F, 0.219101235F, 0.231058106F,
        0.242980182F, 0.254865646F, 0.266712755F, 0.27851969F, 0.290284663F,
        0.302005947F, 0.313681751F, 0.32531029F, 0.336889863F, 0.348418683F,
        0.359895051F, 0.371317208F, 0.382683426F, 0.393992037F, 0.405241311F,
        0.416429549F, 0.427555084F, 0.438616246F, 0.449611336F, 0.460538715F,
        0.471396744F, 0.482183784F, 0.492898196F, 0.50353837F, 0.514102757F,
        0.524589658F, 0.534997642F, 0.545325F, 0.555570245F, 0.565731823F,
        0.575808167F, 0.585797846F, 0.59569931F, 0.605511069F, 0.615231574F,
        0.624859512F, 0.634393275F, 0.643831551F, 0.653172851F, 0.662415802F,
        0.671559F, 0.680601F, 0.689540565F, 0.698376238F, 0.707106769F,
        0.715730846F, 0.724247098F, 0.732654274F, 0.740951121F, 0.749136388F,
        0.757208824F, 0.765167236F, 0.773010433F, 0.780737221F, 0.78834641F,
        0.795836926F, 0.803207517F, 0.81045717F, 0.817584813F, 0.824589312F,
        0.831469595F, 0.838224709F, 0.84485358F, 0.851355195F, 0.857728601F,
        0.863972843F, 0.870086968F, 0.876070082F, 0.881921291F, 0.887639642F,
        0.893224299F, 0.898674488F, 0.903989315F, 0.909168F, 0.914209783F,
        0.919113874F, 0.923879504F, 0.928506076F, 0.932992816F, 0.937339F,
        0.941544056F, 0.945607305F, 0.949528158F, 0.953306F, 0.956940353F,
        0.960430503F, 0.963776052F, 0.966976464F, 0.970031261F, 0.972939968F,
        0.975702107F, 0.97831738F, 0.980785251F, 0.983105481F, 0.985277653F,
        0.987301409F, 0.989176512F, 0.990902662F, 0.992479563F, 0.993907F,
        0.99518472F, 0.996312618F, 0.997290432F, 0.998118103F, 0.99879545F,
        0.999322355F, 0.999698818F, 0.999924719F
    };

    static const real32_T c[128] =
    {
        1.0F, 0.999924719F, 0.999698818F, 0.999322355F, 0.99879545F,
        0.998118103F, 0.997290432F, 0.996312618F, 0.99518472F, 0.993907F,
        0.992479563F, 0.990902662F, 0.989176512F, 0.987301409F, 0.985277653F,
        0.983105481F, 0.980785251F, 0.97831738F, 0.975702107F, 0.972939968F,
        0.970031261F, 0.966976464F, 0.963776052F, 0.960430503F, 0.956940353F,
        0.953306F, 0.949528158F, 0.945607305F, 0.941544056F, 0.937339F,
        0.932992816F, 0.928506076F, 0.923879504F, 0.919113874F, 0.914209783F,
        0.909168F, 0.903989315F, 0.898674488F, 0.893224299F, 0.887639642F,
        0.881921291F, 0.876070082F, 0.870086968F, 0.863972843F, 0.857728601F,
        0.851355195F, 0.84485358F, 0.838224709F, 0.831469595F, 0.824589312F,
        0.817584813F, 0.81045717F, 0.803207517F, 0.795836926F, 0.78834641F,
        0.780737221F, 0.773010433F, 0.765167236F, 0.757208824F, 0.749136388F,
        0.740951121F, 0.732654274F, 0.724247098F, 0.715730846F, 0.707106769F,
        0.698376238F, 0.689540565F, 0.680601F, 0.671559F, 0.662415802F,
        0.653172851F, 0.643831551F, 0.634393275F, 0.624859512F, 0.615231574F,
        0.605511069F, 0.59569931F, 0.585797846F, 0.575808167F, 0.565731823F,
        0.555570245F, 0.545325F, 0.534997642F, 0.524589658F, 0.514102757F,
        0.50353837F, 0.492898196F, 0.482183784F, 0.471396744F, 0.460538715F,
        0.449611336F, 0.438616246F, 0.427555084F, 0.416429549F, 0.405241311F,
        0.393992037F, 0.382683426F, 0.371317208F, 0.359895051F, 0.348418683F,
        0.336889863F, 0.32531029F, 0.313681751F, 0.302005947F, 0.290284663F,
        0.27851969F, 0.266712755F, 0.254865646F, 0.242980182F, 0.231058106F,
        0.219101235F, 0.207111374F, 0.195090324F, 0.183039889F, 0.170961887F,
        0.15885815F, 0.146730468F, 0.134580702F, 0.122410677F, 0.110222206F,
        0.0980171412F, 0.0857973099F, 0.0735645667F, 0.061320737F, 0.0490676761F,
        0.0368072242F, 0.024541229F, 0.0122715384F
    };

    creal32_T *rtb_y_i_0;

    /* Buffer: '<S648>/BufferIn' */
    delayLen = 0;
    for (row = 0; row < 2; row++)
    {
        memIdx = (row << 8) + Model_Target_DW.BufferIn_outBufPtrIdx_c;
        memcpy(&Model_Target_B.BufferIn[delayLen],
               &Model_Target_DW.BufferIn_CircBuf_l[memIdx], sizeof(real32_T) <<
               7U);
        delayLen += 128;
        i = Model_Target_DW.BufferIn_outBufPtrIdx_c + 128;
    }

    if (i == 256)
    {
        i = 0;
    }

    Model_Target_DW.BufferIn_outBufPtrIdx_c = i;

    /* End of Buffer: '<S648>/BufferIn' */

    /* MATLAB Function: '<S753>/Windowing' incorporates:
     *  Buffer: '<S648>/BufferIn'
     */
    /*  Get sizes */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/ShortTimeFourierTransform/Windowing': '<S827>:1' */
    /* '<S827>:1:4' [~, NumChannels] = size(AudioIn); */
    /* '<S827>:1:5' HopSize = FftSize - Overlap; */
    /* '<S827>:1:8' if isempty(InputOverlap) */
    /* '<S827>:1:12' AudioOut = [InputOverlap.*Window(1:Overlap); AudioIn.*Window((HopSize + 1):end)]; */
    for (delayLen = 0; delayLen < 2; delayLen++)
    {
        for (i = 0; i < 128; i++)
        {
            rtb_isImpulsive_g = (delayLen << 7) + i;
            row = (delayLen << 8) + i;
            MedusaFdpFullRateRfftRfftInput[row] =
                Model_Target_DW.InputOverlap[rtb_isImpulsive_g] * b[i];
            MedusaFdpFullRateRfftRfftInput[row + 128] =
                Model_Target_B.BufferIn[rtb_isImpulsive_g] * c[i];
        }
    }

    /*  Update overlapping samples */
    /* '<S827>:1:15' InputOverlap = AudioIn; */
    memcpy(&Model_Target_DW.InputOverlap[0], &Model_Target_B.BufferIn[0], sizeof
           (real32_T) << 8U);

    /* End of MATLAB Function: '<S753>/Windowing' */

    /* MATLAB Function: '<S829>/MATLAB Function1' */
    /*  Computes the Real FFT of a Multi-Channel Signal.  */
    /*  During Code Generation, hexagon rfft crl function is used. */
    /*  Inputs: */
    /*      u - purely real signal.  */
    /*          size = [fftSize, numChannels] */
    /*      fftSize - size of each input channel. Also the size of FFT */
    /*  Outputs: */
    /*      y - fftSize/2 + 1 unique FFT coefficients of each channel of u. */
    /*          size = [fftSize/2 + 1, numChannels] */
    /*  ------------------------------------------------------------------------- */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function1': '<S832>:1' */
    /* '<S832>:1:17' numChannels = size(u, 2); */
    /* '<S832>:1:18' spectrumSize = (fftSize/2) + 1; */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S832>:1:21' y = coder.nullcopy(complex(single(zeros(spectrumSize, numChannels)))); */
    /*  Simulation */
    /* '<S832>:1:24' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S832>:1:27' else */
    /* '<S832>:1:28' y = rfft_process(single(u), Twiddle1, Twiddle2, RfftOutputTmp, int32(fftSize), int32(numChannels)); */
    rfft_process(&Model_Target_B.y_i[0], &MedusaFdpFullRateRfftRfftInput[0],
                 &MedusaFdpFullRateRfftRfftBufferTwiddle1[0],
                 &MedusaFdpFullRateRfftRfftBufferTwiddle2[0],
                 &MedusaFdpFullRateRfftRfftBufferRfftOutputTmp[0], 256, 2);

    /* Math: '<S774>/Math Function'
     *
     * About '<S774>/Math Function':
     *  Operator: magnitude^2
     */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        /* Selector: '<S753>/Selector' incorporates:
         *  Math: '<S756>/Math Function'
         *  Math: '<S756>/Math Function1'
         *  Math: '<S774>/Math Function1'
         *  Selector: '<S753>/Selector1'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S774>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.y_i[delayLen];
        Model_Target_B.Lin2[delayLen] = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;
    }

    /* MATLAB Function: '<S759>/Coeffs 1st Stage' incorporates:
     *  Selector: '<S753>/Selector'
     *  Selector: '<S753>/Selector1'
     */
    Model_Target_Coeffs1stStage(&Model_Target_B.y_i[0], &Model_Target_B.y_i[129],
        &Model_Target_B.sf_Coeffs1stStage_m);

    /* MATLAB Function: '<S762>/MATLAB Function' incorporates:
     *  Math: '<S774>/Math Function'
     *  Product: '<S789>/Multiply'
     *
     * About '<S774>/Math Function':
     *  Operator: magnitude^2
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Calculate coefficients/Instantaneous Stretch Coeffs /MATLAB Function': '<S767>:1' */
    /* '<S767>:1:6' coder.inline('always'); */
    /* '<S767>:1:7' epsf = single(eps); */
    /*  Step 1: Compute the estimated stretch coefficients or worst-case estimate */
    /*  based on maximum allowable stretching Xpmax */
    /*  NOTE: The Xp used for detect here is the decimated rate Xp, which means */
    /*  the pre-calculated LokRokMaxScaleFactor for treble stretching is done */
    /*  using the decimated rate XpMax. */
    /* '<S767>:1:16' Lstrk = min(Lxk, LokRokMaxScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] =
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsLokRokMaxScaleFactor
            * Model_Target_B.sf_Coeffs1stStage_m.Lok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Multiply_c[row] = fminf
            (Model_Target_B.sf_Coeffs1stStage_m.Lxk[row],
             Model_Target_B.Multiply_n[row]);
    }

    /* '<S767>:1:17' Rstrk = min(Rxk, LokRokMaxScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] =
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsLokRokMaxScaleFactor
            * Model_Target_B.sf_Coeffs1stStage_m.Rok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Lstrk[row] = fminf
            (Model_Target_B.sf_Coeffs1stStage_m.Rxk[row],
             Model_Target_B.Multiply_n[row]);
    }

    /*  Step 2: Compute Excessive Stretch Detector (ESD) - used to update Xp */
    /*  */
    /*                    sum_over_FFT_bins( Lstrki * |Lin|) + sum_over_FFT_bins( Rstrki * |Rin|)   */
    /*  ESD = abs( db20 ( ----------------------------------------------------------------------- ) ) */
    /*                                      sum_over_FFT_bins( Lxki * |Lin| ) */
    /*  */
    /*  since Lxki * |Lin| = min (|Lin|,|Rin|) (per bin), we store the minima  */
    /*  beforehand and use it here */
    /*  Note the matrix shorthand for sum_over_FFT_bins(Lstrki * Lin) is Lstrk' * p.absLi */
    /*  A small positive value is added to the numerator, to avoid db20(0) */
    /* '<S767>:1:30' ESDdB = db20( (epsf + Lstrk(:)' * absLi(:) + Rstrk(:)' * absRi(:)) ... */
    /* '<S767>:1:31'             / (epsf + sum(minAbsLiRi)) ); */
    maxXp = Model_Target_B.sf_Coeffs1stStage_m.minAbsLiRi[0];
    for (row = 0; row < 128; row++)
    {
        maxXp += Model_Target_B.sf_Coeffs1stStage_m.minAbsLiRi[row + 1];
    }

    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: db20.m 11813 2012-07-11 17:31:25Z rs7109 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    updatedLokRokScaleFactor = 0.0F;
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        updatedLokRokScaleFactor += Model_Target_B.Multiply_c[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absLi[delayLen];
    }

    rtb_Sumhighfrequencyenergy = 0.0F;
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        rtb_Sumhighfrequencyenergy += Model_Target_B.Lstrk[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absRi[delayLen];
    }

    updatedLokRokScaleFactor = qhmath_log_f(qhmath_abs_f(qhmath_div_f
        ((updatedLokRokScaleFactor + 2.22044605E-16F) +
         rtb_Sumhighfrequencyenergy, maxXp + 2.22044605E-16F))) * 8.68588924F;

    /*  "Turn off" stretching by setting minXp and maxXp to zero,  */
    /*  if CAE_enable is zero. */
    /* '<S767>:1:35' if (CAE_enable == 0) */
    if (Model_Target_B.Constant3 == 0)
    {
        /* '<S767>:1:36' minXp = single(0.0); */
        minXp = 0.0F;

        /* '<S767>:1:37' maxXp = single(0.0); */
        maxXp = 0.0F;
    }
    else
    {
        /* '<S767>:1:38' else */
        /* '<S767>:1:39' minXp = Xpmin; */
        minXp = Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsXpMin;

        /* '<S767>:1:40' maxXp = Xpmax; */
        maxXp = Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsXpMax;
    }

    /*  Calculate new stretch factor, Xp, based on ESD value. */
    /*  The following curve is applied: */
    /*         Xp */
    /*         ^ */
    /*         | */
    /*   maxXp +----------. */
    /*         |          .\ */
    /*         |          . \ */
    /*         |          .  \ */
    /*         |          .   \ */
    /*         |          .    \ */
    /*         |          .     \ */
    /*   minXp +          .      --------------- minXp */
    /*         |          .      . */
    /*         +----------+------+-------------> ESD (dB) */
    /*        0           |      | */
    /*                    |     ESD_upper_bound_in_dB - thresh2 */
    /*                    | */
    /*                   ESD_lower_bound_in_dB - thresh1 */
    /* '<S767>:1:63' if (ESDdB < ESDLowerBound) */
    if (updatedLokRokScaleFactor <
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsESDLowerbounddB)
    {
        /*  Stretching is lower than the lower threshold, use largest allowable Xp. */
        /* '<S767>:1:65' Xp = maxXp; */
        minXp = maxXp;
    }
    else if (updatedLokRokScaleFactor <=
             Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsESDUpperbounddB)
    {
        /* '<S767>:1:69' else */
        /*  Stretching in between, compute Xp as a linear interpolation between  */
        /*  max and min based on the two thresholds */
        /* '<S767>:1:72' Xp = minXp + (maxXp - minXp) * ESDStepSize * (ESDUpperBound - ESDdB); */
        minXp += (maxXp - minXp) *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsESDStepSize *
            (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpCoeffsESDUpperbounddB -
             updatedLokRokScaleFactor);
    }
    else
    {
        /* '<S767>:1:66' elseif (ESDdB > ESDUpperBound) */
        /*  Stretching is higher than the upper threshold, use smallest allowable Xp. */
        /* '<S767>:1:68' Xp = minXp; */
    }

    /*  Step 3: Compute updated instantaneous stretch coefficients */
    /* '<S767>:1:76' updatedLokRokScaleFactor = 0.5 * (Xp/(1-Xp+epsf)); */
    updatedLokRokScaleFactor = qhmath_div_f(minXp, (1.0F - minXp) +
        2.22044605E-16F) * 0.5F;

    /*  Calculate instanstaneous Center Selectivity coefficients based on SPS */
    /* '<S767>:1:79' instCPS = 1 - SPS; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS[i] = 1.0F -
            Model_Target_B.sf_Coeffs1stStage_m.SPS[i];
    }

    /* '<S767>:1:80' Lck = instCPS .* Lxk; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk[i] = Model_Target_B.instCPS[i] *
            Model_Target_B.sf_Coeffs1stStage_m.Lxk[i];
    }

    /* '<S767>:1:81' Rck = instCPS .* Rxk; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.instCPS[delayLen] *=
            Model_Target_B.sf_Coeffs1stStage_m.Rxk[delayLen];
    }

    /*  Use the updated value of Xp to calculate stretch coefficients */
    /* '<S767>:1:84' Lstrk = min(Lck, updatedLokRokScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage_m.Lok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Lstrk[row] = fminf(Model_Target_B.Lstrk[row],
            Model_Target_B.Multiply_n[row]);
    }

    /* '<S767>:1:85' Rstrk = min(Rck, updatedLokRokScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage_m.Rok[i];
    }

    for (row = 0; row < 129; row++)
    {
        Model_Target_B.Multiply_c[row] = fminf(Model_Target_B.instCPS[row],
            Model_Target_B.Multiply_n[row]);
        Model_Target_B.Lstrk[row] *= Model_Target_B.Lin2[row];
    }

    /* MATLAB Function: '<S791>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lstrk, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_eb,
        &Model_Target_DW.sf_MATLABFunction_eb);

    /* MATLAB Function: '<S775>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_ap,
        &Model_Target_DW.sf_MATLABFunction_ap);

    /* Math: '<S774>/Math Function2' incorporates:
     *  Constant: '<S774>/Constant1'
     *  S-Function (sdspmultiportsel): '<S857>/Stereo Split'
     *  Sum: '<S774>/Add'
     *
     * About '<S774>/Math Function2':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_ap.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S774>/Math Function2' */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        /* Math: '<S774>/Math Function1' incorporates:
         *  Math: '<S756>/Math Function'
         *  Math: '<S756>/Math Function1'
         *  Math: '<S774>/Math Function'
         *  Selector: '<S753>/Selector'
         *  Selector: '<S753>/Selector1'
         *
         * About '<S774>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S774>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.y_i[delayLen + 129];
        rtb_Sumhighfrequencyenergy = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;

        /* Product: '<S790>/Multiply' incorporates:
         *  MATLAB Function: '<S762>/MATLAB Function'
         *  Math: '<S774>/Math Function1'
         *
         * About '<S774>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Multiply_n[delayLen] = rtb_Sumhighfrequencyenergy *
            Model_Target_B.Multiply_c[delayLen];

        /* Math: '<S774>/Math Function1'
         *
         * About '<S774>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lstrk[delayLen] = rtb_Sumhighfrequencyenergy;
    }

    /* MATLAB Function: '<S793>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Multiply_n, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_ii,
        &Model_Target_DW.sf_MATLABFunction_ii);

    /* MATLAB Function: '<S776>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lstrk, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_n0,
        &Model_Target_DW.sf_MATLABFunction_n0);

    /* Math: '<S774>/Math Function3' incorporates:
     *  Constant: '<S774>/Constant2'
     *  Product: '<S809>/Divide'
     *  Sum: '<S774>/Add1'
     *
     * About '<S774>/Math Function3':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_n[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_n0.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S774>/Math Function3' */

    /* Product: '<S768>/Multiply' incorporates:
     *  Math: '<S774>/Math Function'
     *
     * About '<S774>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_c[i] = Model_Target_B.Lin2[i] *
            Model_Target_B.sf_Coeffs1stStage_m.Lok[i];
    }

    /* End of Product: '<S768>/Multiply' */

    /* MATLAB Function: '<S770>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Multiply_c, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_c5,
        &Model_Target_DW.sf_MATLABFunction_c5);

    /* Product: '<S768>/Multiply1' incorporates:
     *  S-Function (sdspmultiportsel): '<S857>/Stereo Split'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_e[i] = Model_Target_B.sf_MATLABFunction_c5.y[i]
            * Model_Target_B.instCPS[i];
    }

    /* End of Product: '<S768>/Multiply1' */

    /* Product: '<S769>/Multiply' incorporates:
     *  Math: '<S774>/Math Function1'
     *
     * About '<S774>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_c[i] = Model_Target_B.Lstrk[i] *
            Model_Target_B.sf_Coeffs1stStage_m.Rok[i];
    }

    /* End of Product: '<S769>/Multiply' */

    /* MATLAB Function: '<S772>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Multiply_c, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_ec,
        &Model_Target_DW.sf_MATLABFunction_ec);

    /* Product: '<S769>/Multiply1' incorporates:
     *  Product: '<S809>/Divide'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_m[i] = Model_Target_B.sf_MATLABFunction_ec.y[i]
            * Model_Target_B.Multiply_n[i];
    }

    /* End of Product: '<S769>/Multiply1' */

    /* MATLAB Function: '<S759>/Coeffs 2nd Stage' incorporates:
     *  Product: '<S768>/Multiply1'
     *  Product: '<S769>/Multiply1'
     */
    /*  Update mono coeffs after smoothing far left/right coeffs */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Calculate coefficients/Coeffs 2nd Stage': '<S761>:1' */
    /*  Left only/right only coefficients */
    /* '<S761>:1:5' Lxks = 1 - Loks; */
    /* '<S761>:1:6' Rxks = 1 - Roks; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lxks[i] = 1.0F - Model_Target_B.Multiply1_e[i];
        rtb_Rxks[i] = 1.0F - Model_Target_B.Multiply1_m[i];
    }

    /* End of MATLAB Function: '<S759>/Coeffs 2nd Stage' */

    /* MATLAB Function: '<S766>/Normalize Stretch Coeffs' incorporates:
     *  Math: '<S774>/Math Function'
     *  Product: '<S783>/Multiply'
     *  Product: '<S789>/Multiply1'
     *  Product: '<S790>/Multiply1'
     *  Product: '<S809>/Divide'
     *  S-Function (sdspmultiportsel): '<S857>/Stereo Split'
     *
     * About '<S774>/Math Function':
     *  Operator: magnitude^2
     */
    /*  Normalize stretch coefficients against mono portion  */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Calculate coefficients/Updated Stretch Coeffs and Steering Coeffs/Normalize Stretch Coeffs': '<S779>:1' */
    /*  Take only difference of L&R strecth coeffs as the total stretch  */
    /* '<S779>:1:6' netStretch = (Lstrks .* absLi) - (Rstrks.* absRi); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_c[i] = Model_Target_B.sf_MATLABFunction_eb.y[i] *
            Model_Target_B.instCPS[i] *
            Model_Target_B.sf_Coeffs1stStage_m.absLi[i] -
            Model_Target_B.sf_MATLABFunction_ii.y[i] *
            Model_Target_B.Multiply_n[i] *
            Model_Target_B.sf_Coeffs1stStage_m.absRi[i];
    }

    /*  Normalize by the smoothed total shared level  */
    /* '<S779>:1:9' epsf = single(eps); */
    /* '<S779>:1:10' LxSmth = (Lxks .* absLi) + epsf; */
    /* '<S779>:1:11' RxSmth = (Rxks .* absRi) + epsf; */
    /* '<S779>:1:13' Lstrki = max(0.0, netStretch) ./ LxSmth; */
    for (row = 0; row < 129; row++)
    {
        rtb_Add1_k3[row] = fmaxf(0.0F, Model_Target_B.Multiply_c[row]);
    }

    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        rtb_Add1_k3[delayLen] = qhmath_div_f(rtb_Add1_k3[delayLen],
            Model_Target_B.Lxks[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absLi[delayLen] + 2.22044605E-16F);
    }

    /* '<S779>:1:14' Rstrki = max(0.0, (-netStretch)) ./ RxSmth; */
    for (row = 0; row < 129; row++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Multiply_c[row];
        rtb_Add1_ma[row] = fmaxf(0.0F, -updatedLokRokScaleFactor);
        Model_Target_B.Multiply_c[row] = -updatedLokRokScaleFactor;
    }

    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        rtb_Add1_ma[delayLen] = qhmath_div_f(rtb_Add1_ma[delayLen],
            rtb_Rxks[delayLen] *
            Model_Target_B.sf_Coeffs1stStage_m.absRi[delayLen] + 2.22044605E-16F);
    }

    /*  Bound the stretch coefficients within [0,1] */
    /* '<S779>:1:17' Lstrki = min(1.0, max(0.0, Lstrki)); */
    /* '<S779>:1:18' Rstrki = min(1.0, max(0.0, Rstrki)); */
    for (row = 0; row < 129; row++)
    {
        updatedLokRokScaleFactor = fminf(1.0F, fmaxf(0.0F, rtb_Add1_k3[row]));
        rtb_Sumhighfrequencyenergy = fmaxf(0.0F, rtb_Add1_ma[row]);
        Model_Target_B.Multiply_c[row] = fminf(1.0F, rtb_Sumhighfrequencyenergy);
        rtb_Add1_k3[row] = rtb_Sumhighfrequencyenergy;
        Model_Target_B.Lin2[row] *= updatedLokRokScaleFactor;
    }

    /* MATLAB Function: '<S785>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_fi,
        &Model_Target_DW.sf_MATLABFunction_fi);

    /* Product: '<S783>/Multiply1' incorporates:
     *  S-Function (sdspmultiportsel): '<S857>/Stereo Split'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lin2[i] = Model_Target_B.sf_MATLABFunction_fi.y[i] *
            Model_Target_B.instCPS[i];
    }

    /* End of Product: '<S783>/Multiply1' */

    /* Product: '<S784>/Multiply' incorporates:
     *  MATLAB Function: '<S766>/Normalize Stretch Coeffs'
     *  Math: '<S774>/Math Function1'
     *
     * About '<S774>/Math Function1':
     *  Operator: magnitude^2
     */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Lstrk[delayLen] *= Model_Target_B.Multiply_c[delayLen];
    }

    /* End of Product: '<S784>/Multiply' */

    /* MATLAB Function: '<S787>/MATLAB Function' incorporates:
     *  Constant: '<S764>/lsGain1'
     *  Constant: '<S764>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lstrk, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_m,
        &Model_Target_DW.sf_MATLABFunction_m);

    /* Product: '<S784>/Multiply1' incorporates:
     *  Product: '<S809>/Divide'
     */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Multiply_n[delayLen] *=
            Model_Target_B.sf_MATLABFunction_m.y[delayLen];
    }

    /* End of Product: '<S784>/Multiply1' */

    /* MATLAB Function: '<S766>/Update Steering Coeffs' */
    Model_Target_UpdateSteeringCoeffs(Model_Target_B.Lin2,
        Model_Target_B.Multiply_n, Model_Target_B.Multiply1_e,
        Model_Target_B.Multiply1_m, Model_Target_B.Lxks, rtb_Rxks,
        &Model_Target_B.sf_UpdateSteeringCoeffs_b);

    /* MATLAB Function: '<S757>/Apply coefficients' incorporates:
     *  Selector: '<S753>/Selector'
     *  Selector: '<S753>/Selector1'
     */
    /*  For full-rate Medusa Processing, since we do not generate the Left Surround */
    /*  and Right Surround signals, the residual is simply the leftover "excess" */
    /*  coefficient, after the far left/far right (Lo/Ro) signals have been extracted. */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/FullRate/Apply coefficients': '<S758>:1' */
    /*  Left/Right only */
    /* '<S758>:1:7' Lo = Lok .* L; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.MatrixConcatenate_mb[delayLen].re =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lok[delayLen] *
            Model_Target_B.y_i[delayLen].re;
        Model_Target_B.MatrixConcatenate_mb[delayLen].im =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lok[delayLen] *
            Model_Target_B.y_i[delayLen].im;
    }

    /* '<S758>:1:8' Ro = Rok .* R; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.MatrixConcatenate_mb[delayLen + 129].re =
            Model_Target_B.y_i[delayLen + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rok[delayLen];
        Model_Target_B.MatrixConcatenate_mb[delayLen + 129].im =
            Model_Target_B.y_i[delayLen + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rok[delayLen];
    }

    /*  Left/Right surround residual */
    /* '<S758>:1:11' Lsr = Lxk .* L; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Lsr[delayLen].re =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lxk[delayLen] *
            Model_Target_B.y_i[delayLen].re;
        Model_Target_B.Lsr[delayLen].im =
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Lxk[delayLen] *
            Model_Target_B.y_i[delayLen].im;
    }

    /* '<S758>:1:12' Rsr = Rxk .* R; */
    for (delayLen = 0; delayLen < 129; delayLen++)
    {
        Model_Target_B.Rsr[delayLen].re = Model_Target_B.y_i[delayLen + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rxk[delayLen];
        Model_Target_B.Rsr[delayLen].im = Model_Target_B.y_i[delayLen + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs_b.Rxk[delayLen];
    }

    /* End of MATLAB Function: '<S757>/Apply coefficients' */

    /* Product: '<S799>/Divide' incorporates:
     *  Constant: '<S799>/Constant'
     *  Constant: '<S799>/Constant1'
     *  Product: '<S810>/Divide'
     *  Sum: '<S799>/Minus'
     */
    updatedLokRokScaleFactor_tmp = (1.0F -
        Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumFastPsdSmoothFactor) *
        0.5F;

    /* Sum: '<S800>/Matrix Sum' */
    rtb_Delay_og = -0.0F;
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S756>/Math Function' incorporates:
         *  Math: '<S756>/Math Function1'
         *  Math: '<S774>/Math Function'
         *  Math: '<S774>/Math Function1'
         *  Selector: '<S753>/Selector'
         *  Selector: '<S753>/Selector1'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S774>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S774>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.Lsr[i];

        /* Math: '<S756>/Math Function'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.MathFunction[i] = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;

        /* Sum: '<S799>/Add1' incorporates:
         *  Delay: '<S799>/Delay'
         *  Delay: '<S799>/Delay1'
         *  Math: '<S756>/Math Function'
         *  Product: '<S799>/Divide'
         *  Product: '<S799>/Multiply'
         *  Product: '<S799>/Multiply1'
         *  Sum: '<S799>/Add'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lin2[i] = (Model_Target_B.MathFunction[i] +
            Model_Target_DW.Delay_DSTATE_i[i]) * updatedLokRokScaleFactor_tmp +
            Model_Target_DW.Delay1_DSTATE[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S800>/Matrix Sum' incorporates:
         *  Math: '<S756>/Math Function'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Delay_og += Model_Target_B.MathFunction[i];
    }

    /* Sum: '<S803>/Sum2' incorporates:
     *  Constant: '<S803>/Constant'
     *  Gain: '<S803>/Gain'
     *  Math: '<S803>/log10'
     *  Sum: '<S803>/Sum1'
     *
     * About '<S803>/log10':
     *  Operator: log10
     */
    updatedLokRokScaleFactor = qhmath_log10_f(rtb_Delay_og + 2.22044605E-16F) *
        10.0F;

    /* MATLAB Function: '<S800>/Detect Impulse' incorporates:
     *  Delay: '<S800>/Delay'
     *  Sum: '<S800>/Add1'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Left Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S802>:1' */
    /* '<S802>:1:5' if isempty(counter) */
    /* '<S802>:1:6' if isempty(state) */
    /* '<S802>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (updatedLokRokScaleFactor - Model_Target_DW.Delay_DSTATE_nb > 0.75F)
    {
        /* '<S802>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S802>:1:10' counter = 0; */
        Model_Target_DW.counter_b = 0.0;
    }
    else if ((Model_Target_DW.counter_b <
              Model_Target_MaxValueOfCounterForDetectingImpulse_n) &&
             (Model_Target_DW.state_l == 1.0))
    {
        /* '<S802>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S802>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S802>:1:13' counter = counter + 1; */
        Model_Target_DW.counter_b++;
    }
    else
    {
        /* '<S802>:1:14' else */
        /* '<S802>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_g = 0;
    }

    /* '<S802>:1:17' state = isImpulsive; */
    Model_Target_DW.state_l = rtb_isImpulsive_g;

    /* End of MATLAB Function: '<S800>/Detect Impulse' */

    /* Product: '<S801>/Divide' incorporates:
     *  Constant: '<S801>/Constant'
     *  Constant: '<S801>/Constant1'
     *  Product: '<S812>/Divide'
     *  Sum: '<S801>/Minus'
     */
    minXp_tmp = (1.0F -
                 Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumSlowPsdSmoothFactor)
        * 0.5F;

    /* Sum: '<S801>/Add1' incorporates:
     *  Delay: '<S801>/Delay'
     *  Delay: '<S801>/Delay1'
     *  Math: '<S756>/Math Function'
     *  Product: '<S801>/Divide'
     *  Product: '<S801>/Multiply'
     *  Product: '<S801>/Multiply1'
     *  Sum: '<S801>/Add'
     *
     * About '<S756>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        rtb_Add1_k3[i] = (Model_Target_B.MathFunction[i] +
                          Model_Target_DW.Delay_DSTATE_l[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_a[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S801>/Add1' */

    /* Delay: '<S797>/Delay' incorporates:
     *  Sum: '<S799>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_e[0], &Model_Target_B.Lin2[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec >
            2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                Model_Target_B.Multiply1_e[i] =
                    Model_Target_DW.MedusaDRspumLPxxFast[(i - delayLen) + 2064];
            }
            else
            {
                Model_Target_B.Multiply1_e[i] = Model_Target_B.Lin2[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S797>/Delay' */

    /* Delay: '<S797>/Delay1' incorporates:
     *  Sum: '<S801>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_m[0], &rtb_Add1_k3[0], 129U * sizeof
               (real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec >
            2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                Model_Target_B.Multiply1_m[i] =
                    Model_Target_DW.MedusaDRspumLPxxSlow[(i - delayLen) + 2064];
            }
            else
            {
                Model_Target_B.Multiply1_m[i] = rtb_Add1_k3[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S797>/Delay1' */

    /* Buffer: '<S650>/Buffer' */
    delayLen = 0;
    currentOffset = Model_Target_DW.Buffer_outBufPtrIdx + 128;
    for (row = 0; row < 2; row++)
    {
        memIdx = (row << 8) + Model_Target_DW.Buffer_outBufPtrIdx;
        memcpy(&Model_Target_B.Buffer[delayLen],
               &Model_Target_DW.Buffer_CircBuf[memIdx], sizeof(real32_T) << 7U);
        delayLen += 128;
    }

    if (Model_Target_DW.Buffer_outBufPtrIdx + 128 == 256)
    {
        currentOffset = 0;
    }

    Model_Target_DW.Buffer_outBufPtrIdx = currentOffset;

    /* End of Buffer: '<S650>/Buffer' */

    /* Sum: '<S856>/Sum high  frequency energy' */
    rtb_Sumhighfrequencyenergy = -0.0F;
    for (row = 0; row < 128; row++)
    {
        /* S-Function (sdspmultiportsel): '<S857>/Stereo Split' incorporates:
         *  Buffer: '<S650>/Buffer'
         */
        minXp = Model_Target_B.Buffer[row];
        slewedStepSize = Model_Target_B.Buffer[row + 128];

        /* Sum: '<S857>/Add' incorporates:
         *  Math: '<S857>/Magnitude Squared'
         *  Math: '<S857>/Magnitude Squared1'
         *
         * About '<S857>/Magnitude Squared':
         *  Operator: magnitude^2
         *
         * About '<S857>/Magnitude Squared1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Add[row] = minXp * minXp + slewedStepSize *
            slewedStepSize;

        /* Sum: '<S856>/Sum high  frequency energy' incorporates:
         *  Sum: '<S857>/Add'
         */
        rtb_Sumhighfrequencyenergy += Model_Target_B.Add[row];
    }

    /* Sum: '<S862>/Add1' incorporates:
     *  Constant: '<S862>/Constant'
     *  Constant: '<S862>/Constant1'
     *  Delay: '<S862>/Delay'
     *  Delay: '<S862>/Delay1'
     *  Product: '<S862>/Divide'
     *  Product: '<S862>/Multiply'
     *  Product: '<S862>/Multiply1'
     *  Sum: '<S862>/Add'
     *  Sum: '<S862>/Minus'
     */
    minXp = (1.0F - Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstPSDSmoothFactor)
        * 0.5F * (rtb_Sumhighfrequencyenergy + Model_Target_DW.Delay_DSTATE_i3)
        + Model_Target_DW.Delay1_DSTATE_p *
        Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstPSDSmoothFactor;

    /* MATLAB Function: '<S856>/Estimate Decay' incorporates:
     *  BusCreator generated from: '<S856>/Estimate Decay'
     *  Constant: '<S866>/Constant'
     *  Gain: '<S856>/Gain'
     *  Gain: '<S866>/Gain'
     *  Math: '<S866>/log10'
     *  Sum: '<S866>/Sum1'
     *
     * About '<S866>/log10':
     *  Operator: log10
     */
    /*  Estimate and output decay on linear scale  */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/SPUM Decay Estimate/Decay Estimate/Estimate Decay': '<S859>:1' */
    /*  Buffer holding frame energies in dB */
    /*  Flag to indicate onset strike is on */
    /*  Flag to indicate onset strike is off */
    /*  No activity counter, 'gcounter' in AR model */
    /*  Previous decay slope in dB, 'decay_slope_in_db_per_frame' in bdsp */
    /*  Previous smoothed decay slope in dB */
    /*  Frame energy in dB to allow current onset thresholding, 'gate' in AR model */
    /*  Initialize parameters */
    /* '<S859>:1:14' if isempty(onsetOn) */
    /* '<S859>:1:15' if isempty(onsetOff) */
    /* '<S859>:1:16' if isempty(onsetCounter) */
    /* '<S859>:1:17' if isempty(noOnsetOnOffCounter) */
    /* '<S859>:1:18' if isempty(prevDecay) */
    /* '<S859>:1:19' if isempty(smoothedDecay) */
    /* '<S859>:1:20' if isempty(thresholdForFrameEnergy) */
    /*  Update frame energies buffer */
    /*  latest energy is always the last frame */
    /*  TODO: implement with circular buffer */
    /* '<S859>:1:27' frameEnergiesdB(1:end-1) = frameEnergiesdB(2:end); */
    for (delayLen = 0; delayLen < 7; delayLen++)
    {
        Model_Target_DW.frameEnergiesdB[delayLen] =
            Model_Target_DW.frameEnergiesdB[delayLen + 1];
    }

    /* '<S859>:1:28' frameEnergiesdB(end) = frameEnergydB; */
    Model_Target_DW.frameEnergiesdB[7] = qhmath_log10_f(100.0F * minXp +
        2.22044605E-16F) * 10.0F;

    /*  persistent writeIndex; */
    /*  frameEnergiesdB(writeIndex) = frameEnergydB; */
    /*  writeIndex = mod(writeIndex+1,lengthFrameEnergiesBuffer); */
    /*  derivative = least_square_fit(frameEnergiesdB, writeIndex); */
    /*  Estimate derivative (slope) using first order least square fitting */
    /* '<S859>:1:36' derivative = least_square_fit(frameEnergiesdB,... */
    /* '<S859>:1:37'                 decayConst.numPointsForSlopeComputation,... */
    /* '<S859>:1:38'                 decayConst.lengthFrameEnergiesBuffer); */
    /*  Estimate derivative or slope via first order least square fitting.  */
    /*  Implements following equation to compute k. */
    /*   */
    /*  x = [X_0, X_1, X_2, ..., X_(N-1)] = frame indicies */
    /*  y = [Y_0, Y_1, Y_2, ..., X_(N-1)] = frame energies */
    /*   */
    /*       sum(Xi * Yi) - (1/N) * sum(Xi) * sum(Yi) */
    /*  k = ------------------------------------------- , */
    /*       sum(Xi * Xi) - (1/N) * sum(Xi) * sum(Xi) */
    /*     where i = 0, 1, 2, ... , N-1. */
    /*  */
    /*  M = lengthFrameEnergiesBuffer = 8 ; */
    /*  N = numPointsForSlopeComputation = 5; */
    /* '<S859>:1:130' y = in(M-N+1:M); */
    /* '<S859>:1:131' x = (0:size(y,1)-1)'; */
    /* '<S859>:1:132' d = (sum(x.*y) - sum(x)*sum(y)/N) / (sum(x.^2) - (sum(x))^2/N + single(eps)); */
    for (delayLen = 0; delayLen < 5; delayLen++)
    {
        y[delayLen] = Model_Target_DW.frameEnergiesdB[delayLen + 3] * (real32_T)
            delayLen;
    }

    rtb_Delay_og = qhmath_div_f(((((y[0] + y[1]) + y[2]) + y[3]) + y[4]) -
        qhmath_div_f(((((Model_Target_DW.frameEnergiesdB[3] +
                         Model_Target_DW.frameEnergiesdB[4]) +
                        Model_Target_DW.frameEnergiesdB[5]) +
                       Model_Target_DW.frameEnergiesdB[6]) +
                      Model_Target_DW.frameEnergiesdB[7]) * 10.0F, 5.0F), 10.0F);

    /*  x = 0:size(y,1); */
    /*  derivative = (sum(x.*y) - sum(x)*sum(y)/N) / (sum(x.^2) - (sum(x))^2/N + epsf); */
    /*  Increment no onset on/off counter by 1 */
    /* '<S859>:1:43' noOnsetOnOffCounter = noOnsetOnOffCounter + 1; */
    Model_Target_DW.noOnsetOnOffCounter++;

    /*  Detect onset on */
    /*  if level jump (energy variation) > onset threshold AND  */
    /*  input level (current frame energy) > input threshold */
    /* '<S859>:1:48' latestEnergy = frameEnergiesdB(end); */
    /* '<S859>:1:49' oldestEnergy = frameEnergiesdB(1); */
    /* '<S859>:1:50' onsetVal =  latestEnergy - oldestEnergy; */
    /* '<S859>:1:51' if (onsetVal > decayEstTunable.onsetThreshold) && (latestEnergy > thresholdForFrameEnergy) */
    if ((Model_Target_DW.frameEnergiesdB[7] - Model_Target_DW.frameEnergiesdB[0]
         > Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstOnsetThreshold) &&
            (Model_Target_DW.frameEnergiesdB[7] >
             Model_Target_DW.thresholdForFrameEnergy))
    {
        /* '<S859>:1:52' onsetOn = 1; */
        Model_Target_DW.onsetOn = 1.0;

        /* '<S859>:1:53' thresholdForFrameEnergy = latestEnergy - 3; */
        Model_Target_DW.thresholdForFrameEnergy =
            Model_Target_DW.frameEnergiesdB[7] - 3.0F;

        /*  threshold = current - 3dB */
        /* '<S859>:1:54' onsetCounter = 0; */
        Model_Target_DW.onsetCounter = 0.0;
    }

    /*  Validate onset */
    /* '<S859>:1:58' if onsetOn */
    if (Model_Target_DW.onsetOn != 0.0)
    {
        /* '<S859>:1:59' onsetCounter = onsetCounter + 1; */
        Model_Target_DW.onsetCounter++;

        /* '<S859>:1:60' if onsetCounter >  decayConst.onsetCounterLimit */
        if (Model_Target_DW.onsetCounter > 700.0)
        {
            /*  timeout and reset */
            /* '<S859>:1:61' onsetOn = 0; */
            Model_Target_DW.onsetOn = 0.0;

            /* '<S859>:1:62' onsetCounter = 0; */
            Model_Target_DW.onsetCounter = 0.0;
        }
    }

    /*  Detect onset off */
    /*  if energy variation < threshold AND input level < input threshold */
    /*  AND onsetOn detected AND onsetOff not yet detected */
    /* '<S859>:1:69' if (derivative < decayConst.decaySlowest) && (onsetOn == 1) && (onsetOff == 0)... */
    /* '<S859>:1:70'         && (latestEnergy < thresholdForFrameEnergy) */
    if ((rtb_Delay_og < -0.0693333298F) && (Model_Target_DW.onsetOn == 1.0) &&
            (Model_Target_DW.onsetOff == 0.0) &&
            (Model_Target_DW.frameEnergiesdB[7] <
             Model_Target_DW.thresholdForFrameEnergy))
    {
        /* '<S859>:1:71' onsetOff = 1; */
        Model_Target_DW.onsetOff = 1.0;

        /* '<S859>:1:72' thresholdForFrameEnergy = decayConst.minGateFrameEnergydB; */
        Model_Target_DW.thresholdForFrameEnergy = -25.0F;
    }

    /*  Update slope */
    /* '<S859>:1:76' if (onsetOn == 1) && (onsetOff == 1) */
    if ((Model_Target_DW.onsetOn == 1.0) && (Model_Target_DW.onsetOff == 1.0))
    {
        /* '<S859>:1:77' if (oldestEnergy > latestEnergy) && (oldestEnergy > decayEstTunable.noiseFloor) */
        if (Model_Target_DW.frameEnergiesdB[0] >
                Model_Target_DW.frameEnergiesdB[7])
        {
            if (Model_Target_DW.frameEnergiesdB[0] >
                    Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstNoiseFloor)
            {
                /* '<S859>:1:78' slope = derivative; */
                /*  take the slope as decay estimate */
                /* '<S859>:1:79' noOnsetOnOffCounter = 0; */
                Model_Target_DW.noOnsetOnOffCounter = 0.0;

                /*  reset no activity counter */
                /* '<S859>:1:80' onsetCounter = 0; */
                Model_Target_DW.onsetCounter = 0.0;

                /*  reset counter   */
            }
            else
            {
                /* '<S859>:1:81' else */
                /* '<S859>:1:82' slope = prevDecay; */
                rtb_Delay_og = Model_Target_DW.prevDecay;
            }
        }
        else
        {
            /* '<S859>:1:81' else */
            /* '<S859>:1:82' slope = prevDecay; */
            rtb_Delay_og = Model_Target_DW.prevDecay;
        }

        /* '<S859>:1:84' prevDecay = slope; */
        Model_Target_DW.prevDecay = rtb_Delay_og;

        /* '<S859>:1:85' onsetOn = 0; */
        Model_Target_DW.onsetOn = 0.0;

        /* '<S859>:1:86' onsetOff = 0; */
        Model_Target_DW.onsetOff = 0.0;
    }
    else
    {
        /* '<S859>:1:87' else */
        /* '<S859>:1:88' slope = prevDecay; */
        rtb_Delay_og = Model_Target_DW.prevDecay;
    }

    /*  Validate slope */
    /*  if no onset detected for a predefined period, return to the default decay value */
    /* '<S859>:1:93' if noOnsetOnOffCounter > decayConst.decayDefaultCounterLimit */
    if (Model_Target_DW.noOnsetOnOffCounter > 10385.0)
    {
        /* '<S859>:1:94' slope = decayConst.decayDefaultSlope; */
        rtb_Delay_og = -0.173333332F;

        /* '<S859>:1:95' noOnsetOnOffCounter = 0; */
        Model_Target_DW.noOnsetOnOffCounter = 0.0;
    }

    /*  Smooth slope  */
    /*  using first order averaging with different smoothing params (fast or  */
    /*  slow) depending on estimated slope */
    /* '<S859>:1:101' if slope >= smoothedDecay */
    if (rtb_Delay_og >= Model_Target_DW.smoothedDecay)
    {
        /* '<S859>:1:102' alpha = decayEstTunable.slowAttack; */
        maxXp = Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstSlowAttack;
    }
    else
    {
        /* '<S859>:1:103' else */
        /* '<S859>:1:104' alpha = decayEstTunable.fastAttack; */
        maxXp = Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstFastAttack;
    }

    /* '<S859>:1:106' smoothedDecay = slope*alpha + (1-alpha)*smoothedDecay; */
    Model_Target_DW.smoothedDecay = (1.0F - maxXp) *
        Model_Target_DW.smoothedDecay + rtb_Delay_og * maxXp;

    /* '<S859>:1:107' noOnsetOnOffCounter = noOnsetOnOffCounter + 1; */
    Model_Target_DW.noOnsetOnOffCounter++;

    /*  Clip the estimated smoothed decay slope (in db/frame) and convert it to  */
    /*  linear decay for smoothing next. */
    /* '<S859>:1:111' decay = undb10(max(min(smoothedDecay, decayConst.decaySlowest), ... */
    /* '<S859>:1:112'     decayConst.decayFastest) * decayEstTunable.directPathFramesFs); */
    /* '<S859>:1:136' y = exp(x * log(10)/10); */
    rtb_Delay_og = qhmath_exp_f(qhmath_div_f(fmaxf(fminf
        (Model_Target_DW.smoothedDecay, -0.0693333298F), -0.346666664F) *
        Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstDirectPathFramesFs *
        2.30258512F, 10.0F));

    /* End of MATLAB Function: '<S856>/Estimate Decay' */

    /* MATLAB Function: '<S856>/Smooth Decay' */
    /*  This is basically the same as Forward-backward Smooth block. */
    /*  However as the initial conditions depend on a TOP and build-time config, */
    /*  a Matlab implementation was done for simplification. */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/SPUM Decay Estimate/Decay Estimate/Smooth Decay': '<S861>:1' */
    /* '<S861>:1:8' if isempty(lastInput) */
    if (!Model_Target_DW.lastInput_not_empty)
    {
        /* '<S861>:1:8' ; */
        /* '<S861>:1:8' lastInput = single(undb10(decayConst.decayDefaultSlope * directPathFrames)); */
        /* '<S861>:1:21' y = exp(x * log(10)/10); */
        Model_Target_DW.lastInput = qhmath_div_f(-0.173333332F *
            Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstDirectPathFramesFs *
            2.30258512F, 10.0F);
        Model_Target_DW.lastInput = qhmath_exp_f(Model_Target_DW.lastInput);
        Model_Target_DW.lastInput_not_empty = true;
    }

    /* '<S861>:1:9' if isempty(lastOutput) */
    if (!Model_Target_DW.lastOutput_not_empty)
    {
        /* '<S861>:1:9' ; */
        /* '<S861>:1:9' lastOutput = single(undb10(decayConst.decayDefaultSlope * directPathFrames)); */
        /* '<S861>:1:21' y = exp(x * log(10)/10); */
        Model_Target_DW.lastOutput = qhmath_div_f(-0.173333332F *
            Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstDirectPathFramesFs *
            2.30258512F, 10.0F);
        Model_Target_DW.lastOutput = qhmath_exp_f(Model_Target_DW.lastOutput);
        Model_Target_DW.lastOutput_not_empty = true;
    }

    /* '<S861>:1:11' pole = alpha; */
    /* '<S861>:1:12' gain = (1 - alpha)/2; */
    /* '<S861>:1:14' Output = (Input + lastInput) * gain + lastOutput * pole; */
    maxXp = (rtb_Delay_og + Model_Target_DW.lastInput) * qhmath_div_f(1.0F -
        Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstDecaySmoothFactor, 2.0F) +
        Model_Target_DW.lastOutput *
        Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstDecaySmoothFactor;

    /* '<S861>:1:15' lastInput = Input; */
    Model_Target_DW.lastInput = rtb_Delay_og;

    /* '<S861>:1:16' lastOutput = Output; */
    Model_Target_DW.lastOutput = maxXp;

    /* End of MATLAB Function: '<S856>/Smooth Decay' */

    /* MATLAB Function: '<S856>/Slew Decay' incorporates:
     *  BusCreator generated from: '<S856>/Slew Decay'
     */
    /*  Control how abruptly the decay can change from frame to frame. */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/SPUM Decay Estimate/Decay Estimate/Slew Decay': '<S860>:1' */
    /* '<S860>:1:3' epsf = single(eps); */
    /*  difference of current and past decay in dB */
    /* '<S860>:1:8' if isempty(prevDelta) */
    /* '<S860>:1:9' if isempty(prevStepSize) */
    /* '<S860>:1:10' if isempty(prevSmoothedDecaydB) */
    if (!Model_Target_DW.prevSmoothedDecaydB_not_empty)
    {
        /*  Initial value is decay default in dB */
        /* '<S860>:1:12' prevSmoothedDecaydB = single(decayConst.decayDefaultSlope * directPathFrames); */
        Model_Target_DW.prevSmoothedDecaydB = -0.173333332F *
            Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstDirectPathFramesFs;
        Model_Target_DW.prevSmoothedDecaydB_not_empty = true;
    }

    /* '<S860>:1:15' smoothedDecaydB = db10(smoothedDecayLinear + epsf); */
    /* '<S860>:1:48' y = 10*log10(x); */
    /* '<S860>:1:16' delta = smoothedDecaydB - prevSmoothedDecaydB; */
    rtb_Delay_og = qhmath_log10_f(maxXp + 2.22044605E-16F) * 10.0F -
        Model_Target_DW.prevSmoothedDecaydB;

    /* '<S860>:1:17' if delta > 0 */
    if (rtb_Delay_og > 0.0F)
    {
        /*  Move up if difference is positive => increasing */
        /* '<S860>:1:19' stepSize = min(decaySlewTunable.slewIncrement, delta); */
        maxXp = fminf(Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstStepIncrement,
                      rtb_Delay_og);
    }
    else
    {
        /* '<S860>:1:20' else */
        /*  Move down if difference is negative => decreasing */
        /* '<S860>:1:22' stepSize = max(decaySlewTunable.slewDecrement, delta); */
        maxXp = fmaxf(Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstStepDecrement,
                      rtb_Delay_og);
    }

    /*  If equal sign then still moving in previous direction => keep moving, */
    /*  else reach target and no slewing required */
    /* '<S860>:1:27' if prevDelta * delta > 0 */
    if (Model_Target_DW.prevDelta * rtb_Delay_og > 0.0F)
    {
        /* '<S860>:1:28' slewedStepSize = prevStepSize; */
        slewedStepSize = Model_Target_DW.prevStepSize;
    }
    else
    {
        /* '<S860>:1:29' else */
        /* '<S860>:1:30' slewedStepSize = single(0); */
        slewedStepSize = 0.0F;
    }

    /*  If the difference is within upper bound and slewed stepsize */
    /*  still respects instanteneous stepsize, we can trust slewed stepsize. */
    /* '<S860>:1:35' if (abs(delta) <= decaySlewTunable.slewThreshold) && (abs(slewedStepSize) < abs(stepSize)) */
    if ((qhmath_abs_f(rtb_Delay_og) <=
            Model_Target_PreAmp_p3_b0.MedusaSPUMDecayEstSlewThreshold) &&
            (qhmath_abs_f(slewedStepSize) < qhmath_abs_f(maxXp)))
    {
        /* '<S860>:1:36' stepSize = slewedStepSize; */
        maxXp = slewedStepSize;
    }

    /*  Update states and output */
    /* '<S860>:1:40' prevDelta = delta; */
    Model_Target_DW.prevDelta = rtb_Delay_og;

    /* '<S860>:1:41' prevStepSize = stepSize; */
    Model_Target_DW.prevStepSize = maxXp;

    /* '<S860>:1:42' prevSmoothedDecaydB = prevSmoothedDecaydB + stepSize; */
    Model_Target_DW.prevSmoothedDecaydB += maxXp;

    /* Product: '<S650>/Multiply' incorporates:
     *  DataTypeConversion: '<S650>/Cast To Single'
     *  MATLAB Function: '<S856>/Slew Decay'
     */
    /* '<S860>:1:43' slewedDecayLinear = undb10(prevSmoothedDecaydB); */
    /* '<S860>:1:52' y = exp(x * log(10)/10); */
    Model_Target_B.Multiply = qhmath_exp_f(qhmath_div_f
        (Model_Target_DW.prevSmoothedDecaydB * 2.30258512F, 10.0F)) * (real32_T)
        Model_Target_B.Merge;

    /* Product: '<S806>/Divide' incorporates:
     *  Constant: '<S806>/Constant'
     *  Constant: '<S806>/Constant1'
     *  Product: '<S807>/Divide'
     *  Product: '<S817>/Divide'
     *  Product: '<S818>/Divide'
     *  Sum: '<S806>/Minus'
     */
    maxXp = (1.0F -
             Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumLsSmoothFactor) *
        0.5F;

    /* Sum: '<S811>/Matrix Sum' */
    rtb_Delay_og = -0.0F;
    for (i = 0; i < 129; i++)
    {
        real32_T rtb_Add1_i4;

        /* Switch: '<S795>/Switch' incorporates:
         *  Constant: '<S795>/Constant'
         *  Constant: '<S795>/Constant1'
         *  MinMax: '<S795>/Min'
         *  Product: '<S795>/Divide'
         *  Product: '<S795>/Multiply'
         *  Sum: '<S795>/Add'
         *  Switch: '<S797>/Switch'
         *  Switch: '<S797>/Switch1'
         */
        if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumOverwrite != 0.0F)
        {
            slewedStepSize = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_g > 0)
            {
                /* Switch: '<S797>/Switch1' incorporates:
                 *  Sum: '<S799>/Add1'
                 */
                slewedStepSize = Model_Target_B.Lin2[i];

                /* Switch: '<S797>/Switch' incorporates:
                 *  Delay: '<S797>/Delay'
                 */
                rtb_R_re = Model_Target_B.Multiply1_e[i];
            }
            else
            {
                /* Switch: '<S797>/Switch1' incorporates:
                 *  Sum: '<S801>/Add1'
                 */
                slewedStepSize = rtb_Add1_k3[i];

                /* Switch: '<S797>/Switch' incorporates:
                 *  Delay: '<S797>/Delay1'
                 */
                rtb_R_re = Model_Target_B.Multiply1_m[i];
            }

            slewedStepSize = fminf(1.0F, qhmath_div_f(1.0F, slewedStepSize +
                                    2.22044605E-16F) * (rtb_R_re *
                                    Model_Target_B.Multiply));
        }

        /* End of Switch: '<S795>/Switch' */

        /* Product: '<S798>/Multiply' incorporates:
         *  Math: '<S756>/Math Function'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         */
        slewedStepSize *= Model_Target_B.MathFunction[i];

        /* Sum: '<S806>/Add1' incorporates:
         *  Delay: '<S806>/Delay'
         *  Delay: '<S806>/Delay1'
         *  Product: '<S806>/Divide'
         *  Product: '<S806>/Multiply'
         *  Product: '<S806>/Multiply1'
         *  Sum: '<S806>/Add'
         */
        Model_Target_B.Multiply1_m[i] = (slewedStepSize +
            Model_Target_DW.Delay_DSTATE_m[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_o[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Product: '<S798>/Multiply' */
        Model_Target_B.Multiply1_e[i] = slewedStepSize;

        /* Sum: '<S807>/Add1' incorporates:
         *  Delay: '<S807>/Delay'
         *  Delay: '<S807>/Delay1'
         *  Math: '<S756>/Math Function'
         *  Product: '<S807>/Multiply'
         *  Product: '<S807>/Multiply1'
         *  Sum: '<S807>/Add'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Add1_i4 = (Model_Target_B.MathFunction[i] +
                       Model_Target_DW.Delay_DSTATE_k[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_l[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Product: '<S798>/Multiply1' incorporates:
         *  Constant: '<S798>/Constant'
         *  Product: '<S798>/Divide'
         *  Sum: '<S798>/Add'
         *  Sum: '<S798>/Subtract'
         *  Sum: '<S806>/Add1'
         */
        rtb_R_re_tmp = qhmath_div_f(Model_Target_B.Multiply1_m[i], rtb_Add1_i4 +
            2.22044605E-16F);
        slewedStepSize = Model_Target_B.Lsr[i].re;
        rtb_R_re = rtb_R_re_tmp * slewedStepSize;
        rtb_R_im_tmp = Model_Target_B.Lsr[i].im;
        rtb_R_re_tmp *= rtb_R_im_tmp;

        /* Sum: '<S798>/Subtract' */
        Model_Target_B.MatrixConcatenate_mb[i + 258].re = slewedStepSize -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 258].im = rtb_R_im_tmp -
            rtb_R_re_tmp;

        /* SignalConversion generated from: '<S751>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_mb[i + 387].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 387].im = rtb_R_re_tmp;

        /* Math: '<S756>/Math Function1' incorporates:
         *  Math: '<S756>/Math Function'
         *  Math: '<S774>/Math Function'
         *  Math: '<S774>/Math Function1'
         *  Selector: '<S753>/Selector'
         *  Selector: '<S753>/Selector1'
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S774>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S774>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_i_0 = &Model_Target_B.Rsr[i];
        Model_Target_B.instCPS[i] = rtb_y_i_0->re * rtb_y_i_0->re +
            rtb_y_i_0->im * rtb_y_i_0->im;

        /* Sum: '<S807>/Add1' */
        rtb_Add1_ma[i] = rtb_Add1_i4;

        /* Sum: '<S810>/Add' incorporates:
         *  Math: '<S756>/Math Function1'
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         */
        slewedStepSize = Model_Target_B.instCPS[i];

        /* Sum: '<S810>/Add1' incorporates:
         *  Delay: '<S810>/Delay'
         *  Delay: '<S810>/Delay1'
         *  Product: '<S810>/Multiply'
         *  Product: '<S810>/Multiply1'
         *  Sum: '<S810>/Add'
         */
        Model_Target_B.Multiply_c[i] = (slewedStepSize +
            Model_Target_DW.Delay_DSTATE_em[i]) * updatedLokRokScaleFactor_tmp +
            Model_Target_DW.Delay1_DSTATE_e[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S811>/Matrix Sum' */
        rtb_Delay_og += slewedStepSize;
    }

    /* Sum: '<S814>/Sum2' incorporates:
     *  Constant: '<S814>/Constant'
     *  Gain: '<S814>/Gain'
     *  Math: '<S814>/log10'
     *  Sum: '<S814>/Sum1'
     *
     * About '<S814>/log10':
     *  Operator: log10
     */
    rtb_Delay_og = qhmath_log10_f(rtb_Delay_og + 2.22044605E-16F) * 10.0F;

    /* MATLAB Function: '<S811>/Detect Impulse' incorporates:
     *  Delay: '<S811>/Delay'
     *  Sum: '<S811>/Add1'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Full-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Right Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S813>:1' */
    /* '<S813>:1:5' if isempty(counter) */
    /* '<S813>:1:6' if isempty(state) */
    /* '<S813>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (rtb_Delay_og - Model_Target_DW.Delay_DSTATE_bj > 0.75F)
    {
        /* '<S813>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S813>:1:10' counter = 0; */
        Model_Target_DW.counter = 0.0;
    }
    else if ((Model_Target_DW.counter <
              Model_Target_MaxValueOfCounterForDetectingImpulse_n) &&
             (Model_Target_DW.state == 1.0))
    {
        /* '<S813>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S813>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_g = 1;

        /* '<S813>:1:13' counter = counter + 1; */
        Model_Target_DW.counter++;
    }
    else
    {
        /* '<S813>:1:14' else */
        /* '<S813>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_g = 0;
    }

    /* '<S813>:1:17' state = isImpulsive; */
    Model_Target_DW.state = rtb_isImpulsive_g;

    /* End of MATLAB Function: '<S811>/Detect Impulse' */

    /* Sum: '<S812>/Add1' incorporates:
     *  Delay: '<S812>/Delay'
     *  Delay: '<S812>/Delay1'
     *  Math: '<S756>/Math Function1'
     *  Product: '<S812>/Multiply'
     *  Product: '<S812>/Multiply1'
     *  Sum: '<S812>/Add'
     *
     * About '<S756>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk[i] = (Model_Target_B.instCPS[i] +
            Model_Target_DW.Delay_DSTATE_eu[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_c[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S812>/Add1' */

    /* Delay: '<S808>/Delay' incorporates:
     *  Sum: '<S810>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&Model_Target_B.Lxks[0], &Model_Target_B.Multiply_c[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec >
            2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                Model_Target_B.Lxks[i] = Model_Target_DW.MedusaDRspumRPxxFast[(i
                    - delayLen) + 2064];
            }
            else
            {
                Model_Target_B.Lxks[i] = Model_Target_B.Multiply_c[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S808>/Delay' */

    /* Delay: '<S808>/Delay1' incorporates:
     *  Sum: '<S812>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&rtb_Rxks[0], &Model_Target_B.Lstrk[0], 129U * sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec >
            2064.0F)
        {
            delayLen = 2064;
        }
        else
        {
            delayLen = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (i = 0; i < 129; i++)
        {
            if ((uint32_T)i < (uint32_T)delayLen)
            {
                rtb_Rxks[i] = Model_Target_DW.MedusaDRspumRPxxSlow[(i - delayLen)
                    + 2064];
            }
            else
            {
                rtb_Rxks[i] = Model_Target_B.Lstrk[i - delayLen];
            }
        }
    }

    /* End of Delay: '<S808>/Delay1' */
    for (i = 0; i < 129; i++)
    {
        /* Switch: '<S796>/Switch' incorporates:
         *  Constant: '<S796>/Constant'
         *  Constant: '<S796>/Constant1'
         *  MinMax: '<S796>/Min'
         *  Product: '<S796>/Divide'
         *  Product: '<S796>/Multiply'
         *  Sum: '<S796>/Add'
         *  Switch: '<S808>/Switch'
         *  Switch: '<S808>/Switch1'
         */
        if (Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumOverwrite != 0.0F)
        {
            slewedStepSize = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_g > 0)
            {
                /* Switch: '<S808>/Switch1' incorporates:
                 *  Sum: '<S810>/Add1'
                 */
                slewedStepSize = Model_Target_B.Multiply_c[i];

                /* Switch: '<S808>/Switch' incorporates:
                 *  Delay: '<S808>/Delay'
                 */
                rtb_R_re = Model_Target_B.Lxks[i];
            }
            else
            {
                /* Switch: '<S808>/Switch1' incorporates:
                 *  Sum: '<S812>/Add1'
                 */
                slewedStepSize = Model_Target_B.Lstrk[i];

                /* Switch: '<S808>/Switch' incorporates:
                 *  Delay: '<S808>/Delay1'
                 */
                rtb_R_re = rtb_Rxks[i];
            }

            slewedStepSize = fminf(1.0F, qhmath_div_f(1.0F, slewedStepSize +
                                    2.22044605E-16F) * (rtb_R_re *
                                    Model_Target_B.Multiply));
        }

        /* Product: '<S809>/Multiply' incorporates:
         *  Math: '<S756>/Math Function1'
         *  Product: '<S809>/Divide'
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         */
        slewedStepSize *= Model_Target_B.instCPS[i];

        /* Switch: '<S796>/Switch' incorporates:
         *  Product: '<S809>/Divide'
         */
        Model_Target_B.Multiply_n[i] = slewedStepSize;

        /* Sum: '<S817>/Add1' incorporates:
         *  Delay: '<S817>/Delay'
         *  Delay: '<S817>/Delay1'
         *  Product: '<S817>/Multiply'
         *  Product: '<S817>/Multiply1'
         *  Sum: '<S817>/Add'
         */
        Model_Target_B.Lxks[i] = (slewedStepSize +
            Model_Target_DW.Delay_DSTATE_np[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_b[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Sum: '<S818>/Add1' incorporates:
         *  Delay: '<S818>/Delay'
         *  Delay: '<S818>/Delay1'
         *  Math: '<S756>/Math Function1'
         *  Product: '<S818>/Multiply'
         *  Product: '<S818>/Multiply1'
         *  Sum: '<S818>/Add'
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         */
        updatedLokRokScaleFactor_tmp = (Model_Target_B.instCPS[i] +
            Model_Target_DW.Delay_DSTATE_e3[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_f[i] *
            Model_Target_PreAmp_p3_b0.MedusaFullRateFdpSpumLsSmoothFactor;

        /* Product: '<S809>/Multiply1' incorporates:
         *  Constant: '<S809>/Constant'
         *  Product: '<S809>/Divide'
         *  Sum: '<S809>/Add'
         *  Sum: '<S809>/Subtract'
         *  Sum: '<S817>/Add1'
         */
        rtb_R_re_tmp = qhmath_div_f(Model_Target_B.Lxks[i],
            updatedLokRokScaleFactor_tmp + 2.22044605E-16F);
        slewedStepSize = Model_Target_B.Rsr[i].re;
        rtb_R_re = rtb_R_re_tmp * slewedStepSize;
        rtb_R_im_tmp = Model_Target_B.Rsr[i].im;
        rtb_R_re_tmp *= rtb_R_im_tmp;

        /* Sum: '<S809>/Subtract' */
        Model_Target_B.MatrixConcatenate_mb[i + 516].re = slewedStepSize -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 516].im = rtb_R_im_tmp -
            rtb_R_re_tmp;

        /* SignalConversion generated from: '<S751>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_mb[i + 645].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_mb[i + 645].im = rtb_R_re_tmp;

        /* Sum: '<S818>/Add1' */
        rtb_Rxks[i] = updatedLokRokScaleFactor_tmp;
    }

    /* MATLAB Function: '<S821>/MATLAB Function' incorporates:
     *  Concatenate: '<S751>/Matrix Concatenate'
     *  Constant: '<S752>/Constant'
     */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function': '<S823>:1' */
    /* '<S823>:1:7' [~, numChannels] = size(u); */
    /* '<S823>:1:8' outputSize = fftSize - numOverlap; */
    /*  Buffer to hold overlapped samples */
    /* '<S823>:1:12' if isempty(outputOverlap) */
    /*  Buffer for Simulation  */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S823>:1:20' y = coder.nullcopy(single(zeros(outputSize, numChannels))); */
    /*  Simulation */
    /* '<S823>:1:23' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S823>:1:33' else */
    /* '<S823>:1:34' y = rifft_process(   single(complex(u)), ... */
    /* '<S823>:1:35'                         single(Twiddle1),... */
    /* '<S823>:1:36'                         single(Twiddle2),...  */
    /* '<S823>:1:37'                         single(RifftOutputTmp),... */
    /* '<S823>:1:38'                         single(win),... */
    /* '<S823>:1:39'                         outputOverlap,... */
    /* '<S823>:1:40'                         int32(fftSize),... */
    /* '<S823>:1:41'                         int32(numChannels),... */
    /* '<S823>:1:42'                         int32(numOverlap)); */
    rifft_process(&Model_Target_B.y_e[0], &Model_Target_B.MatrixConcatenate_mb[0],
                  &MedusaFdpFullRateRifftRifftBufferTwiddle1[0],
                  &MedusaFdpFullRateRifftRifftBufferTwiddle2[0],
                  &MedusaFdpFullRateRifftRifftBufferRifftOutputTmp[0],
                  &Model_Target_ConstP.pooled74[0],
                  &Model_Target_DW.outputOverlap[0], 256, 6, 128);

    /* Buffer: '<S648>/BufferOut' */
    currentOffset = 0;
    for (row = 0; row < 6; row++)
    {
        delayLen = 128;
        rtb_isImpulsive_g = row << 8;
        memIdx = rtb_isImpulsive_g + Model_Target_DW.BufferOut_inBufPtrIdx_a;
        if (Model_Target_DW.BufferOut_inBufPtrIdx_a > 128)
        {
            for (i = 0; i < 256 - Model_Target_DW.BufferOut_inBufPtrIdx_a; i++)
            {
                Model_Target_DW.BufferOut_CircBuf_j[memIdx + i] =
                    Model_Target_B.y_e[currentOffset + i];
            }

            currentOffset = (currentOffset -
                             Model_Target_DW.BufferOut_inBufPtrIdx_a) + 256;
            memIdx = rtb_isImpulsive_g;
            delayLen = Model_Target_DW.BufferOut_inBufPtrIdx_a - 128;
        }

        for (i = 0; i < delayLen; i++)
        {
            Model_Target_DW.BufferOut_CircBuf_j[memIdx + i] =
                Model_Target_B.y_e[currentOffset + i];
        }

        currentOffset += delayLen;
    }

    Model_Target_DW.BufferOut_inBufPtrIdx_a += 128;
    if (Model_Target_DW.BufferOut_inBufPtrIdx_a >= 256)
    {
        Model_Target_DW.BufferOut_inBufPtrIdx_a -= 256;
    }

    /* End of Buffer: '<S648>/BufferOut' */
    /* Update for Delay: '<S800>/Delay' */
    Model_Target_DW.Delay_DSTATE_nb = updatedLokRokScaleFactor;

    /* Update for Delay: '<S799>/Delay' incorporates:
     *  Math: '<S756>/Math Function'
     *
     * About '<S756>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_i[0], &Model_Target_B.MathFunction[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S799>/Delay1' incorporates:
     *  Sum: '<S799>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE[0], &Model_Target_B.Lin2[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S801>/Delay' incorporates:
     *  Math: '<S756>/Math Function'
     *
     * About '<S756>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_l[0], &Model_Target_B.MathFunction[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S801>/Delay1' incorporates:
     *  Sum: '<S801>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_a[0], &rtb_Add1_k3[0], 129U * sizeof
           (real32_T));

    /* Update for Delay: '<S797>/Delay' incorporates:
     *  Sum: '<S799>/Add1'
     */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumLPxxFast[i] =
            Model_Target_DW.MedusaDRspumLPxxFast[i + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumLPxxFast[1935], &Model_Target_B.Lin2[0],
           129U * sizeof(real32_T));

    /* End of Update for Delay: '<S797>/Delay' */

    /* Update for Delay: '<S797>/Delay1' */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumLPxxSlow[i] =
            Model_Target_DW.MedusaDRspumLPxxSlow[i + 129];
    }

    /* Update for Delay: '<S862>/Delay' */
    Model_Target_DW.Delay_DSTATE_i3 = rtb_Sumhighfrequencyenergy;

    /* Update for Delay: '<S862>/Delay1' */
    Model_Target_DW.Delay1_DSTATE_p = minXp;

    /* Update for Delay: '<S811>/Delay' */
    Model_Target_DW.Delay_DSTATE_bj = rtb_Delay_og;
    for (i = 0; i < 129; i++)
    {
        /* Update for Delay: '<S810>/Delay' incorporates:
         *  Math: '<S756>/Math Function1'
         *
         * About '<S756>/Math Function1':
         *  Operator: magnitude^2
         */
        slewedStepSize = Model_Target_B.instCPS[i];

        /* Update for Delay: '<S797>/Delay1' incorporates:
         *  Sum: '<S801>/Add1'
         */
        Model_Target_DW.MedusaDRspumLPxxSlow[i + 1935] = rtb_Add1_k3[i];

        /* Update for Delay: '<S806>/Delay' incorporates:
         *  Product: '<S798>/Multiply'
         */
        Model_Target_DW.Delay_DSTATE_m[i] = Model_Target_B.Multiply1_e[i];

        /* Update for Delay: '<S806>/Delay1' incorporates:
         *  Sum: '<S806>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_o[i] = Model_Target_B.Multiply1_m[i];

        /* Update for Delay: '<S807>/Delay' incorporates:
         *  Math: '<S756>/Math Function'
         *
         * About '<S756>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_DW.Delay_DSTATE_k[i] = Model_Target_B.MathFunction[i];

        /* Update for Delay: '<S807>/Delay1' incorporates:
         *  Sum: '<S807>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_l[i] = rtb_Add1_ma[i];

        /* Update for Delay: '<S810>/Delay' */
        Model_Target_DW.Delay_DSTATE_em[i] = slewedStepSize;

        /* Update for Delay: '<S810>/Delay1' incorporates:
         *  Sum: '<S810>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_e[i] = Model_Target_B.Multiply_c[i];

        /* Update for Delay: '<S812>/Delay' */
        Model_Target_DW.Delay_DSTATE_eu[i] = slewedStepSize;

        /* Update for Delay: '<S812>/Delay1' incorporates:
         *  Sum: '<S812>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_c[i] = Model_Target_B.Lstrk[i];
    }

    /* Update for Delay: '<S808>/Delay' incorporates:
     *  Sum: '<S810>/Add1'
     */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumRPxxFast[i] =
            Model_Target_DW.MedusaDRspumRPxxFast[i + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxFast[1935],
           &Model_Target_B.Multiply_c[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S808>/Delay' */

    /* Update for Delay: '<S808>/Delay1' incorporates:
     *  Sum: '<S812>/Add1'
     */
    for (i = 0; i < 1935; i++)
    {
        Model_Target_DW.MedusaDRspumRPxxSlow[i] =
            Model_Target_DW.MedusaDRspumRPxxSlow[i + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxSlow[1935], &Model_Target_B.Lstrk[0],
           129U * sizeof(real32_T));

    /* End of Update for Delay: '<S808>/Delay1' */

    /* Update for Delay: '<S817>/Delay' incorporates:
     *  Product: '<S809>/Multiply'
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_np[0], &Model_Target_B.Multiply_n[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S817>/Delay1' incorporates:
     *  Sum: '<S817>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_b[0], &Model_Target_B.Lxks[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S818>/Delay' incorporates:
     *  Math: '<S756>/Math Function1'
     *
     * About '<S756>/Math Function1':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_e3[0], &Model_Target_B.instCPS[0], 129U
           * sizeof(real32_T));

    /* Update for Delay: '<S818>/Delay1' incorporates:
     *  Sum: '<S818>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_f[0], &rtb_Rxks[0], 129U * sizeof
           (real32_T));
}

/* Output and update for atomic system: '<S558>/Medusa5H1 Part 2' */
void Model_Target_Medusa5H1Part2TID5(void)
{
    int32_T MedusaFdpDeciRateRfftRfftInput_tmp;
    int32_T i;
    int32_T memIdx;
    int32_T rtb_isImpulsive_c;
    real32_T rtb_Add1_gg[129];
    real32_T rtb_MathFunction1_e[129];
    real32_T rtb_Rxks[129];
    real32_T Lx_im;
    real32_T maxXp;
    real32_T minXp;
    real32_T minXp_tmp;
    real32_T rtb_Add1_e3;
    real32_T rtb_R_f_im_tmp;
    real32_T rtb_R_f_re_tmp;
    real32_T rtb_R_f_re_tmp_0;
    real32_T rtb_R_re;
    real32_T updatedLokRokScaleFactor;
    static const real32_T b[128] =
    {
        0.0F, 0.0122715384F, 0.024541229F, 0.0368072242F, 0.0490676761F,
        0.061320737F, 0.0735645667F, 0.0857973099F, 0.0980171412F, 0.110222206F,
        0.122410677F, 0.134580702F, 0.146730468F, 0.15885815F, 0.170961887F,
        0.183039889F, 0.195090324F, 0.207111374F, 0.219101235F, 0.231058106F,
        0.242980182F, 0.254865646F, 0.266712755F, 0.27851969F, 0.290284663F,
        0.302005947F, 0.313681751F, 0.32531029F, 0.336889863F, 0.348418683F,
        0.359895051F, 0.371317208F, 0.382683426F, 0.393992037F, 0.405241311F,
        0.416429549F, 0.427555084F, 0.438616246F, 0.449611336F, 0.460538715F,
        0.471396744F, 0.482183784F, 0.492898196F, 0.50353837F, 0.514102757F,
        0.524589658F, 0.534997642F, 0.545325F, 0.555570245F, 0.565731823F,
        0.575808167F, 0.585797846F, 0.59569931F, 0.605511069F, 0.615231574F,
        0.624859512F, 0.634393275F, 0.643831551F, 0.653172851F, 0.662415802F,
        0.671559F, 0.680601F, 0.689540565F, 0.698376238F, 0.707106769F,
        0.715730846F, 0.724247098F, 0.732654274F, 0.740951121F, 0.749136388F,
        0.757208824F, 0.765167236F, 0.773010433F, 0.780737221F, 0.78834641F,
        0.795836926F, 0.803207517F, 0.81045717F, 0.817584813F, 0.824589312F,
        0.831469595F, 0.838224709F, 0.84485358F, 0.851355195F, 0.857728601F,
        0.863972843F, 0.870086968F, 0.876070082F, 0.881921291F, 0.887639642F,
        0.893224299F, 0.898674488F, 0.903989315F, 0.909168F, 0.914209783F,
        0.919113874F, 0.923879504F, 0.928506076F, 0.932992816F, 0.937339F,
        0.941544056F, 0.945607305F, 0.949528158F, 0.953306F, 0.956940353F,
        0.960430503F, 0.963776052F, 0.966976464F, 0.970031261F, 0.972939968F,
        0.975702107F, 0.97831738F, 0.980785251F, 0.983105481F, 0.985277653F,
        0.987301409F, 0.989176512F, 0.990902662F, 0.992479563F, 0.993907F,
        0.99518472F, 0.996312618F, 0.997290432F, 0.998118103F, 0.99879545F,
        0.999322355F, 0.999698818F, 0.999924719F
    };

    static const real32_T c[128] =
    {
        1.0F, 0.999924719F, 0.999698818F, 0.999322355F, 0.99879545F,
        0.998118103F, 0.997290432F, 0.996312618F, 0.99518472F, 0.993907F,
        0.992479563F, 0.990902662F, 0.989176512F, 0.987301409F, 0.985277653F,
        0.983105481F, 0.980785251F, 0.97831738F, 0.975702107F, 0.972939968F,
        0.970031261F, 0.966976464F, 0.963776052F, 0.960430503F, 0.956940353F,
        0.953306F, 0.949528158F, 0.945607305F, 0.941544056F, 0.937339F,
        0.932992816F, 0.928506076F, 0.923879504F, 0.919113874F, 0.914209783F,
        0.909168F, 0.903989315F, 0.898674488F, 0.893224299F, 0.887639642F,
        0.881921291F, 0.876070082F, 0.870086968F, 0.863972843F, 0.857728601F,
        0.851355195F, 0.84485358F, 0.838224709F, 0.831469595F, 0.824589312F,
        0.817584813F, 0.81045717F, 0.803207517F, 0.795836926F, 0.78834641F,
        0.780737221F, 0.773010433F, 0.765167236F, 0.757208824F, 0.749136388F,
        0.740951121F, 0.732654274F, 0.724247098F, 0.715730846F, 0.707106769F,
        0.698376238F, 0.689540565F, 0.680601F, 0.671559F, 0.662415802F,
        0.653172851F, 0.643831551F, 0.634393275F, 0.624859512F, 0.615231574F,
        0.605511069F, 0.59569931F, 0.585797846F, 0.575808167F, 0.565731823F,
        0.555570245F, 0.545325F, 0.534997642F, 0.524589658F, 0.514102757F,
        0.50353837F, 0.492898196F, 0.482183784F, 0.471396744F, 0.460538715F,
        0.449611336F, 0.438616246F, 0.427555084F, 0.416429549F, 0.405241311F,
        0.393992037F, 0.382683426F, 0.371317208F, 0.359895051F, 0.348418683F,
        0.336889863F, 0.32531029F, 0.313681751F, 0.302005947F, 0.290284663F,
        0.27851969F, 0.266712755F, 0.254865646F, 0.242980182F, 0.231058106F,
        0.219101235F, 0.207111374F, 0.195090324F, 0.183039889F, 0.170961887F,
        0.15885815F, 0.146730468F, 0.134580702F, 0.122410677F, 0.110222206F,
        0.0980171412F, 0.0857973099F, 0.0735645667F, 0.061320737F, 0.0490676761F,
        0.0368072242F, 0.024541229F, 0.0122715384F
    };

    creal32_T *rtb_y_o_0;

    /* Buffer: '<S647>/BufferIn' */
    rtb_isImpulsive_c = 0;
    for (i = 0; i < 2; i++)
    {
        memIdx = (i << 8) + Model_Target_DW.BufferIn_outBufPtrIdx;
        memcpy(&Model_Target_B.BufferIn_f[rtb_isImpulsive_c],
               &Model_Target_DW.BufferIn_CircBuf[memIdx], sizeof(real32_T) << 7U);
        rtb_isImpulsive_c += 128;
        MedusaFdpDeciRateRfftRfftInput_tmp =
            Model_Target_DW.BufferIn_outBufPtrIdx + 128;
    }

    if (MedusaFdpDeciRateRfftRfftInput_tmp == 256)
    {
        MedusaFdpDeciRateRfftRfftInput_tmp = 0;
    }

    Model_Target_DW.BufferIn_outBufPtrIdx = MedusaFdpDeciRateRfftRfftInput_tmp;

    /* End of Buffer: '<S647>/BufferIn' */

    /* MATLAB Function: '<S657>/Windowing' incorporates:
     *  Buffer: '<S647>/BufferIn'
     */
    /*  Get sizes */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/ShortTimeFourierTransform/Windowing': '<S743>:1' */
    /* '<S743>:1:4' [~, NumChannels] = size(AudioIn); */
    /* '<S743>:1:5' HopSize = FftSize - Overlap; */
    /* '<S743>:1:8' if isempty(InputOverlap) */
    /* '<S743>:1:12' AudioOut = [InputOverlap.*Window(1:Overlap); AudioIn.*Window((HopSize + 1):end)]; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 2; rtb_isImpulsive_c++)
    {
        for (i = 0; i < 128; i++)
        {
            MedusaFdpDeciRateRfftRfftInput_tmp = (rtb_isImpulsive_c << 7) + i;
            memIdx = (rtb_isImpulsive_c << 8) + i;
            MedusaFdpDeciRateRfftRfftInput[memIdx] =
                Model_Target_DW.InputOverlap_d[MedusaFdpDeciRateRfftRfftInput_tmp]
                * b[i];
            MedusaFdpDeciRateRfftRfftInput[memIdx + 128] =
                Model_Target_B.BufferIn_f[MedusaFdpDeciRateRfftRfftInput_tmp] *
                c[i];
        }
    }

    /*  Update overlapping samples */
    /* '<S743>:1:15' InputOverlap = AudioIn; */
    memcpy(&Model_Target_DW.InputOverlap_d[0], &Model_Target_B.BufferIn_f[0],
           sizeof(real32_T) << 8U);

    /* End of MATLAB Function: '<S657>/Windowing' */

    /* MATLAB Function: '<S745>/MATLAB Function1' */
    /*  Computes the Real FFT of a Multi-Channel Signal.  */
    /*  During Code Generation, hexagon rfft crl function is used. */
    /*  Inputs: */
    /*      u - purely real signal.  */
    /*          size = [fftSize, numChannels] */
    /*      fftSize - size of each input channel. Also the size of FFT */
    /*  Outputs: */
    /*      y - fftSize/2 + 1 unique FFT coefficients of each channel of u. */
    /*          size = [fftSize/2 + 1, numChannels] */
    /*  ------------------------------------------------------------------------- */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function1': '<S748>:1' */
    /* '<S748>:1:17' numChannels = size(u, 2); */
    /* '<S748>:1:18' spectrumSize = (fftSize/2) + 1; */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S748>:1:21' y = coder.nullcopy(complex(single(zeros(spectrumSize, numChannels)))); */
    /*  Simulation */
    /* '<S748>:1:24' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S748>:1:27' else */
    /* '<S748>:1:28' y = rfft_process(single(u), Twiddle1, Twiddle2, RfftOutputTmp, int32(fftSize), int32(numChannels)); */
    rfft_process(&Model_Target_B.y_o[0], &MedusaFdpDeciRateRfftRfftInput[0],
                 &MedusaFdpDeciRateRfftRfftBufferTwiddle1[0],
                 &MedusaFdpDeciRateRfftRfftBufferTwiddle2[0],
                 &MedusaFdpDeciRateRfftRfftBufferRfftOutputTmp[0], 256, 2);

    /* Math: '<S690>/Math Function'
     *
     * About '<S690>/Math Function':
     *  Operator: magnitude^2
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        /* Selector: '<S657>/Selector' incorporates:
         *  Math: '<S660>/Math Function'
         *  Math: '<S660>/Math Function1'
         *  Math: '<S690>/Math Function1'
         *  Selector: '<S657>/Selector1'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S690>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.y_o[rtb_isImpulsive_c];
        Model_Target_B.Lin2_a[rtb_isImpulsive_c] = rtb_y_o_0->re * rtb_y_o_0->re
            + rtb_y_o_0->im * rtb_y_o_0->im;
    }

    /* MATLAB Function: '<S663>/Coeffs 1st Stage' incorporates:
     *  Selector: '<S657>/Selector'
     *  Selector: '<S657>/Selector1'
     */
    Model_Target_Coeffs1stStage(&Model_Target_B.y_o[0], &Model_Target_B.y_o[129],
        &Model_Target_B.sf_Coeffs1stStage);

    /* MATLAB Function: '<S666>/MATLAB Function' incorporates:
     *  Math: '<S690>/Math Function'
     *  Product: '<S705>/Multiply'
     *
     * About '<S690>/Math Function':
     *  Operator: magnitude^2
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Instantaneous Stretch Coeffs /MATLAB Function': '<S672>:1' */
    /* '<S672>:1:6' coder.inline('always'); */
    /* '<S672>:1:7' epsf = single(eps); */
    /*  Step 1: Compute the estimated stretch coefficients or worst-case estimate */
    /*  based on maximum allowable stretching Xpmax */
    /* '<S672>:1:11' Lstrk = min(Lxk, LokRokMaxScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] =
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsLokRokMaxScaleFactor
            * Model_Target_B.sf_Coeffs1stStage.Lok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = fminf
            (Model_Target_B.sf_Coeffs1stStage.Lxk[i],
             Model_Target_B.Multiply_a[i]);
    }

    /* '<S672>:1:12' Rstrk = min(Rxk, LokRokMaxScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] =
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsLokRokMaxScaleFactor
            * Model_Target_B.sf_Coeffs1stStage.Rok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = fminf(Model_Target_B.sf_Coeffs1stStage.Rxk[i],
            Model_Target_B.Multiply_a[i]);
    }

    /*  Step 2: Compute Excessive Stretch Detector (ESD) - used to update Xp */
    /*  */
    /*                    sum_over_FFT_bins( Lstrki * |Lin|) + sum_over_FFT_bins( Rstrki * |Rin|)   */
    /*  ESD = abs( db20 ( ----------------------------------------------------------------------- ) ) */
    /*                                      sum_over_FFT_bins( Lxki * |Lin| ) */
    /*  */
    /*  since Lxki * |Lin| = min (|Lin|,|Rin|) (per bin), we store the minima  */
    /*  beforehand and use it here */
    /*  Note the matrix shorthand for sum_over_FFT_bins(Lstrki * Lin) is Lstrk' * p.absLi */
    /*  A small positive value is added to the numerator, to avoid db20(0) */
    /* '<S672>:1:25' ESDdB = db20( (epsf + Lstrk(:)' * absLi(:) + Rstrk(:)' * absRi(:)) ... */
    /* '<S672>:1:26'             / (epsf + sum(minAbsLiRi)) ); */
    updatedLokRokScaleFactor = Model_Target_B.sf_Coeffs1stStage.minAbsLiRi[0];
    for (i = 0; i < 128; i++)
    {
        updatedLokRokScaleFactor +=
            Model_Target_B.sf_Coeffs1stStage.minAbsLiRi[i + 1];
    }

    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: db20.m 11813 2012-07-11 17:31:25Z rs7109 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    minXp = 0.0F;
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        minXp += Model_Target_B.Multiply_bg[rtb_isImpulsive_c] *
            Model_Target_B.sf_Coeffs1stStage.absLi[rtb_isImpulsive_c];
    }

    maxXp = 0.0F;
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        maxXp += Model_Target_B.Lstrk_k[rtb_isImpulsive_c] *
            Model_Target_B.sf_Coeffs1stStage.absRi[rtb_isImpulsive_c];
    }

    updatedLokRokScaleFactor = qhmath_log_f(qhmath_abs_f(qhmath_div_f((minXp +
        2.22044605E-16F) + maxXp, updatedLokRokScaleFactor + 2.22044605E-16F))) *
        8.68588924F;

    /*  "Turn off" stretching by setting minXp and maxXp to zero,  */
    /*  if CAE_enable is zero. */
    /* '<S672>:1:30' if (CAE_enable == 0) */
    if (Model_Target_B.Constant3 == 0)
    {
        /* '<S672>:1:31' minXp = single(0.0); */
        minXp = 0.0F;

        /* '<S672>:1:32' maxXp = single(0.0); */
        maxXp = 0.0F;
    }
    else
    {
        /* '<S672>:1:33' else */
        /* '<S672>:1:34' minXp = Xpmin; */
        minXp = Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsXpMin;

        /* '<S672>:1:35' maxXp = Xpmax; */
        maxXp = Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsXpMax;
    }

    /*  Calculate new stretch factor, Xp, based on ESD value. */
    /*  The following curve is applied: */
    /*         Xp */
    /*         ^ */
    /*         | */
    /*   maxXp +----------. */
    /*         |          .\ */
    /*         |          . \ */
    /*         |          .  \ */
    /*         |          .   \ */
    /*         |          .    \ */
    /*         |          .     \ */
    /*   minXp +          .      --------------- minXp */
    /*         |          .      . */
    /*         +----------+------+-------------> ESD (dB) */
    /*        0           |      | */
    /*                    |     ESD_upper_bound_in_dB - thresh2 */
    /*                    | */
    /*                   ESD_lower_bound_in_dB - thresh1 */
    /* '<S672>:1:58' if (ESDdB < ESDLowerBound) */
    if (updatedLokRokScaleFactor <
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsESDLowerbounddB)
    {
        /*  Stretching is lower than the lower threshold, use largest allowable Xp. */
        /* '<S672>:1:60' Xp = maxXp; */
        minXp = maxXp;
    }
    else if (updatedLokRokScaleFactor <=
             Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsESDUpperbounddB)
    {
        /* '<S672>:1:64' else */
        /*  Stretching in between, compute Xp as a linear interpolation between  */
        /*  max and min based on the two thresholds */
        /* '<S672>:1:67' Xp = minXp + (maxXp - minXp) * ESDStepSize * (ESDUpperBound - ESDdB); */
        minXp += (maxXp - minXp) *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsESDStepSize *
            (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpCoeffsESDUpperbounddB -
             updatedLokRokScaleFactor);
    }
    else
    {
        /* '<S672>:1:61' elseif (ESDdB > ESDUpperBound) */
        /*  Stretching is higher than the upper threshold, use smallest allowable Xp. */
        /* '<S672>:1:63' Xp = minXp; */
    }

    /*  Step 3: Compute updated instantaneous stretch coefficients */
    /* '<S672>:1:71' updatedLokRokScaleFactor = 0.5 * (Xp/(1-Xp+epsf)); */
    updatedLokRokScaleFactor = qhmath_div_f(minXp, (1.0F - minXp) +
        2.22044605E-16F) * 0.5F;

    /*  Calculate instanstaneous Center Selectivity coefficients based on SPS */
    /* '<S672>:1:74' instCPS = 1 - SPS; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS_c[i] = 1.0F -
            Model_Target_B.sf_Coeffs1stStage.SPS[i];
    }

    /* '<S672>:1:75' Lck = instCPS .* Lxk; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = Model_Target_B.instCPS_c[i] *
            Model_Target_B.sf_Coeffs1stStage.Lxk[i];
    }

    /* '<S672>:1:76' Rck = instCPS .* Rxk; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.instCPS_c[rtb_isImpulsive_c] *=
            Model_Target_B.sf_Coeffs1stStage.Rxk[rtb_isImpulsive_c];
    }

    /*  Use the updated value of Xp to calculate stretch coefficients */
    /* '<S672>:1:79' Lstrk = min(Lck, updatedLokRokScaleFactor * Lok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage.Lok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = fminf(Model_Target_B.Lstrk_k[i],
            Model_Target_B.Multiply_a[i]);
    }

    /* '<S672>:1:80' Rstrk = min(Rck, updatedLokRokScaleFactor * Rok); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = updatedLokRokScaleFactor *
            Model_Target_B.sf_Coeffs1stStage.Rok[i];
    }

    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = fminf(Model_Target_B.instCPS_c[i],
            Model_Target_B.Multiply_a[i]);
        Model_Target_B.Lstrk_k[i] *= Model_Target_B.Lin2_a[i];
    }

    /* MATLAB Function: '<S707>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lstrk_k, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_kd,
        &Model_Target_DW.sf_MATLABFunction_kd);

    /* MATLAB Function: '<S691>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2_a, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_jh,
        &Model_Target_DW.sf_MATLABFunction_jh);

    /* Math: '<S690>/Math Function2' incorporates:
     *  Constant: '<S690>/Constant1'
     *  Sum: '<S690>/Add'
     *
     * About '<S690>/Math Function2':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS_c[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_jh.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S690>/Math Function2' */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        /* Math: '<S690>/Math Function1' incorporates:
         *  Math: '<S660>/Math Function'
         *  Math: '<S660>/Math Function1'
         *  Math: '<S690>/Math Function'
         *  Selector: '<S657>/Selector'
         *  Selector: '<S657>/Selector1'
         *
         * About '<S690>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S690>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.y_o[rtb_isImpulsive_c + 129];
        maxXp = rtb_y_o_0->re * rtb_y_o_0->re + rtb_y_o_0->im * rtb_y_o_0->im;

        /* Product: '<S706>/Multiply' incorporates:
         *  MATLAB Function: '<S666>/MATLAB Function'
         *  Math: '<S690>/Math Function1'
         *
         * About '<S690>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Multiply_a[rtb_isImpulsive_c] = maxXp *
            Model_Target_B.Multiply_bg[rtb_isImpulsive_c];

        /* Math: '<S690>/Math Function1'
         *
         * About '<S690>/Math Function1':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lstrk_k[rtb_isImpulsive_c] = maxXp;
    }

    /* MATLAB Function: '<S709>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Multiply_a, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_g,
        &Model_Target_DW.sf_MATLABFunction_g);

    /* MATLAB Function: '<S692>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lstrk_k, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_a,
        &Model_Target_DW.sf_MATLABFunction_a);

    /* Math: '<S690>/Math Function3' incorporates:
     *  Constant: '<S690>/Constant2'
     *  Product: '<S725>/Divide'
     *  Sum: '<S690>/Add1'
     *
     * About '<S690>/Math Function3':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_a.y[i] + 2.22044605E-16F);
    }

    /* End of Math: '<S690>/Math Function3' */

    /* Product: '<S673>/Multiply' incorporates:
     *  Math: '<S690>/Math Function'
     *
     * About '<S690>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = Model_Target_B.Lin2_a[i] *
            Model_Target_B.sf_Coeffs1stStage.Lok[i];
    }

    /* End of Product: '<S673>/Multiply' */

    /* MATLAB Function: '<S675>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Multiply_bg, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_n,
        &Model_Target_DW.sf_MATLABFunction_n);

    /* Product: '<S673>/Multiply1' incorporates:
     *  Math: '<S690>/Math Function2'
     *
     * About '<S690>/Math Function2':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_o[i] = Model_Target_B.sf_MATLABFunction_n.y[i] *
            Model_Target_B.instCPS_c[i];
    }

    /* End of Product: '<S673>/Multiply1' */

    /* Product: '<S674>/Multiply' incorporates:
     *  Math: '<S690>/Math Function1'
     *
     * About '<S690>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = Model_Target_B.Lstrk_k[i] *
            Model_Target_B.sf_Coeffs1stStage.Rok[i];
    }

    /* End of Product: '<S674>/Multiply' */

    /* MATLAB Function: '<S677>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Multiply_bg, 0.90993F,
        0.0450350046F, &Model_Target_B.sf_MATLABFunction_e,
        &Model_Target_DW.sf_MATLABFunction_e);

    /* Product: '<S674>/Multiply1' incorporates:
     *  Product: '<S725>/Divide'
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply1_a[i] = Model_Target_B.sf_MATLABFunction_e.y[i] *
            Model_Target_B.Multiply_a[i];
    }

    /* End of Product: '<S674>/Multiply1' */

    /* MATLAB Function: '<S663>/Coeffs 2nd Stage' incorporates:
     *  Product: '<S673>/Multiply1'
     *  Product: '<S674>/Multiply1'
     */
    /*  Update mono coeffs after smoothing far left/right coeffs */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Coeffs 2nd Stage': '<S665>:1' */
    /*  Left only/right only coefficients */
    /* '<S665>:1:5' Lxks = 1 - Loks; */
    /* '<S665>:1:6' Rxks = 1 - Roks; */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lxks_j[i] = 1.0F - Model_Target_B.Multiply1_o[i];
        rtb_Rxks[i] = 1.0F - Model_Target_B.Multiply1_a[i];
    }

    /* End of MATLAB Function: '<S663>/Coeffs 2nd Stage' */

    /* MATLAB Function: '<S671>/Normalize Stretch Coeffs' incorporates:
     *  Math: '<S690>/Math Function'
     *  Math: '<S690>/Math Function2'
     *  Product: '<S699>/Multiply'
     *  Product: '<S705>/Multiply1'
     *  Product: '<S706>/Multiply1'
     *  Product: '<S725>/Divide'
     *
     * About '<S690>/Math Function':
     *  Operator: magnitude^2
     *
     * About '<S690>/Math Function2':
     *  Operator: reciprocal
     */
    /*  Normalize stretch coefficients against mono portion  */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Updated Stretch Coeffs and Steering Coeffs/Normalize Stretch Coeffs': '<S695>:1' */
    /*  Take only difference of L&R strecth coeffs as the total stretch  */
    /* '<S695>:1:6' netStretch = (Lstrks .* absLi) - (Rstrks.* absRi); */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_bg[i] = Model_Target_B.sf_MATLABFunction_kd.y[i]
            * Model_Target_B.instCPS_c[i] *
            Model_Target_B.sf_Coeffs1stStage.absLi[i] -
            Model_Target_B.sf_MATLABFunction_g.y[i] *
            Model_Target_B.Multiply_a[i] *
            Model_Target_B.sf_Coeffs1stStage.absRi[i];
    }

    /*  Normalize by the smoothed total shared level  */
    /* '<S695>:1:9' epsf = single(eps); */
    /* '<S695>:1:10' LxSmth = (Lxks .* absLi) + epsf; */
    /* '<S695>:1:11' RxSmth = (Rxks .* absRi) + epsf; */
    /* '<S695>:1:13' Lstrki = max(0.0, netStretch) ./ LxSmth; */
    for (i = 0; i < 129; i++)
    {
        rtb_Add1_gg[i] = fmaxf(0.0F, Model_Target_B.Multiply_bg[i]);
    }

    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_Add1_gg[rtb_isImpulsive_c] = qhmath_div_f
            (rtb_Add1_gg[rtb_isImpulsive_c],
             Model_Target_B.Lxks_j[rtb_isImpulsive_c] *
             Model_Target_B.sf_Coeffs1stStage.absLi[rtb_isImpulsive_c] +
             2.22044605E-16F);
    }

    /* '<S695>:1:14' Rstrki = max(0.0, (-netStretch)) ./ RxSmth; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Multiply_bg[rtb_isImpulsive_c];
        rtb_MathFunction1_e[rtb_isImpulsive_c] = fmaxf(0.0F,
            -updatedLokRokScaleFactor);
        Model_Target_B.Multiply_bg[rtb_isImpulsive_c] =
            -updatedLokRokScaleFactor;
    }

    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_MathFunction1_e[rtb_isImpulsive_c] = qhmath_div_f
            (rtb_MathFunction1_e[rtb_isImpulsive_c], rtb_Rxks[rtb_isImpulsive_c]
             * Model_Target_B.sf_Coeffs1stStage.absRi[rtb_isImpulsive_c] +
             2.22044605E-16F);
    }

    /*  Bound the stretch coefficients within [0,1] */
    /* '<S695>:1:17' Lstrki = min(1.0, max(0.0, Lstrki)); */
    /* '<S695>:1:18' Rstrki = min(1.0, max(0.0, Rstrki)); */
    for (i = 0; i < 129; i++)
    {
        updatedLokRokScaleFactor = fminf(1.0F, fmaxf(0.0F, rtb_Add1_gg[i]));
        rtb_Add1_e3 = fmaxf(0.0F, rtb_MathFunction1_e[i]);
        Model_Target_B.Multiply_bg[i] = fminf(1.0F, rtb_Add1_e3);
        rtb_Add1_gg[i] = rtb_Add1_e3;
        Model_Target_B.Lin2_a[i] *= updatedLokRokScaleFactor;
    }

    /* MATLAB Function: '<S701>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2_a, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_k,
        &Model_Target_DW.sf_MATLABFunction_k);

    /* Product: '<S699>/Multiply1' incorporates:
     *  Math: '<S690>/Math Function2'
     *
     * About '<S690>/Math Function2':
     *  Operator: reciprocal
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.instCPS_c[rtb_isImpulsive_c] *=
            Model_Target_B.sf_MATLABFunction_k.y[rtb_isImpulsive_c];
    }

    /* End of Product: '<S699>/Multiply1' */

    /* Product: '<S700>/Multiply' incorporates:
     *  MATLAB Function: '<S671>/Normalize Stretch Coeffs'
     *  Math: '<S690>/Math Function1'
     *
     * About '<S690>/Math Function1':
     *  Operator: magnitude^2
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Lstrk_k[rtb_isImpulsive_c] *=
            Model_Target_B.Multiply_bg[rtb_isImpulsive_c];
    }

    /* End of Product: '<S700>/Multiply' */

    /* MATLAB Function: '<S703>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain1'
     *  Constant: '<S669>/lsPole1'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lstrk_k, 0.90993F, 0.0450350046F,
        &Model_Target_B.sf_MATLABFunction_b,
        &Model_Target_DW.sf_MATLABFunction_b);

    /* Product: '<S700>/Multiply1' incorporates:
     *  Product: '<S725>/Divide'
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Multiply_a[rtb_isImpulsive_c] *=
            Model_Target_B.sf_MATLABFunction_b.y[rtb_isImpulsive_c];
    }

    /* End of Product: '<S700>/Multiply1' */

    /* MATLAB Function: '<S671>/Update Steering Coeffs' */
    Model_Target_UpdateSteeringCoeffs(Model_Target_B.instCPS_c,
        Model_Target_B.Multiply_a, Model_Target_B.Multiply1_o,
        Model_Target_B.Multiply1_a, Model_Target_B.Lxks_j, rtb_Rxks,
        &Model_Target_B.sf_UpdateSteeringCoeffs);

    /* Product: '<S679>/|Lx|^2' incorporates:
     *  Math: '<S668>/Math Function'
     *  Math: '<S679>/Math Function'
     *
     * About '<S668>/Math Function':
     *  Operator: magnitude^2
     *
     * About '<S679>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S679>/Math Function'
         *
         * About '<S679>/Math Function':
         *  Operator: magnitude^2
         */
        updatedLokRokScaleFactor = Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[i];

        /* Math: '<S668>/Math Function'
         *
         * About '<S668>/Math Function':
         *  Operator: magnitude^2
         */
        minXp = Model_Target_B.sf_Coeffs1stStage.absLi[i];
        Model_Target_B.Lin2_a[i] = updatedLokRokScaleFactor *
            updatedLokRokScaleFactor * (minXp * minXp);
    }

    /* End of Product: '<S679>/|Lx|^2' */

    /* MATLAB Function: '<S682>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain2'
     *  Constant: '<S669>/lsPole2'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2_a, 0.324919701F, 0.33754015F,
        &Model_Target_B.sf_MATLABFunction_eo,
        &Model_Target_DW.sf_MATLABFunction_eo);

    /* MATLAB Function: '<S668>/MATLAB Function' incorporates:
     *  Product: '<S679>/SPS*|Lx|^2'
     *  Product: '<S679>/|Lx|^2'
     *  Selector: '<S657>/Selector'
     *  Selector: '<S657>/Selector1'
     */
    /*  New SPS is calculated and smoothed using Lx/Rx. This change ensures no */
    /*  surround content generated when there is no phase difference between L/R */
    /*  regardless of the magnitude difference. */
    /*  The old SPS was calculated using Lin/Rin, and smoothed using Lx/Rx. */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Calculate coefficients/Smooth 2nd Stage/MATLAB Function': '<S680>:1' */
    /* '<S680>:1:7' Lx = Lxks .* Lin; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Lx[rtb_isImpulsive_c].re =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[rtb_isImpulsive_c] *
            Model_Target_B.y_o[rtb_isImpulsive_c].re;
        Model_Target_B.Lx[rtb_isImpulsive_c].im =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[rtb_isImpulsive_c] *
            Model_Target_B.y_o[rtb_isImpulsive_c].im;
    }

    /* '<S680>:1:8' Rx = Rxks .* Rin; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Rx[rtb_isImpulsive_c].re =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[rtb_isImpulsive_c];
        Model_Target_B.Rx[rtb_isImpulsive_c].im =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[rtb_isImpulsive_c];
    }

    /*  Surround Phase Selectivity */
    /*  SPS = |Lx - Rx|/(|Lx| + |Rx|) */
    /* '<S680>:1:12' SPS = abs(Lx - Rx) ./ (abs(Lx) + abs(Rx) + single(eps)); */
    for (i = 0; i < 129; i++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Rx[i].re;
        minXp = Model_Target_B.Rx[i].im;
        maxXp = Model_Target_B.Lx[i].re;
        Lx_im = Model_Target_B.Lx[i].im;
        updatedLokRokScaleFactor = qhmath_div_f(qhmath_hypot_f(maxXp -
            updatedLokRokScaleFactor, Lx_im - minXp), (qhmath_hypot_f(maxXp,
            Lx_im) + qhmath_hypot_f(updatedLokRokScaleFactor, minXp)) +
            2.22044605E-16F);
        Model_Target_B.Lstrk_k[i] = updatedLokRokScaleFactor;
        Model_Target_B.Lin2_a[i] *= updatedLokRokScaleFactor;
    }

    /* End of MATLAB Function: '<S668>/MATLAB Function' */

    /* MATLAB Function: '<S683>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain2'
     *  Constant: '<S669>/lsPole2'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2_a, 0.324919701F, 0.33754015F,
        &Model_Target_B.sf_MATLABFunction_d,
        &Model_Target_DW.sf_MATLABFunction_d);

    /* Product: '<S668>/Multiply' incorporates:
     *  Constant: '<S679>/Constant1'
     *  Math: '<S679>/Math Function1'
     *  Product: '<S679>/Multiply'
     *  Sum: '<S679>/Add'
     *
     * About '<S679>/Math Function1':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Multiply_a[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_eo.y[i] + 2.22044605E-16F) *
            Model_Target_B.sf_MATLABFunction_d.y[i] *
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[i];
    }

    /* End of Product: '<S668>/Multiply' */

    /* Product: '<S681>/|Rx|^2' incorporates:
     *  Math: '<S668>/Math Function1'
     *  Math: '<S681>/Math Function'
     *
     * About '<S668>/Math Function1':
     *  Operator: magnitude^2
     *
     * About '<S681>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S681>/Math Function'
         *
         * About '<S681>/Math Function':
         *  Operator: magnitude^2
         */
        updatedLokRokScaleFactor = Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[i];

        /* Math: '<S668>/Math Function1'
         *
         * About '<S668>/Math Function1':
         *  Operator: magnitude^2
         */
        minXp = Model_Target_B.sf_Coeffs1stStage.absRi[i];
        Model_Target_B.Lin2_a[i] = updatedLokRokScaleFactor *
            updatedLokRokScaleFactor * (minXp * minXp);
    }

    /* End of Product: '<S681>/|Rx|^2' */

    /* MATLAB Function: '<S687>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain2'
     *  Constant: '<S669>/lsPole2'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2_a, 0.324919701F, 0.33754015F,
        &Model_Target_B.sf_MATLABFunction_ea,
        &Model_Target_DW.sf_MATLABFunction_ea);

    /* Product: '<S681>/SPS*|Rx|^2' incorporates:
     *  Product: '<S681>/|Rx|^2'
     */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.Lin2_a[rtb_isImpulsive_c] *=
            Model_Target_B.Lstrk_k[rtb_isImpulsive_c];
    }

    /* End of Product: '<S681>/SPS*|Rx|^2' */

    /* MATLAB Function: '<S686>/MATLAB Function' incorporates:
     *  Constant: '<S669>/lsGain2'
     *  Constant: '<S669>/lsPole2'
     */
    Model_Target_MATLABFunction(Model_Target_B.Lin2_a, 0.324919701F, 0.33754015F,
        &Model_Target_B.sf_MATLABFunction_f,
        &Model_Target_DW.sf_MATLABFunction_f);

    /* Product: '<S668>/Multiply1' incorporates:
     *  Constant: '<S681>/Constant1'
     *  Math: '<S681>/Math Function1'
     *  Product: '<S681>/Multiply'
     *  Sum: '<S681>/Add'
     *
     * About '<S681>/Math Function1':
     *  Operator: reciprocal
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lstrk_k[i] = qhmath_div_f(1.0F,
            Model_Target_B.sf_MATLABFunction_ea.y[i] + 2.22044605E-16F) *
            Model_Target_B.sf_MATLABFunction_f.y[i] *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[i];
    }

    /* End of Product: '<S668>/Multiply1' */

    /* MATLAB Function: '<S661>/Apply coefficients' incorporates:
     *  Product: '<S668>/Multiply'
     *  Product: '<S668>/Multiply1'
     *  Selector: '<S657>/Selector'
     *  Selector: '<S657>/Selector1'
     */
    /*  Left/Right only */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/CalculateAndApplyCoefficients/DeciRate/Apply coefficients': '<S662>:1' */
    /* '<S662>:1:4' Lo = Lok.*L; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c].re =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lok[rtb_isImpulsive_c] *
            Model_Target_B.y_o[rtb_isImpulsive_c].re;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c].im =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lok[rtb_isImpulsive_c] *
            Model_Target_B.y_o[rtb_isImpulsive_c].im;
    }

    /* '<S662>:1:5' Ro = Rok.*R; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 129].re =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].re *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rok[rtb_isImpulsive_c];
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 129].im =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].im *
            Model_Target_B.sf_UpdateSteeringCoeffs.Rok[rtb_isImpulsive_c];
    }

    /*  Left/Right surround */
    /* '<S662>:1:8' Ls = Lsk.*L; */
    /* '<S662>:1:9' Rs = Rsk.*R; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        updatedLokRokScaleFactor = Model_Target_B.Lstrk_k[rtb_isImpulsive_c];
        rtb_Add1_e3 = Model_Target_B.Multiply_a[rtb_isImpulsive_c];
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 258].re =
            rtb_Add1_e3 * Model_Target_B.y_o[rtb_isImpulsive_c].re;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 258].im =
            rtb_Add1_e3 * Model_Target_B.y_o[rtb_isImpulsive_c].im;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 387].re =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].re *
            updatedLokRokScaleFactor;
        Model_Target_B.MatrixConcatenate_p[rtb_isImpulsive_c + 387].im =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].im *
            updatedLokRokScaleFactor;
    }

    /*  Left/Right surround residual */
    /* '<S662>:1:12' Lsr = (Lxk - Lsk) .*L ; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_Add1_e3 =
            Model_Target_B.sf_UpdateSteeringCoeffs.Lxk[rtb_isImpulsive_c] -
            Model_Target_B.Multiply_a[rtb_isImpulsive_c];
        Model_Target_B.Lx[rtb_isImpulsive_c].re = rtb_Add1_e3 *
            Model_Target_B.y_o[rtb_isImpulsive_c].re;
        Model_Target_B.Lx[rtb_isImpulsive_c].im = rtb_Add1_e3 *
            Model_Target_B.y_o[rtb_isImpulsive_c].im;
    }

    /* '<S662>:1:13' Rsr = (Rxk - Rsk) .*R; */
    for (rtb_isImpulsive_c = 0; rtb_isImpulsive_c < 129; rtb_isImpulsive_c++)
    {
        rtb_Add1_e3 =
            Model_Target_B.sf_UpdateSteeringCoeffs.Rxk[rtb_isImpulsive_c] -
            Model_Target_B.Lstrk_k[rtb_isImpulsive_c];
        Model_Target_B.Rx[rtb_isImpulsive_c].re =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].re * rtb_Add1_e3;
        Model_Target_B.Rx[rtb_isImpulsive_c].im =
            Model_Target_B.y_o[rtb_isImpulsive_c + 129].im * rtb_Add1_e3;
    }

    /* End of MATLAB Function: '<S661>/Apply coefficients' */

    /* Product: '<S715>/Divide' incorporates:
     *  Constant: '<S715>/Constant'
     *  Constant: '<S715>/Constant1'
     *  Product: '<S726>/Divide'
     *  Sum: '<S715>/Minus'
     */
    Lx_im = (1.0F -
             Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumFastPsdSmoothFactor)
        * 0.5F;

    /* Sum: '<S716>/Matrix Sum' */
    minXp = -0.0F;
    for (i = 0; i < 129; i++)
    {
        /* Math: '<S660>/Math Function' incorporates:
         *  Math: '<S660>/Math Function1'
         *  Math: '<S690>/Math Function'
         *  Math: '<S690>/Math Function1'
         *  Selector: '<S657>/Selector'
         *  Selector: '<S657>/Selector1'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S690>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S690>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.Lx[i];

        /* Math: '<S660>/Math Function'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.MathFunction_l[i] = rtb_y_o_0->re * rtb_y_o_0->re +
            rtb_y_o_0->im * rtb_y_o_0->im;

        /* Sum: '<S715>/Add1' incorporates:
         *  Delay: '<S715>/Delay'
         *  Delay: '<S715>/Delay1'
         *  Math: '<S660>/Math Function'
         *  Product: '<S715>/Divide'
         *  Product: '<S715>/Multiply'
         *  Product: '<S715>/Multiply1'
         *  Sum: '<S715>/Add'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_B.Lstrk_k[i] = (Model_Target_B.MathFunction_l[i] +
            Model_Target_DW.Delay_DSTATE_mg[i]) * Lx_im +
            Model_Target_DW.Delay1_DSTATE_g[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S716>/Matrix Sum' incorporates:
         *  Math: '<S660>/Math Function'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         */
        minXp += Model_Target_B.MathFunction_l[i];
    }

    /* Sum: '<S719>/Sum2' incorporates:
     *  Constant: '<S719>/Constant'
     *  Gain: '<S719>/Gain'
     *  Math: '<S719>/log10'
     *  Sum: '<S719>/Sum1'
     *
     * About '<S719>/log10':
     *  Operator: log10
     */
    updatedLokRokScaleFactor = qhmath_log10_f(minXp + 2.22044605E-16F) * 10.0F;

    /* MATLAB Function: '<S716>/Detect Impulse' incorporates:
     *  Delay: '<S716>/Delay'
     *  Sum: '<S716>/Add1'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Left Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S718>:1' */
    /* '<S718>:1:5' if isempty(counter) */
    /* '<S718>:1:6' if isempty(state) */
    /* '<S718>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (updatedLokRokScaleFactor - Model_Target_DW.Delay_DSTATE_nr > 6.0F)
    {
        /* '<S718>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S718>:1:10' counter = 0; */
        Model_Target_DW.counter_p = 0.0;
    }
    else if ((Model_Target_DW.counter_p <
              Model_Target_MaxValueOfCounterForDetectingImpulse) &&
             (Model_Target_DW.state_e == 1.0))
    {
        /* '<S718>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S718>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S718>:1:13' counter = counter + 1; */
        Model_Target_DW.counter_p++;
    }
    else
    {
        /* '<S718>:1:14' else */
        /* '<S718>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_c = 0;
    }

    /* '<S718>:1:17' state = isImpulsive; */
    Model_Target_DW.state_e = rtb_isImpulsive_c;

    /* End of MATLAB Function: '<S716>/Detect Impulse' */

    /* Product: '<S717>/Divide' incorporates:
     *  Constant: '<S717>/Constant'
     *  Constant: '<S717>/Constant1'
     *  Product: '<S728>/Divide'
     *  Sum: '<S717>/Minus'
     */
    minXp_tmp = (1.0F -
                 Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumSlowPsdSmoothFactor)
        * 0.5F;

    /* Sum: '<S717>/Add1' incorporates:
     *  Delay: '<S717>/Delay'
     *  Delay: '<S717>/Delay1'
     *  Math: '<S660>/Math Function'
     *  Product: '<S717>/Divide'
     *  Product: '<S717>/Multiply'
     *  Product: '<S717>/Multiply1'
     *  Sum: '<S717>/Add'
     *
     * About '<S660>/Math Function':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.Lin2_a[i] = (Model_Target_B.MathFunction_l[i] +
            Model_Target_DW.Delay_DSTATE_lq[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_ab[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S717>/Add1' */

    /* Delay: '<S713>/Delay' incorporates:
     *  Sum: '<S715>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_o[0], &Model_Target_B.Lstrk_k[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
            645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                Model_Target_B.Multiply1_o[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumLPxxFast_d
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                Model_Target_B.Multiply1_o[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.Lstrk_k[MedusaFdpDeciRateRfftRfftInput_tmp -
                    i];
            }
        }
    }

    /* End of Delay: '<S713>/Delay' */

    /* Delay: '<S713>/Delay1' incorporates:
     *  Sum: '<S717>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&Model_Target_B.Multiply1_a[0], &Model_Target_B.Lin2_a[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
            645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                Model_Target_B.Multiply1_a[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumLPxxSlow_i
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                Model_Target_B.Multiply1_a[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.Lin2_a[MedusaFdpDeciRateRfftRfftInput_tmp - i];
            }
        }
    }

    /* End of Delay: '<S713>/Delay1' */

    /* Product: '<S722>/Divide' incorporates:
     *  Constant: '<S722>/Constant'
     *  Constant: '<S722>/Constant1'
     *  Product: '<S723>/Divide'
     *  Product: '<S733>/Divide'
     *  Product: '<S734>/Divide'
     *  Sum: '<S722>/Minus'
     */
    maxXp = (1.0F -
             Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumLsSmoothFactor) *
        0.5F;

    /* Sum: '<S727>/Matrix Sum' */
    minXp = -0.0F;
    for (i = 0; i < 129; i++)
    {
        /* Switch: '<S711>/Switch' incorporates:
         *  Constant: '<S711>/Constant'
         *  Constant: '<S711>/Constant1'
         *  MinMax: '<S711>/Min'
         *  Product: '<S711>/Divide'
         *  Product: '<S711>/Multiply'
         *  Sum: '<S711>/Add'
         *  Switch: '<S713>/Switch'
         *  Switch: '<S713>/Switch1'
         */
        if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumOverwrite != 0.0F)
        {
            rtb_Add1_e3 = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_c > 0)
            {
                /* Switch: '<S713>/Switch1' incorporates:
                 *  Sum: '<S715>/Add1'
                 */
                rtb_Add1_e3 = Model_Target_B.Lstrk_k[i];

                /* Switch: '<S713>/Switch' incorporates:
                 *  Delay: '<S713>/Delay'
                 */
                rtb_R_f_re_tmp_0 = Model_Target_B.Multiply1_o[i];
            }
            else
            {
                /* Switch: '<S713>/Switch1' incorporates:
                 *  Sum: '<S717>/Add1'
                 */
                rtb_Add1_e3 = Model_Target_B.Lin2_a[i];

                /* Switch: '<S713>/Switch' incorporates:
                 *  Delay: '<S713>/Delay1'
                 */
                rtb_R_f_re_tmp_0 = Model_Target_B.Multiply1_a[i];
            }

            rtb_Add1_e3 = fminf(1.0F, qhmath_div_f(1.0F, rtb_Add1_e3 +
                                 2.22044605E-16F) * (rtb_R_f_re_tmp_0 *
                                 Model_Target_B.Multiply));
        }

        /* End of Switch: '<S711>/Switch' */

        /* Product: '<S714>/Multiply' incorporates:
         *  Math: '<S660>/Math Function'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Add1_e3 *= Model_Target_B.MathFunction_l[i];

        /* Sum: '<S722>/Add1' incorporates:
         *  Delay: '<S722>/Delay'
         *  Delay: '<S722>/Delay1'
         *  Product: '<S722>/Divide'
         *  Product: '<S722>/Multiply'
         *  Product: '<S722>/Multiply1'
         *  Sum: '<S722>/Add'
         */
        Model_Target_B.Multiply1_a[i] = (rtb_Add1_e3 +
            Model_Target_DW.Delay_DSTATE_h[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_e2[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Product: '<S714>/Multiply' */
        Model_Target_B.Multiply1_o[i] = rtb_Add1_e3;

        /* Sum: '<S723>/Add1' incorporates:
         *  Delay: '<S723>/Delay'
         *  Delay: '<S723>/Delay1'
         *  Math: '<S660>/Math Function'
         *  Product: '<S723>/Multiply'
         *  Product: '<S723>/Multiply1'
         *  Sum: '<S723>/Add'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         */
        rtb_Add1_e3 = (Model_Target_B.MathFunction_l[i] +
                       Model_Target_DW.Delay_DSTATE_ek[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_o4[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Product: '<S714>/Multiply1' incorporates:
         *  Constant: '<S714>/Constant'
         *  Product: '<S714>/Divide'
         *  Sum: '<S714>/Add'
         *  Sum: '<S714>/Subtract'
         *  Sum: '<S722>/Add1'
         */
        rtb_R_f_re_tmp = qhmath_div_f(Model_Target_B.Multiply1_a[i], rtb_Add1_e3
            + 2.22044605E-16F);
        rtb_R_f_re_tmp_0 = Model_Target_B.Lx[i].re;
        rtb_R_re = rtb_R_f_re_tmp * rtb_R_f_re_tmp_0;
        rtb_R_f_im_tmp = Model_Target_B.Lx[i].im;
        rtb_R_f_re_tmp *= rtb_R_f_im_tmp;

        /* Sum: '<S714>/Subtract' */
        Model_Target_B.MatrixConcatenate_p[i + 516].re = rtb_R_f_re_tmp_0 -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 516].im = rtb_R_f_im_tmp -
            rtb_R_f_re_tmp;

        /* SignalConversion generated from: '<S655>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_p[i + 645].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 645].im = rtb_R_f_re_tmp;

        /* Math: '<S660>/Math Function1' incorporates:
         *  Math: '<S660>/Math Function'
         *  Math: '<S690>/Math Function'
         *  Math: '<S690>/Math Function1'
         *  Selector: '<S657>/Selector'
         *  Selector: '<S657>/Selector1'
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S690>/Math Function':
         *  Operator: magnitude^2
         *
         * About '<S690>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_y_o_0 = &Model_Target_B.Rx[i];
        rtb_MathFunction1_e[i] = rtb_y_o_0->re * rtb_y_o_0->re + rtb_y_o_0->im *
            rtb_y_o_0->im;

        /* Sum: '<S723>/Add1' */
        rtb_Add1_gg[i] = rtb_Add1_e3;

        /* Sum: '<S726>/Add' incorporates:
         *  Math: '<S660>/Math Function1'
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_Add1_e3 = rtb_MathFunction1_e[i];

        /* Sum: '<S726>/Add1' incorporates:
         *  Delay: '<S726>/Delay'
         *  Delay: '<S726>/Delay1'
         *  Product: '<S726>/Multiply'
         *  Product: '<S726>/Multiply1'
         *  Sum: '<S726>/Add'
         */
        Model_Target_B.Multiply_bg[i] = (rtb_Add1_e3 +
            Model_Target_DW.Delay_DSTATE_cg[i]) * Lx_im +
            Model_Target_DW.Delay1_DSTATE_k[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumFastPsdSmoothFactor;

        /* Sum: '<S727>/Matrix Sum' */
        minXp += rtb_Add1_e3;
    }

    /* Sum: '<S730>/Sum2' incorporates:
     *  Constant: '<S730>/Constant'
     *  Gain: '<S730>/Gain'
     *  Math: '<S730>/log10'
     *  Sum: '<S730>/Sum1'
     *
     * About '<S730>/log10':
     *  Operator: log10
     */
    minXp = qhmath_log10_f(minXp + 2.22044605E-16F) * 10.0F;

    /* MATLAB Function: '<S727>/Detect Impulse' incorporates:
     *  Delay: '<S727>/Delay'
     *  Sum: '<S727>/Add1'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 2/Decimated-Rate FDP/Fdp/FreqDomainProcessing/Reverb Extractions/Right Reverb Extraction/Compute PSD/Impulse Detector/Detect Impulse': '<S729>:1' */
    /* '<S729>:1:5' if isempty(counter) */
    /* '<S729>:1:6' if isempty(state) */
    /* '<S729>:1:8' if (EnergyDifference > DetectImpulseThreshold) */
    if (minXp - Model_Target_DW.Delay_DSTATE_a > 6.0F)
    {
        /* '<S729>:1:9' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S729>:1:10' counter = 0; */
        Model_Target_DW.counter_n = 0.0;
    }
    else if ((Model_Target_DW.counter_n <
              Model_Target_MaxValueOfCounterForDetectingImpulse) &&
             (Model_Target_DW.state_o == 1.0))
    {
        /* '<S729>:1:11' elseif (counter < MaxValueOfCounterForDetectingImpulse) && (state == 1) */
        /* '<S729>:1:12' isImpulsive = 1; */
        rtb_isImpulsive_c = 1;

        /* '<S729>:1:13' counter = counter + 1; */
        Model_Target_DW.counter_n++;
    }
    else
    {
        /* '<S729>:1:14' else */
        /* '<S729>:1:15' isImpulsive = 0; */
        rtb_isImpulsive_c = 0;
    }

    /* '<S729>:1:17' state = isImpulsive; */
    Model_Target_DW.state_o = rtb_isImpulsive_c;

    /* End of MATLAB Function: '<S727>/Detect Impulse' */

    /* Sum: '<S728>/Add1' incorporates:
     *  Delay: '<S728>/Delay'
     *  Delay: '<S728>/Delay1'
     *  Math: '<S660>/Math Function1'
     *  Product: '<S728>/Multiply'
     *  Product: '<S728>/Multiply1'
     *  Sum: '<S728>/Add'
     *
     * About '<S660>/Math Function1':
     *  Operator: magnitude^2
     */
    for (i = 0; i < 129; i++)
    {
        Model_Target_B.instCPS_c[i] = (rtb_MathFunction1_e[i] +
            Model_Target_DW.Delay_DSTATE_ks[i]) * minXp_tmp +
            Model_Target_DW.Delay1_DSTATE_ep[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumSlowPsdSmoothFactor;
    }

    /* End of Sum: '<S728>/Add1' */

    /* Delay: '<S724>/Delay' incorporates:
     *  Sum: '<S726>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&Model_Target_B.Lxks_j[0], &Model_Target_B.Multiply_bg[0], 129U *
               sizeof(real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
            645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                Model_Target_B.Lxks_j[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumRPxxFast_e
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                Model_Target_B.Lxks_j[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.Multiply_bg[MedusaFdpDeciRateRfftRfftInput_tmp
                    - i];
            }
        }
    }

    /* End of Delay: '<S724>/Delay' */

    /* Delay: '<S724>/Delay1' incorporates:
     *  Sum: '<S728>/Add1'
     */
    if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec <
            1.0F)
    {
        memcpy(&rtb_Rxks[0], &Model_Target_B.instCPS_c[0], 129U * sizeof
               (real32_T));
    }
    else
    {
        if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec >
            645.0F)
        {
            i = 645;
        }
        else
        {
            i = (int32_T)(uint32_T)fmodf(truncf
                (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumDirectPathSamplesDec),
                4.2949673E+9F);
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < 129;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            if ((uint32_T)MedusaFdpDeciRateRfftRfftInput_tmp < (uint32_T)i)
            {
                rtb_Rxks[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_DW.MedusaDRspumRPxxSlow_i
                    [(MedusaFdpDeciRateRfftRfftInput_tmp - i) + 645];
            }
            else
            {
                rtb_Rxks[MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.instCPS_c[MedusaFdpDeciRateRfftRfftInput_tmp
                    - i];
            }
        }
    }

    /* End of Delay: '<S724>/Delay1' */
    for (i = 0; i < 129; i++)
    {
        /* Switch: '<S712>/Switch' incorporates:
         *  Constant: '<S712>/Constant'
         *  Constant: '<S712>/Constant1'
         *  MinMax: '<S712>/Min'
         *  Product: '<S712>/Divide'
         *  Product: '<S712>/Multiply'
         *  Sum: '<S712>/Add'
         *  Switch: '<S724>/Switch'
         *  Switch: '<S724>/Switch1'
         */
        if (Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumOverwrite != 0.0F)
        {
            rtb_Add1_e3 = 1.0F;
        }
        else
        {
            if (rtb_isImpulsive_c > 0)
            {
                /* Switch: '<S724>/Switch1' incorporates:
                 *  Sum: '<S726>/Add1'
                 */
                rtb_Add1_e3 = Model_Target_B.Multiply_bg[i];

                /* Switch: '<S724>/Switch' incorporates:
                 *  Delay: '<S724>/Delay'
                 */
                rtb_R_f_re_tmp_0 = Model_Target_B.Lxks_j[i];
            }
            else
            {
                /* Switch: '<S724>/Switch1' incorporates:
                 *  Sum: '<S728>/Add1'
                 */
                rtb_Add1_e3 = Model_Target_B.instCPS_c[i];

                /* Switch: '<S724>/Switch' incorporates:
                 *  Delay: '<S724>/Delay1'
                 */
                rtb_R_f_re_tmp_0 = rtb_Rxks[i];
            }

            rtb_Add1_e3 = fminf(1.0F, qhmath_div_f(1.0F, rtb_Add1_e3 +
                                 2.22044605E-16F) * (rtb_R_f_re_tmp_0 *
                                 Model_Target_B.Multiply));
        }

        /* Product: '<S725>/Multiply' incorporates:
         *  Math: '<S660>/Math Function1'
         *  Product: '<S725>/Divide'
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_Add1_e3 *= rtb_MathFunction1_e[i];

        /* Switch: '<S712>/Switch' incorporates:
         *  Product: '<S725>/Divide'
         */
        Model_Target_B.Multiply_a[i] = rtb_Add1_e3;

        /* Sum: '<S733>/Add1' incorporates:
         *  Delay: '<S733>/Delay'
         *  Delay: '<S733>/Delay1'
         *  Product: '<S733>/Multiply'
         *  Product: '<S733>/Multiply1'
         *  Sum: '<S733>/Add'
         */
        Model_Target_B.Lxks_j[i] = (rtb_Add1_e3 +
            Model_Target_DW.Delay_DSTATE_ai[i]) * maxXp +
            Model_Target_DW.Delay1_DSTATE_i[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Sum: '<S734>/Add1' incorporates:
         *  Delay: '<S734>/Delay'
         *  Delay: '<S734>/Delay1'
         *  Math: '<S660>/Math Function1'
         *  Product: '<S734>/Multiply'
         *  Product: '<S734>/Multiply1'
         *  Sum: '<S734>/Add'
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         */
        Lx_im = (rtb_MathFunction1_e[i] + Model_Target_DW.Delay_DSTATE_at[i]) *
            maxXp + Model_Target_DW.Delay1_DSTATE_aa[i] *
            Model_Target_PreAmp_p3_b0.MedusaDeciRateFdpSpumLsSmoothFactor;

        /* Product: '<S725>/Multiply1' incorporates:
         *  Constant: '<S725>/Constant'
         *  Product: '<S725>/Divide'
         *  Sum: '<S725>/Add'
         *  Sum: '<S725>/Subtract'
         *  Sum: '<S733>/Add1'
         */
        rtb_R_f_re_tmp = qhmath_div_f(Model_Target_B.Lxks_j[i], Lx_im +
            2.22044605E-16F);
        rtb_R_f_re_tmp_0 = Model_Target_B.Rx[i].re;
        rtb_R_re = rtb_R_f_re_tmp * rtb_R_f_re_tmp_0;
        rtb_R_f_im_tmp = Model_Target_B.Rx[i].im;
        rtb_R_f_re_tmp *= rtb_R_f_im_tmp;

        /* Sum: '<S725>/Subtract' */
        Model_Target_B.MatrixConcatenate_p[i + 774].re = rtb_R_f_re_tmp_0 -
            rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 774].im = rtb_R_f_im_tmp -
            rtb_R_f_re_tmp;

        /* SignalConversion generated from: '<S655>/Matrix Concatenate' */
        Model_Target_B.MatrixConcatenate_p[i + 903].re = rtb_R_re;
        Model_Target_B.MatrixConcatenate_p[i + 903].im = rtb_R_f_re_tmp;

        /* Sum: '<S734>/Add1' */
        rtb_Rxks[i] = Lx_im;
    }

    /* MATLAB Function: '<S737>/MATLAB Function' incorporates:
     *  Concatenate: '<S655>/Matrix Concatenate'
     *  Constant: '<S656>/Constant'
     */
    /* MATLAB Function 'RifftWola/RifftWola/Hexagon/MATLAB Function': '<S739>:1' */
    /* '<S739>:1:7' [~, numChannels] = size(u); */
    /* '<S739>:1:8' outputSize = fftSize - numOverlap; */
    /*  Buffer to hold overlapped samples */
    /* '<S739>:1:12' if isempty(outputOverlap) */
    /*  Buffer for Simulation  */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S739>:1:20' y = coder.nullcopy(single(zeros(outputSize, numChannels))); */
    /*  Simulation */
    /* '<S739>:1:23' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S739>:1:33' else */
    /* '<S739>:1:34' y = rifft_process(   single(complex(u)), ... */
    /* '<S739>:1:35'                         single(Twiddle1),... */
    /* '<S739>:1:36'                         single(Twiddle2),...  */
    /* '<S739>:1:37'                         single(RifftOutputTmp),... */
    /* '<S739>:1:38'                         single(win),... */
    /* '<S739>:1:39'                         outputOverlap,... */
    /* '<S739>:1:40'                         int32(fftSize),... */
    /* '<S739>:1:41'                         int32(numChannels),... */
    /* '<S739>:1:42'                         int32(numOverlap)); */
    rifft_process(&Model_Target_B.y_pz[0], &Model_Target_B.MatrixConcatenate_p[0],
                  &MedusaFdpDeciRateRifftRifftBufferTwiddle1[0],
                  &MedusaFdpDeciRateRifftRifftBufferTwiddle2[0],
                  &MedusaFdpDeciRateRifftRifftBufferRifftOutputTmp[0],
                  &Model_Target_ConstP.pooled74[0],
                  &Model_Target_DW.outputOverlap_j[0], 256, 8, 128);

    /* Buffer: '<S647>/BufferOut' */
    rtb_isImpulsive_c = 0;
    for (i = 0; i < 8; i++)
    {
        int32_T tmp;
        int32_T tmp_0;
        memIdx = 128;
        tmp_0 = i << 8;
        tmp = tmp_0 + Model_Target_DW.BufferOut_inBufPtrIdx;
        if (Model_Target_DW.BufferOut_inBufPtrIdx > 128)
        {
            for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                    MedusaFdpDeciRateRfftRfftInput_tmp < 256 -
                    Model_Target_DW.BufferOut_inBufPtrIdx;
                    MedusaFdpDeciRateRfftRfftInput_tmp++)
            {
                Model_Target_DW.BufferOut_CircBuf[tmp +
                    MedusaFdpDeciRateRfftRfftInput_tmp] =
                    Model_Target_B.y_pz[rtb_isImpulsive_c +
                    MedusaFdpDeciRateRfftRfftInput_tmp];
            }

            rtb_isImpulsive_c = (rtb_isImpulsive_c -
                                 Model_Target_DW.BufferOut_inBufPtrIdx) + 256;
            tmp = tmp_0;
            memIdx = Model_Target_DW.BufferOut_inBufPtrIdx - 128;
        }

        for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
                MedusaFdpDeciRateRfftRfftInput_tmp < memIdx;
                MedusaFdpDeciRateRfftRfftInput_tmp++)
        {
            Model_Target_DW.BufferOut_CircBuf[tmp +
                MedusaFdpDeciRateRfftRfftInput_tmp] =
                Model_Target_B.y_pz[rtb_isImpulsive_c +
                MedusaFdpDeciRateRfftRfftInput_tmp];
        }

        rtb_isImpulsive_c += memIdx;
    }

    Model_Target_DW.BufferOut_inBufPtrIdx += 128;
    if (Model_Target_DW.BufferOut_inBufPtrIdx >= 256)
    {
        Model_Target_DW.BufferOut_inBufPtrIdx -= 256;
    }

    /* End of Buffer: '<S647>/BufferOut' */
    /* Update for Delay: '<S716>/Delay' */
    Model_Target_DW.Delay_DSTATE_nr = updatedLokRokScaleFactor;

    /* Update for Delay: '<S715>/Delay' incorporates:
     *  Math: '<S660>/Math Function'
     *
     * About '<S660>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_mg[0], &Model_Target_B.MathFunction_l[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S715>/Delay1' incorporates:
     *  Sum: '<S715>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_g[0], &Model_Target_B.Lstrk_k[0], 129U
           * sizeof(real32_T));

    /* Update for Delay: '<S717>/Delay' incorporates:
     *  Math: '<S660>/Math Function'
     *
     * About '<S660>/Math Function':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_lq[0], &Model_Target_B.MathFunction_l[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S717>/Delay1' incorporates:
     *  Sum: '<S717>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_ab[0], &Model_Target_B.Lin2_a[0], 129U
           * sizeof(real32_T));

    /* Update for Delay: '<S713>/Delay' incorporates:
     *  Sum: '<S715>/Add1'
     */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumLPxxFast_d[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumLPxxFast_d[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumLPxxFast_d[516],
           &Model_Target_B.Lstrk_k[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S713>/Delay' */

    /* Update for Delay: '<S713>/Delay1' */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumLPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumLPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    /* Update for Delay: '<S727>/Delay' */
    Model_Target_DW.Delay_DSTATE_a = minXp;
    for (i = 0; i < 129; i++)
    {
        /* Update for Delay: '<S726>/Delay' incorporates:
         *  Math: '<S660>/Math Function1'
         *
         * About '<S660>/Math Function1':
         *  Operator: magnitude^2
         */
        rtb_Add1_e3 = rtb_MathFunction1_e[i];

        /* Update for Delay: '<S713>/Delay1' incorporates:
         *  Sum: '<S717>/Add1'
         */
        Model_Target_DW.MedusaDRspumLPxxSlow_i[i + 516] =
            Model_Target_B.Lin2_a[i];

        /* Update for Delay: '<S722>/Delay' incorporates:
         *  Product: '<S714>/Multiply'
         */
        Model_Target_DW.Delay_DSTATE_h[i] = Model_Target_B.Multiply1_o[i];

        /* Update for Delay: '<S722>/Delay1' incorporates:
         *  Sum: '<S722>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_e2[i] = Model_Target_B.Multiply1_a[i];

        /* Update for Delay: '<S723>/Delay' incorporates:
         *  Math: '<S660>/Math Function'
         *
         * About '<S660>/Math Function':
         *  Operator: magnitude^2
         */
        Model_Target_DW.Delay_DSTATE_ek[i] = Model_Target_B.MathFunction_l[i];

        /* Update for Delay: '<S723>/Delay1' incorporates:
         *  Sum: '<S723>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_o4[i] = rtb_Add1_gg[i];

        /* Update for Delay: '<S726>/Delay' */
        Model_Target_DW.Delay_DSTATE_cg[i] = rtb_Add1_e3;

        /* Update for Delay: '<S726>/Delay1' incorporates:
         *  Sum: '<S726>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_k[i] = Model_Target_B.Multiply_bg[i];

        /* Update for Delay: '<S728>/Delay' */
        Model_Target_DW.Delay_DSTATE_ks[i] = rtb_Add1_e3;

        /* Update for Delay: '<S728>/Delay1' incorporates:
         *  Sum: '<S728>/Add1'
         */
        Model_Target_DW.Delay1_DSTATE_ep[i] = Model_Target_B.instCPS_c[i];
    }

    /* Update for Delay: '<S724>/Delay' incorporates:
     *  Sum: '<S726>/Add1'
     */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumRPxxFast_e[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumRPxxFast_e[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxFast_e[516],
           &Model_Target_B.Multiply_bg[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S724>/Delay' */

    /* Update for Delay: '<S724>/Delay1' incorporates:
     *  Sum: '<S728>/Add1'
     */
    for (MedusaFdpDeciRateRfftRfftInput_tmp = 0;
            MedusaFdpDeciRateRfftRfftInput_tmp < 516;
            MedusaFdpDeciRateRfftRfftInput_tmp++)
    {
        Model_Target_DW.MedusaDRspumRPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp]
            =
            Model_Target_DW.MedusaDRspumRPxxSlow_i[MedusaFdpDeciRateRfftRfftInput_tmp
            + 129];
    }

    memcpy(&Model_Target_DW.MedusaDRspumRPxxSlow_i[516],
           &Model_Target_B.instCPS_c[0], 129U * sizeof(real32_T));

    /* End of Update for Delay: '<S724>/Delay1' */

    /* Update for Delay: '<S733>/Delay' incorporates:
     *  Product: '<S725>/Multiply'
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_ai[0], &Model_Target_B.Multiply_a[0],
           129U * sizeof(real32_T));

    /* Update for Delay: '<S733>/Delay1' incorporates:
     *  Sum: '<S733>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_i[0], &Model_Target_B.Lxks_j[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S734>/Delay' incorporates:
     *  Math: '<S660>/Math Function1'
     *
     * About '<S660>/Math Function1':
     *  Operator: magnitude^2
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_at[0], &rtb_MathFunction1_e[0], 129U *
           sizeof(real32_T));

    /* Update for Delay: '<S734>/Delay1' incorporates:
     *  Sum: '<S734>/Add1'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_aa[0], &rtb_Rxks[0], 129U * sizeof
           (real32_T));
}

/*
 * Output and update for action system:
 *    '<S962>/Fading Forward'
 *    '<S950>/Fading Forward'
 *    '<S974>/Fading Forward'
 *    '<S1071>/Fading Forward'
 *    '<S1059>/Fading Forward'
 *    '<S1083>/Fading Forward'
 */
void Model_Target_FadingForward(real32_T rtu_backFadeGain, real32_T
    rtu_forwardDownmixThreshold, real32_T rtu_forwardDownmixMax, real32_T
    *rty_downmix)
{
    /* Product: '<S967>/Multiply' incorporates:
     *  Constant: '<S967>/Constant'
     *  Constant: '<S967>/EPS'
     *  MinMax: '<S967>/Max'
     *  MinMax: '<S967>/Min'
     *  Product: '<S967>/Divide'
     *  Sum: '<S967>/Subtract'
     */
    *rty_downmix = (1.0F - qhmath_div_f(fminf(rtu_backFadeGain,
                      rtu_forwardDownmixThreshold), fmaxf
                     (rtu_forwardDownmixThreshold, 1.1920929E-7F))) *
        rtu_forwardDownmixMax;
}

/*
 * Output and update for action system:
 *    '<S962>/Fading Backward'
 *    '<S950>/Fading Backward'
 *    '<S974>/Fading Backward'
 *    '<S1071>/Fading Backward'
 *    '<S1059>/Fading Backward'
 *    '<S1083>/Fading Backward'
 */
void Model_Target_FadingBackward(real32_T rtu_frontFadeGain, real32_T
    rtu_backwardDownmixThreshold, real32_T rtu_backwardDownmixMax, real32_T
    *rty_downmix)
{
    /* Product: '<S966>/Multiply' incorporates:
     *  Constant: '<S966>/Constant'
     *  Constant: '<S966>/EPS'
     *  MinMax: '<S966>/Max'
     *  MinMax: '<S966>/Min'
     *  Product: '<S966>/Divide'
     *  Sum: '<S966>/Subtract'
     */
    *rty_downmix = (1.0F - qhmath_div_f(fminf(rtu_frontFadeGain,
                      rtu_backwardDownmixThreshold), fmaxf
                     (rtu_backwardDownmixThreshold, 1.1920929E-7F))) *
        rtu_backwardDownmixMax;
}

/* Output and update for atomic system: '<S952>/process' */
void Model_Target_process(const boolean_T *rtd_FRM_Freeze_CS, real32_T
    rtd_FRM_currentGain_CS[12], int32_T rtd_FRM_frameCount_CS[12], const
    real32_T rtd_FRM_rampCoeff_CS[12], const real32_T rtd_FRM_targetGain_CS[12])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/process': '<S959>:1' */
    /* '<S959>:1:10' for i = 1:numel(FRM_currentGain_CS) */
    for (i = 0; i < 12; i++)
    {
        /* '<S959>:1:11' if (FRM_Freeze_CS(1) == false) */
        if (!*rtd_FRM_Freeze_CS)
        {
            /* '<S959>:1:12' if (FRM_frameCount_CS(i) == 0) */
            if (rtd_FRM_frameCount_CS[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S959>:1:14' FRM_currentGain_CS(i) = FRM_targetGain_CS(i); */
                rtd_FRM_currentGain_CS[i] = rtd_FRM_targetGain_CS[i];
            }
            else
            {
                /* '<S959>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S959>:1:17' FRM_currentGain_CS(i) = FRM_currentGain_CS(i)*FRM_rampCoeff_CS(i); */
                rtd_FRM_currentGain_CS[i] *= rtd_FRM_rampCoeff_CS[i];

                /* '<S959>:1:18' FRM_frameCount_CS(i) = FRM_frameCount_CS(i) - 1; */
                rtd_FRM_frameCount_CS[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S964>/process' */
void Model_Target_process_o(const boolean_T *rtd_FRM_Freeze_Left, real32_T
    rtd_FRM_currentGain_Left[30], int32_T rtd_FRM_frameCount_Left[30], const
    real32_T rtd_FRM_rampCoeff_Left[30], const real32_T rtd_FRM_targetGain_Left
    [30])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Ramper/process': '<S971>:1' */
    /* '<S971>:1:10' for i = 1:numel(FRM_currentGain_Left) */
    for (i = 0; i < 30; i++)
    {
        /* '<S971>:1:11' if (FRM_Freeze_Left(1) == false) */
        if (!*rtd_FRM_Freeze_Left)
        {
            /* '<S971>:1:12' if (FRM_frameCount_Left(i) == 0) */
            if (rtd_FRM_frameCount_Left[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S971>:1:14' FRM_currentGain_Left(i) = FRM_targetGain_Left(i); */
                rtd_FRM_currentGain_Left[i] = rtd_FRM_targetGain_Left[i];
            }
            else
            {
                /* '<S971>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S971>:1:17' FRM_currentGain_Left(i) = FRM_currentGain_Left(i)*FRM_rampCoeff_Left(i); */
                rtd_FRM_currentGain_Left[i] *= rtd_FRM_rampCoeff_Left[i];

                /* '<S971>:1:18' FRM_frameCount_Left(i) = FRM_frameCount_Left(i) - 1; */
                rtd_FRM_frameCount_Left[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S976>/process' */
void Model_Target_process_i(const boolean_T *rtd_FRM_Freeze_Right, real32_T
    rtd_FRM_currentGain_Right[30], int32_T rtd_FRM_frameCount_Right[30], const
    real32_T rtd_FRM_rampCoeff_Right[30], const real32_T
    rtd_FRM_targetGain_Right[30])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Ramper/process': '<S983>:1' */
    /* '<S983>:1:10' for i = 1:numel(FRM_currentGain_Right) */
    for (i = 0; i < 30; i++)
    {
        /* '<S983>:1:11' if (FRM_Freeze_Right(1) == false) */
        if (!*rtd_FRM_Freeze_Right)
        {
            /* '<S983>:1:12' if (FRM_frameCount_Right(i) == 0) */
            if (rtd_FRM_frameCount_Right[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S983>:1:14' FRM_currentGain_Right(i) = FRM_targetGain_Right(i); */
                rtd_FRM_currentGain_Right[i] = rtd_FRM_targetGain_Right[i];
            }
            else
            {
                /* '<S983>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S983>:1:17' FRM_currentGain_Right(i) = FRM_currentGain_Right(i)*FRM_rampCoeff_Right(i); */
                rtd_FRM_currentGain_Right[i] *= rtd_FRM_rampCoeff_Right[i];

                /* '<S983>:1:18' FRM_frameCount_Right(i) = FRM_frameCount_Right(i) - 1; */
                rtd_FRM_frameCount_Right[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S964>/control' */
void Model_Target_control_m(const real32_T rtu_target_gains_linear[30], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_FRM_Freeze_Left,
    real32_T rtd_FRM_currentGain_Left[30], int32_T rtd_FRM_frameCount_Left[30],
    real32_T rtd_FRM_rampCoeff_Left[30], real32_T rtd_FRM_targetGain_Left[30])
{
    int32_T k;
    real32_T currentgain[30];
    real32_T diff[30];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Ramper/control': '<S970>:1' */
    /* '<S970>:1:10' dim_rgain = size(FRM_currentGain_Left); */
    /* '<S970>:1:11' rgain_SILENT_GAIN_mat = (MedusaFRMConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S970>:1:15' FRM_Freeze_Left(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S970>:1:24' currentgain = max(FRM_currentGain_Left, rgain_SILENT_GAIN_mat); */
    /* '<S970>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S970>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 30; k++)
    {
        currentgain[k] = fmaxf(rtd_FRM_currentGain_Left[k], 1.1920929E-7F);
        rtd_FRM_rampCoeff_Left[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S970>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S970>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S970>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S970>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S970>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 30; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_FRM_rampCoeff_Left[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S970>:1:43' quantum_ms = 1000 * (MedusaFRMConfig.frame_size) / (MedusaFRMConfig.sample_rate_in_hertz); */
    /* '<S970>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S970>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S970>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S970>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S970>:1:63' FRM_frameCount_Left  = int32(numFrames); */
    /* '<S970>:1:64' FRM_rampCoeff_Left   = single(RampCoef); */
    /* '<S970>:1:65' FRM_targetGain_Left  = target_gains_linear; */
    /* '<S970>:1:66' FRM_currentGain_Left = currentgain; */
    for (k = 0; k < 30; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_FRM_rampCoeff_Left[k] = qhmath_div_f(rtd_FRM_rampCoeff_Left[k],
            currentgain_0);
        rtd_FRM_rampCoeff_Left[k] = qhmath_log_f(rtd_FRM_rampCoeff_Left[k]);
        rtd_FRM_rampCoeff_Left[k] = qhmath_div_f(rtd_FRM_rampCoeff_Left[k],
            numFrames);
        rtd_FRM_rampCoeff_Left[k] = qhmath_exp_f(rtd_FRM_rampCoeff_Left[k]);
        rtd_FRM_frameCount_Left[k] = (int32_T)roundf(numFrames);
        rtd_FRM_targetGain_Left[k] = rtu_target_gains_linear[k];
        rtd_FRM_currentGain_Left[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S970>:1:69' FRM_Freeze_Left(1) = false; */
    *rtd_FRM_Freeze_Left = false;
}

/* Output and update for function-call system: '<S952>/control' */
void Model_Target_control_e(const real32_T rtu_target_gains_linear[12], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_FRM_Freeze_CS, real32_T
    rtd_FRM_currentGain_CS[12], int32_T rtd_FRM_frameCount_CS[12], real32_T
    rtd_FRM_rampCoeff_CS[12], real32_T rtd_FRM_targetGain_CS[12])
{
    int32_T k;
    real32_T currentgain[12];
    real32_T diff[12];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/control': '<S958>:1' */
    /* '<S958>:1:10' dim_rgain = size(FRM_currentGain_CS); */
    /* '<S958>:1:11' rgain_SILENT_GAIN_mat = (MedusaFRMConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S958>:1:15' FRM_Freeze_CS(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S958>:1:24' currentgain = max(FRM_currentGain_CS, rgain_SILENT_GAIN_mat); */
    /* '<S958>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S958>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 12; k++)
    {
        currentgain[k] = fmaxf(rtd_FRM_currentGain_CS[k], 1.1920929E-7F);
        rtd_FRM_rampCoeff_CS[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S958>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S958>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S958>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S958>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S958>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 12; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_FRM_rampCoeff_CS[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S958>:1:43' quantum_ms = 1000 * (MedusaFRMConfig.frame_size) / (MedusaFRMConfig.sample_rate_in_hertz); */
    /* '<S958>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S958>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S958>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S958>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S958>:1:63' FRM_frameCount_CS  = int32(numFrames); */
    /* '<S958>:1:64' FRM_rampCoeff_CS   = single(RampCoef); */
    /* '<S958>:1:65' FRM_targetGain_CS  = target_gains_linear; */
    /* '<S958>:1:66' FRM_currentGain_CS = currentgain; */
    for (k = 0; k < 12; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_FRM_rampCoeff_CS[k] = qhmath_div_f(rtd_FRM_rampCoeff_CS[k],
            currentgain_0);
        rtd_FRM_rampCoeff_CS[k] = qhmath_log_f(rtd_FRM_rampCoeff_CS[k]);
        rtd_FRM_rampCoeff_CS[k] = qhmath_div_f(rtd_FRM_rampCoeff_CS[k],
            numFrames);
        rtd_FRM_rampCoeff_CS[k] = qhmath_exp_f(rtd_FRM_rampCoeff_CS[k]);
        rtd_FRM_frameCount_CS[k] = (int32_T)roundf(numFrames);
        rtd_FRM_targetGain_CS[k] = rtu_target_gains_linear[k];
        rtd_FRM_currentGain_CS[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S958>:1:69' FRM_Freeze_CS(1) = false; */
    *rtd_FRM_Freeze_CS = false;
}

/* Output and update for function-call system: '<S976>/control' */
void Model_Target_control_a(const real32_T rtu_target_gains_linear[30], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_FRM_Freeze_Right,
    real32_T rtd_FRM_currentGain_Right[30], int32_T rtd_FRM_frameCount_Right[30],
    real32_T rtd_FRM_rampCoeff_Right[30], real32_T rtd_FRM_targetGain_Right[30])
{
    int32_T k;
    real32_T currentgain[30];
    real32_T diff[30];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Ramper/control': '<S982>:1' */
    /* '<S982>:1:10' dim_rgain = size(FRM_currentGain_Right); */
    /* '<S982>:1:11' rgain_SILENT_GAIN_mat = (MedusaFRMConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S982>:1:15' FRM_Freeze_Right(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S982>:1:24' currentgain = max(FRM_currentGain_Right, rgain_SILENT_GAIN_mat); */
    /* '<S982>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S982>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 30; k++)
    {
        currentgain[k] = fmaxf(rtd_FRM_currentGain_Right[k], 1.1920929E-7F);
        rtd_FRM_rampCoeff_Right[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S982>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S982>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S982>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S982>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S982>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 30; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_FRM_rampCoeff_Right[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S982>:1:43' quantum_ms = 1000 * (MedusaFRMConfig.frame_size) / (MedusaFRMConfig.sample_rate_in_hertz); */
    /* '<S982>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S982>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S982>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S982>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S982>:1:63' FRM_frameCount_Right  = int32(numFrames); */
    /* '<S982>:1:64' FRM_rampCoeff_Right   = single(RampCoef); */
    /* '<S982>:1:65' FRM_targetGain_Right  = target_gains_linear; */
    /* '<S982>:1:66' FRM_currentGain_Right = currentgain; */
    for (k = 0; k < 30; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_FRM_rampCoeff_Right[k] = qhmath_div_f(rtd_FRM_rampCoeff_Right[k],
            currentgain_0);
        rtd_FRM_rampCoeff_Right[k] = qhmath_log_f(rtd_FRM_rampCoeff_Right[k]);
        rtd_FRM_rampCoeff_Right[k] = qhmath_div_f(rtd_FRM_rampCoeff_Right[k],
            numFrames);
        rtd_FRM_rampCoeff_Right[k] = qhmath_exp_f(rtd_FRM_rampCoeff_Right[k]);
        rtd_FRM_frameCount_Right[k] = (int32_T)roundf(numFrames);
        rtd_FRM_targetGain_Right[k] = rtu_target_gains_linear[k];
        rtd_FRM_currentGain_Right[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S982>:1:69' FRM_Freeze_Right(1) = false; */
    *rtd_FRM_Freeze_Right = false;
}

/* Output and update for function-call system: '<S1023>/init' */
void InitTrigger_Model_141_3728_59_156(void)
{
    /* MATLAB Function: '<S1022>/PoolIirInit' */
    /* MATLAB Function: '<S1022>/PoolIirInit' incorporates:
     *  Constant: '<S1017>/Constant'
     *  Sum: '<S1011>/Add'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1028>:1' */
    /* '<S1028>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1025>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1025>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1025>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1025>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1025>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1025>:1:28' else */
    /* '<S1025>:1:29' switch(VariantStr) */
    /* '<S1025>:1:30' case{"Hexagon"} */
    /* '<S1025>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1025>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1025>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaPremixCSsosA55058states[0],
                 &MedusaPremixCSsosA59792PoolIirAudioIn[0], 8U, 1U,
                 &Model_Target_ConstP.pooled103,
                 &MedusaPremixCSsosA9635PoolIirCoeffs[0],
                 &MedusaPremixCSsosA55058states[0], 57U, 1U, 20U);

    /* '<S1025>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1031>/init' */
void InitTrigger_Model_141_3728_59_192(void)
{
    /* MATLAB Function: '<S1030>/SignalBreakFcn' */
    /* MATLAB Function: '<S1030>/SignalBreakFcn' incorporates:
     *  Constant: '<S1017>/Constant1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1033>:1' */
    /* '<S1033>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1032>:1' */
    /* '<S1032>:1:3' y = u; */
    memcpy(&MedusaPremixCSsosA9635PoolIirCoeffs[0],
           &Model_Target_ConstP.Constant1_Value_h[0], 21U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S1040>/init' */
void InitTrigger_Model_141_3745_59_156(void)
{
    /* MATLAB Function: '<S1039>/PoolIirInit' */
    /* MATLAB Function: '<S1039>/PoolIirInit' incorporates:
     *  Constant: '<S1034>/Constant'
     *  Product: '<S1014>/Matrix Multiply1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1045>:1' */
    /* '<S1045>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1042>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1042>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1042>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1042>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1042>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1042>:1:28' else */
    /* '<S1042>:1:29' switch(VariantStr) */
    /* '<S1042>:1:30' case{"Hexagon"} */
    /* '<S1042>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1042>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1042>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaPremixCSsosB36825states[0],
                 &MedusaPremixCSsosB23177PoolIirAudioIn[0], 8U, 1U,
                 &Model_Target_ConstP.pooled103,
                 &MedusaPremixCSsosB46041PoolIirCoeffs[0],
                 &MedusaPremixCSsosB36825states[0], 57U, 1U, 20U);

    /* '<S1042>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1048>/init' */
void InitTrigger_Model_141_3745_59_192(void)
{
    /* MATLAB Function: '<S1047>/SignalBreakFcn' */
    /* MATLAB Function: '<S1047>/SignalBreakFcn' incorporates:
     *  Constant: '<S1034>/Constant1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1050>:1' */
    /* '<S1050>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1049>:1' */
    /* '<S1049>:1:3' y = u; */
    memcpy(&MedusaPremixCSsosB46041PoolIirCoeffs[0],
           &Model_Target_ConstP.Constant1_Value_n[0], 21U * sizeof(real32_T));
}

/* Output and update for atomic system: '<S1061>/process' */
void Model_Target_process_p(const boolean_T *rtd_Premix_Freeze_CS, real32_T
    rtd_Premix_currentGain_CS[20], int32_T rtd_Premix_frameCount_CS[20], const
    real32_T rtd_Premix_rampCoeff_CS[20], const real32_T
    rtd_Premix_targetGain_CS[20])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/process': '<S1068>:1' */
    /* '<S1068>:1:10' for i = 1:numel(Premix_currentGain_CS) */
    for (i = 0; i < 20; i++)
    {
        /* '<S1068>:1:11' if (Premix_Freeze_CS(1) == false) */
        if (!*rtd_Premix_Freeze_CS)
        {
            /* '<S1068>:1:12' if (Premix_frameCount_CS(i) == 0) */
            if (rtd_Premix_frameCount_CS[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1068>:1:14' Premix_currentGain_CS(i) = Premix_targetGain_CS(i); */
                rtd_Premix_currentGain_CS[i] = rtd_Premix_targetGain_CS[i];
            }
            else
            {
                /* '<S1068>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1068>:1:17' Premix_currentGain_CS(i) = Premix_currentGain_CS(i)*Premix_rampCoeff_CS(i); */
                rtd_Premix_currentGain_CS[i] *= rtd_Premix_rampCoeff_CS[i];

                /* '<S1068>:1:18' Premix_frameCount_CS(i) = Premix_frameCount_CS(i) - 1; */
                rtd_Premix_frameCount_CS[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S1073>/process' */
void Model_Target_process_in(const boolean_T *rtd_Premix_Freeze_Left, real32_T
    rtd_Premix_currentGain_Left[77], int32_T rtd_Premix_frameCount_Left[77],
    const real32_T rtd_Premix_rampCoeff_Left[77], const real32_T
    rtd_Premix_targetGain_Left[77])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Ramper/process': '<S1080>:1' */
    /* '<S1080>:1:10' for i = 1:numel(Premix_currentGain_Left) */
    for (i = 0; i < 77; i++)
    {
        /* '<S1080>:1:11' if (Premix_Freeze_Left(1) == false) */
        if (!*rtd_Premix_Freeze_Left)
        {
            /* '<S1080>:1:12' if (Premix_frameCount_Left(i) == 0) */
            if (rtd_Premix_frameCount_Left[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1080>:1:14' Premix_currentGain_Left(i) = Premix_targetGain_Left(i); */
                rtd_Premix_currentGain_Left[i] = rtd_Premix_targetGain_Left[i];
            }
            else
            {
                /* '<S1080>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1080>:1:17' Premix_currentGain_Left(i) = Premix_currentGain_Left(i)*Premix_rampCoeff_Left(i); */
                rtd_Premix_currentGain_Left[i] *= rtd_Premix_rampCoeff_Left[i];

                /* '<S1080>:1:18' Premix_frameCount_Left(i) = Premix_frameCount_Left(i) - 1; */
                rtd_Premix_frameCount_Left[i]--;
            }
        }
    }
}

/* Output and update for atomic system: '<S1085>/process' */
void Model_Target_process_f(const boolean_T *rtd_Premix_Freeze_Right, real32_T
    rtd_Premix_currentGain_Right[77], int32_T rtd_Premix_frameCount_Right[77],
    const real32_T rtd_Premix_rampCoeff_Right[77], const real32_T
    rtd_Premix_targetGain_Right[77])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Ramper/process': '<S1092>:1' */
    /* '<S1092>:1:10' for i = 1:numel(Premix_currentGain_Right) */
    for (i = 0; i < 77; i++)
    {
        /* '<S1092>:1:11' if (Premix_Freeze_Right(1) == false) */
        if (!*rtd_Premix_Freeze_Right)
        {
            /* '<S1092>:1:12' if (Premix_frameCount_Right(i) == 0) */
            if (rtd_Premix_frameCount_Right[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1092>:1:14' Premix_currentGain_Right(i) = Premix_targetGain_Right(i); */
                rtd_Premix_currentGain_Right[i] = rtd_Premix_targetGain_Right[i];
            }
            else
            {
                /* '<S1092>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1092>:1:17' Premix_currentGain_Right(i) = Premix_currentGain_Right(i)*Premix_rampCoeff_Right(i); */
                rtd_Premix_currentGain_Right[i] *= rtd_Premix_rampCoeff_Right[i];

                /* '<S1092>:1:18' Premix_frameCount_Right(i) = Premix_frameCount_Right(i) - 1; */
                rtd_Premix_frameCount_Right[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1073>/control' */
void Model_Target_control_p(const real32_T rtu_target_gains_linear[77], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_Premix_Freeze_Left,
    real32_T rtd_Premix_currentGain_Left[77], int32_T
    rtd_Premix_frameCount_Left[77], real32_T rtd_Premix_rampCoeff_Left[77],
    real32_T rtd_Premix_targetGain_Left[77])
{
    int32_T k;
    real32_T currentgain[77];
    real32_T diff[77];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Ramper/control': '<S1079>:1' */
    /* '<S1079>:1:10' dim_rgain = size(Premix_currentGain_Left); */
    /* '<S1079>:1:11' rgain_SILENT_GAIN_mat = (MedusaPremixConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1079>:1:15' Premix_Freeze_Left(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1079>:1:24' currentgain = max(Premix_currentGain_Left, rgain_SILENT_GAIN_mat); */
    /* '<S1079>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1079>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 77; k++)
    {
        currentgain[k] = fmaxf(rtd_Premix_currentGain_Left[k], 1.1920929E-7F);
        rtd_Premix_rampCoeff_Left[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1079>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1079>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1079>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1079>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1079>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 77; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_Premix_rampCoeff_Left[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1079>:1:43' quantum_ms = 1000 * (MedusaPremixConfig.frame_size) / (MedusaPremixConfig.sample_rate_in_hertz); */
    /* '<S1079>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1079>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1079>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1079>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1079>:1:63' Premix_frameCount_Left  = int32(numFrames); */
    /* '<S1079>:1:64' Premix_rampCoeff_Left   = single(RampCoef); */
    /* '<S1079>:1:65' Premix_targetGain_Left  = target_gains_linear; */
    /* '<S1079>:1:66' Premix_currentGain_Left = currentgain; */
    for (k = 0; k < 77; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_Premix_rampCoeff_Left[k] = qhmath_div_f(rtd_Premix_rampCoeff_Left[k],
            currentgain_0);
        rtd_Premix_rampCoeff_Left[k] = qhmath_log_f(rtd_Premix_rampCoeff_Left[k]);
        rtd_Premix_rampCoeff_Left[k] = qhmath_div_f(rtd_Premix_rampCoeff_Left[k],
            numFrames);
        rtd_Premix_rampCoeff_Left[k] = qhmath_exp_f(rtd_Premix_rampCoeff_Left[k]);
        rtd_Premix_frameCount_Left[k] = (int32_T)roundf(numFrames);
        rtd_Premix_targetGain_Left[k] = rtu_target_gains_linear[k];
        rtd_Premix_currentGain_Left[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1079>:1:69' Premix_Freeze_Left(1) = false; */
    *rtd_Premix_Freeze_Left = false;
}

/* Output and update for function-call system: '<S1061>/control' */
void Model_Target_control_l(const real32_T rtu_target_gains_linear[20], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_Premix_Freeze_CS,
    real32_T rtd_Premix_currentGain_CS[20], int32_T rtd_Premix_frameCount_CS[20],
    real32_T rtd_Premix_rampCoeff_CS[20], real32_T rtd_Premix_targetGain_CS[20])
{
    int32_T k;
    real32_T currentgain[20];
    real32_T diff[20];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Ramper/control': '<S1067>:1' */
    /* '<S1067>:1:10' dim_rgain = size(Premix_currentGain_CS); */
    /* '<S1067>:1:11' rgain_SILENT_GAIN_mat = (MedusaPremixConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1067>:1:15' Premix_Freeze_CS(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1067>:1:24' currentgain = max(Premix_currentGain_CS, rgain_SILENT_GAIN_mat); */
    /* '<S1067>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1067>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 20; k++)
    {
        currentgain[k] = fmaxf(rtd_Premix_currentGain_CS[k], 1.1920929E-7F);
        rtd_Premix_rampCoeff_CS[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1067>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1067>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1067>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1067>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1067>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 20; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_Premix_rampCoeff_CS[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1067>:1:43' quantum_ms = 1000 * (MedusaPremixConfig.frame_size) / (MedusaPremixConfig.sample_rate_in_hertz); */
    /* '<S1067>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1067>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1067>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1067>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1067>:1:63' Premix_frameCount_CS  = int32(numFrames); */
    /* '<S1067>:1:64' Premix_rampCoeff_CS   = single(RampCoef); */
    /* '<S1067>:1:65' Premix_targetGain_CS  = target_gains_linear; */
    /* '<S1067>:1:66' Premix_currentGain_CS = currentgain; */
    for (k = 0; k < 20; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_Premix_rampCoeff_CS[k] = qhmath_div_f(rtd_Premix_rampCoeff_CS[k],
            currentgain_0);
        rtd_Premix_rampCoeff_CS[k] = qhmath_log_f(rtd_Premix_rampCoeff_CS[k]);
        rtd_Premix_rampCoeff_CS[k] = qhmath_div_f(rtd_Premix_rampCoeff_CS[k],
            numFrames);
        rtd_Premix_rampCoeff_CS[k] = qhmath_exp_f(rtd_Premix_rampCoeff_CS[k]);
        rtd_Premix_frameCount_CS[k] = (int32_T)roundf(numFrames);
        rtd_Premix_targetGain_CS[k] = rtu_target_gains_linear[k];
        rtd_Premix_currentGain_CS[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1067>:1:69' Premix_Freeze_CS(1) = false; */
    *rtd_Premix_Freeze_CS = false;
}

/* Output and update for function-call system: '<S1085>/control' */
void Model_Target_control_c(const real32_T rtu_target_gains_linear[77], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_Premix_Freeze_Right,
    real32_T rtd_Premix_currentGain_Right[77], int32_T
    rtd_Premix_frameCount_Right[77], real32_T rtd_Premix_rampCoeff_Right[77],
    real32_T rtd_Premix_targetGain_Right[77])
{
    int32_T k;
    real32_T currentgain[77];
    real32_T diff[77];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Ramper/control': '<S1091>:1' */
    /* '<S1091>:1:10' dim_rgain = size(Premix_currentGain_Right); */
    /* '<S1091>:1:11' rgain_SILENT_GAIN_mat = (MedusaPremixConfig.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1091>:1:15' Premix_Freeze_Right(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1091>:1:24' currentgain = max(Premix_currentGain_Right, rgain_SILENT_GAIN_mat); */
    /* '<S1091>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1091>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 77; k++)
    {
        currentgain[k] = fmaxf(rtd_Premix_currentGain_Right[k], 1.1920929E-7F);
        rtd_Premix_rampCoeff_Right[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1091>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1091>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1091>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1091>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1091>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 77; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_Premix_rampCoeff_Right[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1091>:1:43' quantum_ms = 1000 * (MedusaPremixConfig.frame_size) / (MedusaPremixConfig.sample_rate_in_hertz); */
    /* '<S1091>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1091>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1091>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1091>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1091>:1:63' Premix_frameCount_Right  = int32(numFrames); */
    /* '<S1091>:1:64' Premix_rampCoeff_Right   = single(RampCoef); */
    /* '<S1091>:1:65' Premix_targetGain_Right  = target_gains_linear; */
    /* '<S1091>:1:66' Premix_currentGain_Right = currentgain; */
    for (k = 0; k < 77; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_Premix_rampCoeff_Right[k] = qhmath_div_f
            (rtd_Premix_rampCoeff_Right[k], currentgain_0);
        rtd_Premix_rampCoeff_Right[k] = qhmath_log_f
            (rtd_Premix_rampCoeff_Right[k]);
        rtd_Premix_rampCoeff_Right[k] = qhmath_div_f
            (rtd_Premix_rampCoeff_Right[k], numFrames);
        rtd_Premix_rampCoeff_Right[k] = qhmath_exp_f
            (rtd_Premix_rampCoeff_Right[k]);
        rtd_Premix_frameCount_Right[k] = (int32_T)roundf(numFrames);
        rtd_Premix_targetGain_Right[k] = rtu_target_gains_linear[k];
        rtd_Premix_currentGain_Right[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1091>:1:69' Premix_Freeze_Right(1) = false; */
    *rtd_Premix_Freeze_Right = false;
}

/* Output and update for function-call system: '<S1074>/Target Gain Computation' */
void Model_Target_TargetGainComputation(const real32_T rtu_minGain_Left[77],
    const real32_T rtu_detentGain_Left[77], const real32_T rtu_maxGain_Left[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Left[77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Target Gain Computation': '<S1082>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1082>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1082>:1:20' targetGain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_SLCGain_Left[0], &rtu_minGain_Left[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_SLCGain_Left[0], &rtu_detentGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_SLCGain_Left[0], &rtu_maxGain_Left[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_SLCGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_Premix_SLCGain_Left[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Left[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1082>:1:22' Premix_SLCGain_Left = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1062>/Target Gain Computation' */
void Model_Target_TargetGainComputation_b(const real32_T rtu_minGain_CS[20],
    const real32_T rtu_detentGain_CS[20], const real32_T rtu_maxGain_CS[20],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_CS[20])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Target Gain Computation': '<S1070>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1070>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1070>:1:20' targetGain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_SLCGain_CS[0], &rtu_minGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_SLCGain_CS[0], &rtu_detentGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_SLCGain_CS[0], &rtu_maxGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 20; i++)
                {
                    rtd_Premix_SLCGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 20; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_Premix_SLCGain_CS[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_CS[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1070>:1:22' Premix_SLCGain_CS = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1086>/Target Gain Computation' */
void Model_Target_TargetGainComputation_e(const real32_T rtu_minGain_Right[77],
    const real32_T rtu_detentGain_Right[77], const real32_T rtu_maxGain_Right[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Right[77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Target Gain Computation': '<S1094>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1094>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1094>:1:20' targetGain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_SLCGain_Right[0], &rtu_minGain_Right[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_SLCGain_Right[0], &rtu_detentGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_SLCGain_Right[0], &rtu_maxGain_Right[0], 77U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_SLCGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_Premix_SLCGain_Right[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Right[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1094>:1:22' Premix_SLCGain_Right = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S965>/Target Gain Computation' */
void Model_Target_TargetGainComputation_ex(const real32_T rtu_minGain_Left[30],
    const real32_T rtu_detentGain_Left[30], const real32_T rtu_maxGain_Left[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Left[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Target Gain Computation': '<S973>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S973>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S973>:1:20' targetGain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_SLCGain_Left[0], &rtu_minGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_SLCGain_Left[0], &rtu_detentGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_SLCGain_Left[0], &rtu_maxGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_SLCGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_FRM_SLCGain_Left[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_Left[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S973>:1:22' FRM_SLCGain_Left = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S953>/Target Gain Computation' */
void Model_Target_TargetGainComputation_l(const real32_T rtu_minGain_CS[12],
    const real32_T rtu_detentGain_CS[12], const real32_T rtu_maxGain_CS[12],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_CS[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Target Gain Computation': '<S961>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S961>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S961>:1:20' targetGain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_SLCGain_CS[i] = rtu_minGain_CS[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_SLCGain_CS[i] = rtu_detentGain_CS[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_SLCGain_CS[i] = rtu_maxGain_CS[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_FRM_SLCGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_FRM_SLCGain_CS[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_CS[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S961>:1:22' FRM_SLCGain_CS = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S977>/Target Gain Computation' */
void Model_Target_TargetGainComputation_j(const real32_T rtu_minGain_Right[30],
    const real32_T rtu_detentGain_Right[30], const real32_T rtu_maxGain_Right[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Right[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Target Gain Computation': '<S985>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S985>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S985>:1:20' targetGain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_SLCGain_Right[0], &rtu_minGain_Right[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_SLCGain_Right[0], &rtu_detentGain_Right[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_SLCGain_Right[0], &rtu_maxGain_Right[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_SLCGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_FRM_SLCGain_Right[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_Right[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S985>:1:22' FRM_SLCGain_Right = targetGain; */
    /*      gain_out = targetGain; */
}

/* Output and update for function-call system: '<S1144>/Target Gain Computation' */
void Model_Target_TargetGainComputation_k(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSDrv_SLCGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Surround Level Control/Target Gain Computation': '<S1150>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1150>:1:7' targetGain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_SLCGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_SLCGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_SLCGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSDrv_SLCGain[i] = (rtu_maxGain[i] - rtu_minGain[i]) *
                        position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSDrv_SLCGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1150>:1:9' VLSDrv_SLCGain = targetGain; */
}

/* Output and update for function-call system: '<S1169>/Target Gain Computation' */
void Model_Target_TargetGainComputation_g(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSPax_SLCGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Surround Level Control/Target Gain Computation': '<S1175>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1175>:1:7' targetGain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_SLCGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_SLCGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_SLCGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSPax_SLCGain[i] = (rtu_maxGain[i] - rtu_minGain[i]) *
                        position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSPax_SLCGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /* '<S1175>:1:9' VLSPax_SLCGain = targetGain; */
}

/* Output and update for function-call system: '<S1113>/REQ' */
void HandleReqPreAmpMedusaSurroundLevelControlIndex(void)
{
    /* MATLAB Function: '<S1074>/Target Gain Computation' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1120>:1' */
    /* '<S1120>:1:3' go(); */
    Model_Target_TargetGainComputation
        (&(Model_Target_PreAmp_p5_b0.MedusaPremixMinLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixDetentLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixMaxLevel_Left[0]),
         Model_Target_PreAmp_p5_b0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left);

    /* MATLAB Function: '<S1062>/Target Gain Computation' */
    Model_Target_TargetGainComputation_b
        (&(Model_Target_PreAmp_p5_b0.MedusaPremixMinLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixDetentLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixMaxLevel_CS[0]),
         Model_Target_PreAmp_p5_b0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS);

    /* MATLAB Function: '<S1086>/Target Gain Computation' */
    Model_Target_TargetGainComputation_e
        (&(Model_Target_PreAmp_p5_b0.MedusaPremixMinLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixDetentLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixMaxLevel_Right[0]),
         Model_Target_PreAmp_p5_b0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right);

    /* MATLAB Function: '<S965>/Target Gain Computation' */
    Model_Target_TargetGainComputation_ex
        (&(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMinLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDetentLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMaxLevel_Left[0]),
         Model_Target_PreAmp_p5_b0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left);

    /* MATLAB Function: '<S953>/Target Gain Computation' */
    Model_Target_TargetGainComputation_l
        (&(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMinLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDetentLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMaxLevel_CS[0]),
         Model_Target_PreAmp_p5_b0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS);

    /* MATLAB Function: '<S977>/Target Gain Computation' */
    Model_Target_TargetGainComputation_j
        (&(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMinLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDetentLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMaxLevel_Right[0]),
         Model_Target_PreAmp_p5_b0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right);

    /* MATLAB Function: '<S1144>/Target Gain Computation' */
    Model_Target_TargetGainComputation_k
        (&(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsMinLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsDetentLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsMaxLevel[0]),
         Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain);

    /* MATLAB Function: '<S1169>/Target Gain Computation' */
    Model_Target_TargetGainComputation_g
        (&(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsMinLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsDetentLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsMaxLevel[0]),
         Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain);

    /* MATLAB Function: '<S1111>/MATLAB Function' */
    /* MATLAB Function 'Surround Level Control Generic/Detect SLC REQ/MATLAB Function': '<S1115>:1' */
    /*  Increment the trigger count everytime the SLC is triggered. The changes */
    /*  in this count are tracked to update a boolean indicator of whether the */
    /*  SLC trigger. */
    /* '<S1115>:1:9' TriggerCount = TriggerCount+1; */
    Model_Target_Medusa5H1Part3_DW.TriggerCount++;
}

/* Output and update for function-call system: '<S1074>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL(const real32_T rtu_minGain_Left[77],
    const real32_T rtu_detentGain_Left[77], const real32_T rtu_maxGain_Left[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Left[77], real32_T rtd_Premix_currentGain_Left[77],
    int32_T rtd_Premix_frameCount_Left[77], real32_T rtd_Premix_targetGain_Left
    [77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Initialization and RMDL': '<S1081>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1081>:1:9' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1081>:1:23' gain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_currentGain_Left[0], &rtu_minGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_currentGain_Left[0], &rtu_detentGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_currentGain_Left[0], &rtu_maxGain_Left[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_currentGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_Premix_currentGain_Left[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Left[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1081>:1:27' Premix_currentGain_Left = gain; */
    /* '<S1081>:1:28' Premix_targetGain_Left = gain; */
    /* '<S1081>:1:29' Premix_SLCGain_Left = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1081>:1:32' Premix_frameCount_Left = zeros(size(Premix_currentGain_Left), 'int32'); */
    for (i = 0; i < 77; i++)
    {
        rtd_Premix_targetGain_Left[i] = rtd_Premix_currentGain_Left[i];
        rtd_Premix_SLCGain_Left[i] = rtd_Premix_currentGain_Left[i];
        rtd_Premix_frameCount_Left[i] = 0;
    }
}

/* Output and update for function-call system: '<S1062>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_f(const real32_T rtu_minGain_CS[20],
    const real32_T rtu_detentGain_CS[20], const real32_T rtu_maxGain_CS[20],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_CS[20], real32_T rtd_Premix_currentGain_CS[20], int32_T
    rtd_Premix_frameCount_CS[20], real32_T rtd_Premix_targetGain_CS[20])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Initialization and RMDL': '<S1069>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1069>:1:9' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1069>:1:23' gain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_currentGain_CS[0], &rtu_minGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_currentGain_CS[0], &rtu_detentGain_CS[0], 20U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_currentGain_CS[0], &rtu_maxGain_CS[0], 20U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 20; i++)
                {
                    rtd_Premix_currentGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 20; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_Premix_currentGain_CS[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_CS[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1069>:1:27' Premix_currentGain_CS = gain; */
    /* '<S1069>:1:28' Premix_targetGain_CS = gain; */
    /* '<S1069>:1:29' Premix_SLCGain_CS = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1069>:1:32' Premix_frameCount_CS = zeros(size(Premix_currentGain_CS), 'int32'); */
    for (i = 0; i < 20; i++)
    {
        rtd_Premix_targetGain_CS[i] = rtd_Premix_currentGain_CS[i];
        rtd_Premix_SLCGain_CS[i] = rtd_Premix_currentGain_CS[i];
        rtd_Premix_frameCount_CS[i] = 0;
    }
}

/* Output and update for function-call system: '<S1086>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_n(const real32_T rtu_minGain_Right[77],
    const real32_T rtu_detentGain_Right[77], const real32_T rtu_maxGain_Right[77],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_Premix_SLCGain_Right[77], real32_T rtd_Premix_currentGain_Right[77],
    int32_T rtd_Premix_frameCount_Right[77], real32_T
    rtd_Premix_targetGain_Right[77])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Initialization and RMDL': '<S1093>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S1093>:1:9' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1093>:1:23' gain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaPremixConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_Premix_currentGain_Right[0], &rtu_minGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_Premix_currentGain_Right[0], &rtu_detentGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_Premix_currentGain_Right[0], &rtu_maxGain_Right[0], 77U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 77; i++)
                {
                    rtd_Premix_currentGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 77; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_Premix_currentGain_Right[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Right[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1093>:1:27' Premix_currentGain_Right = gain; */
    /* '<S1093>:1:28' Premix_targetGain_Right = gain; */
    /* '<S1093>:1:29' Premix_SLCGain_Right = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1093>:1:32' Premix_frameCount_Right = zeros(size(Premix_currentGain_Right), 'int32'); */
    for (i = 0; i < 77; i++)
    {
        rtd_Premix_targetGain_Right[i] = rtd_Premix_currentGain_Right[i];
        rtd_Premix_SLCGain_Right[i] = rtd_Premix_currentGain_Right[i];
        rtd_Premix_frameCount_Right[i] = 0;
    }
}

/* Output and update for function-call system: '<S965>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_o(const real32_T rtu_minGain_Left[30],
    const real32_T rtu_detentGain_Left[30], const real32_T rtu_maxGain_Left[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Left[30], real32_T rtd_FRM_currentGain_Left[30], int32_T
    rtd_FRM_frameCount_Left[30], real32_T rtd_FRM_targetGain_Left[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Surround Level Control/Initialization and RMDL': '<S972>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S972>:1:9' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S972>:1:23' gain = MedusaPremixGainComputation(minGain_Left, detentGain_Left, maxGain_Left, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_currentGain_Left[0], &rtu_minGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_currentGain_Left[0], &rtu_detentGain_Left[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_currentGain_Left[0], &rtu_maxGain_Left[0], 30U * sizeof
               (real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_currentGain_Left[i] = (rtu_maxGain_Left[i] -
                        rtu_minGain_Left[i]) * position + rtu_minGain_Left[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_Left[i],
                        1.1920929E-7F));
                    rtd_FRM_currentGain_Left[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Left[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S972>:1:27' FRM_currentGain_Left = gain; */
    /* '<S972>:1:28' FRM_targetGain_Left = gain; */
    /* '<S972>:1:29' FRM_SLCGain_Left = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S972>:1:32' FRM_frameCount_Left = zeros(size(FRM_currentGain_Left), 'int32'); */
    for (i = 0; i < 30; i++)
    {
        rtd_FRM_targetGain_Left[i] = rtd_FRM_currentGain_Left[i];
        rtd_FRM_SLCGain_Left[i] = rtd_FRM_currentGain_Left[i];
        rtd_FRM_frameCount_Left[i] = 0;
    }
}

/* Output and update for function-call system: '<S953>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_k(const real32_T rtu_minGain_CS[12],
    const real32_T rtu_detentGain_CS[12], const real32_T rtu_maxGain_CS[12],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_CS[12], real32_T rtd_FRM_currentGain_CS[12], int32_T
    rtd_FRM_frameCount_CS[12], real32_T rtd_FRM_targetGain_CS[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Surround Level Control/Initialization and RMDL': '<S960>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S960>:1:9' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S960>:1:23' gain = MedusaPremixGainComputation(minGain_CS, detentGain_CS, maxGain_CS, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_currentGain_CS[i] = rtu_minGain_CS[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_currentGain_CS[i] = rtu_detentGain_CS[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_FRM_currentGain_CS[i] = rtu_maxGain_CS[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_FRM_currentGain_CS[i] = (rtu_maxGain_CS[i] -
                        rtu_minGain_CS[i]) * position + rtu_minGain_CS[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain_CS[i],
                        1.1920929E-7F));
                    rtd_FRM_currentGain_CS[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain_CS[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S960>:1:27' FRM_currentGain_CS = gain; */
    /* '<S960>:1:28' FRM_targetGain_CS = gain; */
    /* '<S960>:1:29' FRM_SLCGain_CS = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S960>:1:32' FRM_frameCount_CS = zeros(size(FRM_currentGain_CS), 'int32'); */
    for (i = 0; i < 12; i++)
    {
        rtd_FRM_targetGain_CS[i] = rtd_FRM_currentGain_CS[i];
        rtd_FRM_SLCGain_CS[i] = rtd_FRM_currentGain_CS[i];
        rtd_FRM_frameCount_CS[i] = 0;
    }
}

/* Output and update for function-call system: '<S977>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_ou(const real32_T rtu_minGain_Right[30],
    const real32_T rtu_detentGain_Right[30], const real32_T rtu_maxGain_Right[30],
    real32_T rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_FRM_SLCGain_Right[30], real32_T rtd_FRM_currentGain_Right[30], int32_T
    rtd_FRM_frameCount_Right[30], real32_T rtd_FRM_targetGain_Right[30])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Surround Level Control/Initialization and RMDL': '<S984>:1' */
    /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
    /* '<S984>:1:9' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S984>:1:23' gain = MedusaPremixGainComputation(minGain_Right, detentGain_Right, maxGain_Right, interpolation_method, surr_level, MedusaFRMConfig); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        memcpy(&rtd_FRM_currentGain_Right[0], &rtu_minGain_Right[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        memcpy(&rtd_FRM_currentGain_Right[0], &rtu_detentGain_Right[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        memcpy(&rtd_FRM_currentGain_Right[0], &rtu_maxGain_Right[0], 30U *
               sizeof(real32_T));

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 30; i++)
                {
                    rtd_FRM_currentGain_Right[i] = (rtu_maxGain_Right[i] -
                        rtu_minGain_Right[i]) * position + rtu_minGain_Right[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 30; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf
                        (rtu_minGain_Right[i], 1.1920929E-7F));
                    rtd_FRM_currentGain_Right[i] = qhmath_pow_f(10.0F,
                        qhmath_div_f((20.0F * qhmath_log10_f(fmaxf
                        (rtu_maxGain_Right[i], 1.1920929E-7F)) - minGain_dB) *
                                     position + minGain_dB, 20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S984>:1:27' FRM_currentGain_Right = gain; */
    /* '<S984>:1:28' FRM_targetGain_Right = gain; */
    /* '<S984>:1:29' FRM_SLCGain_Right = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S984>:1:32' FRM_frameCount_Right = zeros(size(FRM_currentGain_Right), 'int32'); */
    for (i = 0; i < 30; i++)
    {
        rtd_FRM_targetGain_Right[i] = rtd_FRM_currentGain_Right[i];
        rtd_FRM_SLCGain_Right[i] = rtd_FRM_currentGain_Right[i];
        rtd_FRM_frameCount_Right[i] = 0;
    }
}

/* Output and update for function-call system: '<S1144>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_o4(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSDrv_SLCGain[12], real32_T rtd_VLSDrv_currentGain[12], int32_T
    rtd_VLSDrv_frameCount[12], real32_T rtd_VLSDrv_targetGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Surround Level Control/Initialization and RMDL': '<S1149>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1149>:1:10' gain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_currentGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_currentGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSDrv_currentGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSDrv_currentGain[i] = (rtu_maxGain[i] - rtu_minGain[i])
                        * position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSDrv_currentGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1149>:1:14' VLSDrv_currentGain = gain; */
    /* '<S1149>:1:15' VLSDrv_targetGain = gain; */
    /* '<S1149>:1:16' VLSDrv_SLCGain = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1149>:1:19' VLSDrv_frameCount = zeros(size(VLSDrv_currentGain), 'int32'); */
    for (i = 0; i < 12; i++)
    {
        rtd_VLSDrv_targetGain[i] = rtd_VLSDrv_currentGain[i];
        rtd_VLSDrv_SLCGain[i] = rtd_VLSDrv_currentGain[i];
        rtd_VLSDrv_frameCount[i] = 0;
    }
}

/* Output and update for function-call system: '<S1169>/Initialization and RMDL' */
void Model_Target_InitializationandRMDL_b(const real32_T rtu_minGain[12], const
    real32_T rtu_detentGain[12], const real32_T rtu_maxGain[12], real32_T
    rtu_interpolation_method, uint32_T rtu_surr_level, real32_T
    rtd_VLSPax_SLCGain[12], real32_T rtd_VLSPax_currentGain[12], int32_T
    rtd_VLSPax_frameCount[12], real32_T rtd_VLSPax_targetGain[12])
{
    int32_T i;
    int32_T tmp;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Surround Level Control/Initialization and RMDL': '<S1174>:1' */
    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* '<S1174>:1:10' gain = MedusaPremixGainComputation(minGain, detentGain, maxGain, interpolation_method, surr_level, configStruct); */
    /*  #codegen */
    /*  Extracting the surround level indices correponding to the anchor */
    /*  points from the specified Config Struct */
    /* 'MedusaPremixGainComputation:5' midIndex = ceil(length(ConfigStruct.granularity)/2); */
    /* 'MedusaPremixGainComputation:7' min_level = ConfigStruct.granularity(1); */
    /* 'MedusaPremixGainComputation:8' detent_level = ConfigStruct.granularity(midIndex); */
    /* 'MedusaPremixGainComputation:9' max_level = ConfigStruct.granularity(end); */
    /*  Performing bound check on Surround Level value */
    /* 'MedusaPremixGainComputation:12' surroundLevel = min(surroundLevel, max_level); */
    if (rtu_surr_level > 255U)
    {
        i = 255;
    }
    else
    {
        i = (int32_T)rtu_surr_level;
    }

    /*  Computing the 'surround' part of mixing gains depending on the surround */
    /*  level index; The other part of mixing gain comes from 'fade downmix' */
    /* 'MedusaPremixGainComputation:16' switch surroundLevel */
    if ((uint32_T)i == 0U)
    {
        tmp = 0;
    }
    else if ((uint32_T)i == 128U)
    {
        tmp = 1;
    }
    else if ((uint32_T)i == 255U)
    {
        tmp = 2;
    }
    else
    {
        tmp = -1;
    }

    switch (tmp)
    {
      case 0:
        /* 'MedusaPremixGainComputation:17' case min_level */
        /* 'MedusaPremixGainComputation:18' targetGain = minGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_currentGain[i] = rtu_minGain[i];
        }

        /*  when surround index corresponds to 'min' anchor point */
        break;

      case 1:
        /* 'MedusaPremixGainComputation:19' case detent_level */
        /* 'MedusaPremixGainComputation:20' targetGain = detentGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_currentGain[i] = rtu_detentGain[i];
        }

        /*  when surround index corresponds to 'detent' anchor point */
        break;

      case 2:
        /* 'MedusaPremixGainComputation:21' case max_level */
        /* 'MedusaPremixGainComputation:22' targetGain = maxGain; */
        for (i = 0; i < 12; i++)
        {
            rtd_VLSPax_currentGain[i] = rtu_maxGain[i];
        }

        /*  when surround index corresponds to 'max' anchor point */
        break;

      default:
        {
            real32_T position;

            /* 'MedusaPremixGainComputation:23' otherwise */
            /* 'MedusaPremixGainComputation:24' position = (single(surroundLevel) - min_level)/(max_level - min_level); */
            position = qhmath_div_f((real32_T)i, 255.0F);

            /*  when surround index lies in between the anchor points */
            /* 'MedusaPremixGainComputation:25' if (interpolationMethod(1) == 0) */
            if (rtu_interpolation_method == 0.0F)
            {
                /* 'MedusaPremixGainComputation:26' targetGain = (maxGain - minGain)*position + minGain; */
                for (i = 0; i < 12; i++)
                {
                    rtd_VLSPax_currentGain[i] = (rtu_maxGain[i] - rtu_minGain[i])
                        * position + rtu_minGain[i];
                }

                /*  Linear Interpolation */
            }
            else
            {
                /* 'MedusaPremixGainComputation:27' else */
                /* 'MedusaPremixGainComputation:28' minGain_dB = 20*log10(max(minGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:29' maxGain_dB = 20*log10(max(maxGain, eps('single'))); */
                /* 'MedusaPremixGainComputation:30' targetGain_dB = (maxGain_dB - minGain_dB)*position + minGain_dB; */
                /* 'MedusaPremixGainComputation:31' targetGain = 10.^(targetGain_dB/20); */
                for (i = 0; i < 12; i++)
                {
                    real32_T minGain_dB;
                    minGain_dB = 20.0F * qhmath_log10_f(fmaxf(rtu_minGain[i],
                        1.1920929E-7F));
                    rtd_VLSPax_currentGain[i] = qhmath_pow_f(10.0F, qhmath_div_f
                        ((20.0F * qhmath_log10_f(fmaxf(rtu_maxGain[i],
                        1.1920929E-7F)) - minGain_dB) * position + minGain_dB,
                         20.0F));
                }

                /*  dB-Linear Interpolation */
            }
        }
        break;
    }

    /*  Ramping doesn't take place during RMDL and cold start. Hence, gains */
    /*  are directly pushed to mixing matrix */
    /* '<S1174>:1:14' VLSPax_currentGain = gain; */
    /* '<S1174>:1:15' VLSPax_targetGain = gain; */
    /* '<S1174>:1:16' VLSPax_SLCGain = gain; */
    /*  Resetting the frame count to zero to avoid unintentional ramping */
    /* '<S1174>:1:19' VLSPax_frameCount = zeros(size(VLSPax_currentGain), 'int32'); */
    for (i = 0; i < 12; i++)
    {
        rtd_VLSPax_targetGain[i] = rtd_VLSPax_currentGain[i];
        rtd_VLSPax_SLCGain[i] = rtd_VLSPax_currentGain[i];
        rtd_VLSPax_frameCount[i] = 0;
    }
}

/* Output and update for function-call system: '<S1114>/REQ' */
void HandleReqPreAmpMedusaSurroundLevelControlReset(void)
{
    /* MATLAB Function: '<S1074>/Initialization and RMDL' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1126>:1' */
    /* '<S1126>:1:3' go(); */
    Model_Target_InitializationandRMDL
        (&(Model_Target_PreAmp_p5_b0.MedusaPremixMinLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixDetentLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixMaxLevel_Left[0]),
         Model_Target_PreAmp_p5_b0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left,
         Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left,
         Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Left,
         Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left);

    /* MATLAB Function: '<S1062>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_f
        (&(Model_Target_PreAmp_p5_b0.MedusaPremixMinLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixDetentLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixMaxLevel_CS[0]),
         Model_Target_PreAmp_p5_b0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS,
         Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS,
         Model_Target_Medusa5H1Part3_DW.Premix_frameCount_CS,
         Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS);

    /* MATLAB Function: '<S1086>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_n
        (&(Model_Target_PreAmp_p5_b0.MedusaPremixMinLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixDetentLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaPremixMaxLevel_Right[0]),
         Model_Target_PreAmp_p5_b0.MedusaPremixInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right,
         Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right,
         Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Right,
         Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right);

    /* MATLAB Function: '<S965>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_o
        (&(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMinLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDetentLevel_Left[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMaxLevel_Left[0]),
         Model_Target_PreAmp_p5_b0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left,
         Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left,
         Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Left,
         Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left);

    /* MATLAB Function: '<S953>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_k
        (&(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMinLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDetentLevel_CS[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMaxLevel_CS[0]),
         Model_Target_PreAmp_p5_b0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS,
         Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS,
         Model_Target_Medusa5H1Part3_DW.FRM_frameCount_CS,
         Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS);

    /* MATLAB Function: '<S977>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_ou
        (&(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMinLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDetentLevel_Right[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaFullRateMixerMaxLevel_Right[0]),
         Model_Target_PreAmp_p5_b0.MedusaFullRateMixerInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right,
         Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right,
         Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Right,
         Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right);

    /* MATLAB Function: '<S1144>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_o4
        (&(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsMinLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsDetentLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsMaxLevel[0]),
         Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_frameCount,
         Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain);

    /* MATLAB Function: '<S1169>/Initialization and RMDL' */
    Model_Target_InitializationandRMDL_b
        (&(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsMinLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsDetentLevel[0]),
         &(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsMaxLevel[0]),
         Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsInterpolation_Method,
         Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_surround_index,
         Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain,
         Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain,
         Model_Target_Medusa5H1Part3_DW.VLSPax_frameCount,
         Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain);
}

/*
 * Output and update for atomic system:
 *    '<S1131>/Fade_Trigger_Generation'
 *    '<S1156>/Fade_Trigger_Generation'
 */
void Model_Target_Fade_Trigger_Generation(real32_T rtu_gainDifference, const
    real32_T rtu_1[12], real32_T rtu_2, real32_T rtu_3, real32_T rtu_4, real32_T
    rtu_5, real32_T rtu_6, real32_T rtu_7,
    B_Fade_Trigger_Generation_Model_Target_T *localB)
{
    int32_T i;

    /*  #codegen */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Fade Inputs/Fade_Trigger_Generation': '<S1136>:1' */
    /* '<S1136>:1:3' fadeOn = false; */
    localB->fadeOn = false;

    /*  Generates function call triggers when incoming fade gain values change */
    /* '<S1136>:1:6' if(gainDifference > 0) */
    if (rtu_gainDifference > 0.0F)
    {
        /* Outputs for Function Call SubSystem: '<S1133>/Fader Downmix' */
        /* MATLAB Function: '<S1142>/MATLAB Function' */
        /* '<S1136>:1:7' fadeTrigger(); */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Fader Downmix/MATLAB Function': '<S1145>:1' */
        /* '<S1145>:1:4' if (forwardGain >= backwardGain) */
        if (rtu_2 >= rtu_5)
        {
            /* '<S1145>:1:5' downmix = (1 - min(backwardGain, forwardDownmixThreshold) / max(forwardDownmixThreshold, single(eps)))... */
            /* '<S1145>:1:6'         * forwardDownmixMax; */
            localB->downmix = (1.0F - qhmath_div_f(fminf(rtu_5, rtu_3), fmaxf
                                (rtu_3, 2.22044605E-16F))) * rtu_4;
        }
        else
        {
            /* '<S1145>:1:7' else */
            /* '<S1145>:1:8' downmix = (1 - min(forwardGain, backwardDownmixThreshold) / max(backwardDownmixThreshold, single(eps)))... */
            /* '<S1145>:1:9'         * backwardDownmixMax; */
            localB->downmix = (1.0F - qhmath_div_f(fminf(rtu_2, rtu_6), fmaxf
                                (rtu_6, 2.22044605E-16F))) * rtu_7;
        }

        /* End of MATLAB Function: '<S1142>/MATLAB Function' */
        for (i = 0; i < 12; i++)
        {
            /* Product: '<S1142>/Matrix Multiply' */
            localB->MatrixMultiply[i] = localB->downmix * rtu_1[i];
        }

        /* End of Outputs for SubSystem: '<S1133>/Fader Downmix' */
        /* '<S1136>:1:8' fadeOn = true; */
        localB->fadeOn = true;

        /*  Indicates that fade is triggered */
    }
}

/* Output and update for atomic system: '<S1143>/process' */
void Model_Target_process_c(const boolean_T *rtd_VLSDrv_Freeze, real32_T
    rtd_VLSDrv_currentGain[12], int32_T rtd_VLSDrv_frameCount[12], const
    real32_T rtd_VLSDrv_rampCoeff[12], const real32_T rtd_VLSDrv_targetGain[12])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/process': '<S1148>:1' */
    /* '<S1148>:1:10' for i = 1:numel(VLSDrv_currentGain) */
    for (i = 0; i < 12; i++)
    {
        /* '<S1148>:1:11' if (VLSDrv_Freeze(1) == false) */
        if (!*rtd_VLSDrv_Freeze)
        {
            /* '<S1148>:1:12' if (VLSDrv_frameCount(i) == 0) */
            if (rtd_VLSDrv_frameCount[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1148>:1:14' VLSDrv_currentGain(i) = VLSDrv_targetGain(i); */
                rtd_VLSDrv_currentGain[i] = rtd_VLSDrv_targetGain[i];
            }
            else
            {
                /* '<S1148>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1148>:1:17' VLSDrv_currentGain(i) = VLSDrv_currentGain(i)*VLSDrv_rampCoeff(i); */
                rtd_VLSDrv_currentGain[i] *= rtd_VLSDrv_rampCoeff[i];

                /* '<S1148>:1:18' VLSDrv_frameCount(i) = VLSDrv_frameCount(i) - 1; */
                rtd_VLSDrv_frameCount[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1143>/control' */
void Model_Target_control_as(const real32_T rtu_target_gains_linear[12],
    uint32_T rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_VLSDrv_Freeze,
    real32_T rtd_VLSDrv_currentGain[12], int32_T rtd_VLSDrv_frameCount[12],
    real32_T rtd_VLSDrv_rampCoeff[12], real32_T rtd_VLSDrv_targetGain[12])
{
    int32_T k;
    real32_T currentgain[12];
    real32_T diff[12];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/control': '<S1147>:1' */
    /* '<S1147>:1:10' dim_rgain = size(VLSDrv_currentGain); */
    /* '<S1147>:1:11' rgain_SILENT_GAIN_mat = (configStruct.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1147>:1:15' VLSDrv_Freeze(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1147>:1:24' currentgain = max(VLSDrv_currentGain, rgain_SILENT_GAIN_mat); */
    /* '<S1147>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1147>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 12; k++)
    {
        currentgain[k] = fmaxf(rtd_VLSDrv_currentGain[k], 1.1920929E-7F);
        rtd_VLSDrv_rampCoeff[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1147>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1147>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1147>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1147>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1147>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 12; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_VLSDrv_rampCoeff[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1147>:1:43' quantum_ms = 1000 * (configStruct.frame_size) / (configStruct.sample_rate_in_hertz); */
    /* '<S1147>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1147>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1147>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1147>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1147>:1:63' VLSDrv_frameCount  = int32(numFrames); */
    /* '<S1147>:1:64' VLSDrv_rampCoeff   = single(RampCoef); */
    /* '<S1147>:1:65' VLSDrv_targetGain  = target_gains_linear; */
    /* '<S1147>:1:66' VLSDrv_currentGain = currentgain; */
    for (k = 0; k < 12; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_VLSDrv_rampCoeff[k] = qhmath_div_f(rtd_VLSDrv_rampCoeff[k],
            currentgain_0);
        rtd_VLSDrv_rampCoeff[k] = qhmath_log_f(rtd_VLSDrv_rampCoeff[k]);
        rtd_VLSDrv_rampCoeff[k] = qhmath_div_f(rtd_VLSDrv_rampCoeff[k],
            numFrames);
        rtd_VLSDrv_rampCoeff[k] = qhmath_exp_f(rtd_VLSDrv_rampCoeff[k]);
        rtd_VLSDrv_frameCount[k] = (int32_T)numFrames;
        rtd_VLSDrv_targetGain[k] = rtu_target_gains_linear[k];
        rtd_VLSDrv_currentGain[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1147>:1:69' VLSDrv_Freeze(1) = false; */
    *rtd_VLSDrv_Freeze = false;
}

/* Output and update for atomic system: '<S1168>/process' */
void Model_Target_process_e(const boolean_T *rtd_VLSPax_Freeze, real32_T
    rtd_VLSPax_currentGain[12], int32_T rtd_VLSPax_frameCount[12], const
    real32_T rtd_VLSPax_rampCoeff[12], const real32_T rtd_VLSPax_targetGain[12])
{
    int32_T i;

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Ramper/process': '<S1173>:1' */
    /* '<S1173>:1:10' for i = 1:numel(VLSPax_currentGain) */
    for (i = 0; i < 12; i++)
    {
        /* '<S1173>:1:11' if (VLSPax_Freeze(1) == false) */
        if (!*rtd_VLSPax_Freeze)
        {
            /* '<S1173>:1:12' if (VLSPax_frameCount(i) == 0) */
            if (rtd_VLSPax_frameCount[i] == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S1173>:1:14' VLSPax_currentGain(i) = VLSPax_targetGain(i); */
                rtd_VLSPax_currentGain[i] = rtd_VLSPax_targetGain[i];
            }
            else
            {
                /* '<S1173>:1:15' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S1173>:1:17' VLSPax_currentGain(i) = VLSPax_currentGain(i)*VLSPax_rampCoeff(i); */
                rtd_VLSPax_currentGain[i] *= rtd_VLSPax_rampCoeff[i];

                /* '<S1173>:1:18' VLSPax_frameCount(i) = VLSPax_frameCount(i) - 1; */
                rtd_VLSPax_frameCount[i]--;
            }
        }
    }
}

/* Output and update for function-call system: '<S1168>/control' */
void Model_Target_control_j(const real32_T rtu_target_gains_linear[12], uint32_T
    rtu_rampRate, uint32_T rtu_rampTime, boolean_T *rtd_VLSPax_Freeze, real32_T
    rtd_VLSPax_currentGain[12], int32_T rtd_VLSPax_frameCount[12], real32_T
    rtd_VLSPax_rampCoeff[12], real32_T rtd_VLSPax_targetGain[12])
{
    int32_T k;
    real32_T currentgain[12];
    real32_T diff[12];

    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Gain Computation/Ramper/control': '<S1172>:1' */
    /* '<S1172>:1:10' dim_rgain = size(VLSPax_currentGain); */
    /* '<S1172>:1:11' rgain_SILENT_GAIN_mat = (configStruct.rgain_SILENT_GAIN)*ones(dim_rgain); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. */
    /* '<S1172>:1:15' VLSPax_Freeze(1) = true; */
    /*  freeze the gain */
    /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
    /*  When this control set goes live, ensure that the current gain will move. */
    /*  If current gain is zero, replace with a value very close to zero. What we */
    /*  really want is a value which is on the edge of perception - not too small */
    /*  or large. If the value is too small, we'll waste some of our ramp time */
    /*  in perceived silence. If the value is too large, the audio will lurch */
    /*  into perceptability at the start of the ramp. */
    /* '<S1172>:1:24' currentgain = max(VLSPax_currentGain, rgain_SILENT_GAIN_mat); */
    /* '<S1172>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
    /*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
    /*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
    /*  that matches the slope. */
    /* '<S1172>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
    for (k = 0; k < 12; k++)
    {
        currentgain[k] = fmaxf(rtd_VLSPax_currentGain[k], 1.1920929E-7F);
        rtd_VLSPax_rampCoeff[k] = fmaxf(rtu_target_gains_linear[k],
            1.1920929E-7F);
        diff[k] = (real32_T)rtu_rampTime;
    }

    /* '<S1172>:1:32' if(~rampTime) */
    if (rtu_rampTime == 0U)
    {
        /* '<S1172>:1:33' currentGain_db = 20*log10(currentgain); */
        /* '<S1172>:1:34' targetGain_db = 20*log10(targetGain); */
        /* '<S1172>:1:35' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1172>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
        for (k = 0; k < 12; k++)
        {
            diff[k] = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                                    (currentgain[k]) - 20.0F * qhmath_log10_f
                                    (rtd_VLSPax_rampCoeff[k])), (real32_T)
                                   rtu_rampRate) * 1000.0F;
        }
    }

    /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
    /*  the whole number of frames required to best match requested ramp time. */
    /*  Ensure that at least one frame is used. The frame size will therefore */
    /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
    /* '<S1172>:1:43' quantum_ms = 1000 * (configStruct.frame_size) / (configStruct.sample_rate_in_hertz); */
    /* '<S1172>:1:44' numFrames = rampTime_ms / quantum_ms; */
    /* '<S1172>:1:45' numFrames = max (1, round(numFrames)); */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1172>:1:59' factor = log( targetGain ./ currentgain ); */
    /* '<S1172>:1:60' RampCoef = exp(factor ./ numFrames); */
    /*  Output control signals */
    /* '<S1172>:1:63' VLSPax_frameCount  = int32(numFrames); */
    /* '<S1172>:1:64' VLSPax_rampCoeff   = single(RampCoef); */
    /* '<S1172>:1:65' VLSPax_targetGain  = target_gains_linear; */
    /* '<S1172>:1:66' VLSPax_currentGain = currentgain; */
    for (k = 0; k < 12; k++)
    {
        real32_T currentgain_0;
        real32_T diff_0;
        real32_T numFrames;
        currentgain_0 = currentgain[k];
        diff_0 = roundf(qhmath_div_f(diff[k], 0.722222209F));
        numFrames = fmaxf(1.0F, diff_0);
        rtd_VLSPax_rampCoeff[k] = qhmath_div_f(rtd_VLSPax_rampCoeff[k],
            currentgain_0);
        rtd_VLSPax_rampCoeff[k] = qhmath_log_f(rtd_VLSPax_rampCoeff[k]);
        rtd_VLSPax_rampCoeff[k] = qhmath_div_f(rtd_VLSPax_rampCoeff[k],
            numFrames);
        rtd_VLSPax_rampCoeff[k] = qhmath_exp_f(rtd_VLSPax_rampCoeff[k]);
        rtd_VLSPax_frameCount[k] = (int32_T)numFrames;
        rtd_VLSPax_targetGain[k] = rtu_target_gains_linear[k];
        rtd_VLSPax_currentGain[k] = currentgain_0;
        diff[k] = diff_0;
    }

    /*  unfreeze the gain */
    /* '<S1172>:1:69' VLSPax_Freeze(1) = false; */
    *rtd_VLSPax_Freeze = false;
}

/* Output and update for function-call system: '<S889>/REQ' */
void HandleReqPreAmpMedusaPostUpmixDisable(void)
{
    /* Outputs for Function Call SubSystem: '<S587>/Enable State Write' */
    /* DataStoreWrite: '<S886>/Data Store Write' incorporates:
     *  Constant: '<S886>/Constant'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1184>:1' */
    /* '<S1184>:1:3' go(); */
    Model_Target_Medusa5H1Part3_DW.MedusaPostUpmixEnable = 0U;

    /* End of Outputs for SubSystem: '<S587>/Enable State Write' */
}

/* System initialize for atomic system: '<S558>/Medusa5H1 Part 3' */
void Model_Target_Medusa5H1Part3_Init(void)
{
    int32_T i;

    /* Start for If: '<S587>/If' */
    Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem = -1;

    /* Start for DataStoreMemory: '<S587>/Data Store Memory' */
    Model_Target_Medusa5H1Part3_DW.MedusaPostUpmixEnable = 1U;

    /* SystemInitialize for IfAction SubSystem: '<S587>/On' */

    /* user code (Initialize function Body) */

    // Trigger RTC request handler at init for '<S1114>/RTC Request Response Trigger'
    HandleReqPreAmpMedusaSurroundLevelControlReset();
    for (i = 0; i < 20; i++)
    {
        /* Start for DataStoreMemory: '<S1061>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1002>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1002>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1002>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[i] = 1.0F;
    }

    for (i = 0; i < 77; i++)
    {
        /* Start for DataStoreMemory: '<S1073>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1003>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1003>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1003>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1085>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1004>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1004>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1004>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right[i] = 1.0F;
    }

    for (i = 0; i < 12; i++)
    {
        /* Start for DataStoreMemory: '<S952>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_CS[i] = 1.0F;

        /* Start for DataStoreMemory: '<S934>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S934>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S934>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS[i] = 1.0E-5F;
    }

    for (i = 0; i < 30; i++)
    {
        /* Start for DataStoreMemory: '<S964>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Left[i] = 1.0F;

        /* Start for DataStoreMemory: '<S935>/Data Store Memory1' */
        Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S935>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S935>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S976>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Right[i] = 1.0F;

        /* Start for DataStoreMemory: '<S936>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S936>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S936>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i] = 1.0E-5F;
    }

    for (i = 0; i < 12; i++)
    {
        /* Start for DataStoreMemory: '<S1143>/Ramp Coeff' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_rampCoeff[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1133>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1133>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1133>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1168>/Ramp Coeff' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_rampCoeff[i] = 1.0F;

        /* Start for DataStoreMemory: '<S1158>/Data Store Memory2' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1158>/Data Store Memory3' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain[i] = 1.0E-5F;

        /* Start for DataStoreMemory: '<S1158>/Data Store Memory4' */
        Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain[i] = 1.0E-5F;
    }

    /* SystemInitialize for Enabled SubSystem: '<S999>/Mono-Surround' */

    /* Start for If: '<S1015>/If' */
    Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem_b = -1;

    /* Start for If: '<S1016>/If' */
    Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem_k = -1;

    /* SystemInitialize for IfAction SubSystem: '<S1015>/Hilbert SOS A' */

    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1031>/ITC1' */
    InitTrigger_Model_141_3728_59_192();

    /* InitTriggerControl '<S1023>/ITC1' */
    InitTrigger_Model_141_3728_59_156();

    /* End of SystemInitialize for SubSystem: '<S1015>/Hilbert SOS A' */

    /* SystemInitialize for IfAction SubSystem: '<S1016>/Hilbert SOS B' */

    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1048>/ITC1' */
    InitTrigger_Model_141_3745_59_192();

    /* InitTriggerControl '<S1040>/ITC1' */
    InitTrigger_Model_141_3745_59_156();

    /* End of SystemInitialize for SubSystem: '<S1016>/Hilbert SOS B' */

    /* End of SystemInitialize for SubSystem: '<S999>/Mono-Surround' */

    /* SystemInitialize for Atomic SubSystem: '<S887>/Expand Tail Components' */
    /* '<S899>:1:18' delayIndex = int32(0); */
    /* '<S900>:1:18' delayIndex = int32(0); */
    /* '<S901>:1:18' delayIndex = int32(0); */
    Model_Target_ExpandTailComponents_Init();

    /* End of SystemInitialize for SubSystem: '<S887>/Expand Tail Components' */
    /* '<S1116>:1:9' previousCount = single(0); */

    /* End of SystemInitialize for SubSystem: '<S587>/On' */
}

/* Outputs for atomic system: '<S558>/Medusa5H1 Part 3' */
void Model_Target_Medusa5H1Part3(void)
{
    int32_T colIdx;
    int32_T i;
    int32_T sample;
    int32_T writeIndex;
    real32_T PremixMatrixTarget[77];
    real32_T audioOut[64];
    real32_T MatrixConcatenate[56];
    real32_T PremixMatrix_e[30];
    real32_T PremixMatrix_a[20];
    real32_T rtb_Downsample_n[16];
    real32_T PremixMatrix_m[12];
    real32_T rtb_Transpose1_o_0[12];
    int8_T rtAction;
    int8_T rtPrevAction;
    static const int8_T tmp[18] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17, 18, 19, 20
    };

    static const int8_T tmp_0[6] =
    {
        10, 21, 11, 22, 12, 23
    };

    static const int8_T tmp_1[22] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 10, 20, 11,
        21
    };

    static const int8_T tmp_2[4] =
    {
        5, 7, 5, 7
    };

    /* If: '<S587>/If' incorporates:
     *  DataStoreRead: '<S587>/Enable State Read'
     */
    rtPrevAction = Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem;
    rtAction = (int8_T)(Model_Target_Medusa5H1Part3_DW.MedusaPostUpmixEnable <=
                        0U);
    Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem = rtAction;
    if ((rtPrevAction != rtAction) && (rtPrevAction == 0))
    {
        /* Disable for Enabled SubSystem: '<S999>/Mono-Surround' */
        if (Model_Target_Medusa5H1Part3_DW.MonoSurround_MODE)
        {
            /* Disable for If: '<S1015>/If' */
            Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem_b = -1;

            /* Disable for If: '<S1016>/If' */
            Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem_k = -1;
            Model_Target_Medusa5H1Part3_DW.MonoSurround_MODE = false;
        }

        /* End of Disable for SubSystem: '<S999>/Mono-Surround' */
    }

    if (rtAction == 0)
    {
        boolean_T fadeOn;
        boolean_T rtb_SLC_On;
        if (rtPrevAction != 0)
        {
        }

        /* MATLAB Function: '<S892>/MATLAB Function' */
        /* [Param:maxDelay] */
        /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S901>:1' */
        /*  Our delayline lives in global variable. We treat as a circular buffer.  */
        /*  figure out the frame size and channel count */
        /* '<S901>:1:9' [frameSize, numChannels] = size(audioIn); */
        /* '<S901>:1:10' frameSize = int32(frameSize); */
        /* '<S901>:1:11' stateLen = int32(maxDelay)+frameSize; */
        /* '<S901>:1:12' totalLen = int32(stateLen * numChannels); */
        /* '<S901>:1:13' audioOut = coder.nullcopy(audioIn); */
        /*  writeIndex points to our current write location in buffer */
        /* '<S901>:1:17' if isempty(delayIndex) */
        /*  delayBuffer is a circular buffer that holds previous samples */
        /*  Write data to delay buffer */
        /* '<S901>:1:24' bufferIndex = delayIndex; */
        i = Model_Target_Medusa5H1Part3_DW.delayIndex;

        /* '<S901>:1:26' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Save writeIndex for next channel */
            /* '<S901>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
            writeIndex = circindex(i, 0, 70);

            /* '<S901>:1:31' for sample = 1:frameSize */
            for (sample = 0; sample < 32; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S901>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
                FullRateBassDelay[writeIndex] =
                    MedusaBassMgrLpf31798PoolIirAudioOut[(colIdx << 5) + sample];

                /*  increment write pointer */
                /* '<S901>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 70);
            }

            /*  Advance buffer index for next channel */
            /* '<S901>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 35, 70);
        }

        /*  Reset */
        /* '<S901>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
        i = circindex(Model_Target_Medusa5H1Part3_DW.delayIndex, 32, 70);

        /* '<S901>:1:46' delayIndex = bufferIndex; */
        Model_Target_Medusa5H1Part3_DW.delayIndex = i;

        /*  Read samples from delay line */
        /* '<S901>:1:49' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Setup read pointer */
            /* '<S901>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
            writeIndex = circindex(i,
                                   -(Model_Target_PreAmp_p5_b0.MedusaFullRateBassDelay
                                    + 32), 70);

            /* '<S901>:1:54' for sample = 1:frameSize */
            for (sample = 0; sample < 32; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S901>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
                audioOut[sample + (colIdx << 5)] = FullRateBassDelay[writeIndex];

                /*  increment write pointer */
                /* '<S901>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 70);
            }

            /*  Advance buffer index for next channel */
            /* '<S901>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 35, 70);
        }

        /* End of MATLAB Function: '<S892>/MATLAB Function' */

        /* DownSample: '<S887>/Downsample' */
        for (i = 0; i < 16; i++)
        {
            rtb_Downsample_n[i] = audioOut[i << 2];
        }

        /* End of DownSample: '<S887>/Downsample' */
        /* MATLAB Function: '<S891>/MATLAB Function' incorporates:
         *  DownSample: '<S887>/Downsample'
         */
        /* [Param:maxDelay] */
        /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S900>:1' */
        /*  Our delayline lives in global variable. We treat as a circular buffer.  */
        /*  figure out the frame size and channel count */
        /* '<S900>:1:9' [frameSize, numChannels] = size(audioIn); */
        /* '<S900>:1:10' frameSize = int32(frameSize); */
        /* '<S900>:1:11' stateLen = int32(maxDelay)+frameSize; */
        /* '<S900>:1:12' totalLen = int32(stateLen * numChannels); */
        /* '<S900>:1:13' audioOut = coder.nullcopy(audioIn); */
        /*  writeIndex points to our current write location in buffer */
        /* '<S900>:1:17' if isempty(delayIndex) */
        /*  delayBuffer is a circular buffer that holds previous samples */
        /*  Write data to delay buffer */
        /* '<S900>:1:24' bufferIndex = delayIndex; */
        i = Model_Target_Medusa5H1Part3_DW.delayIndex_i;

        /* '<S900>:1:26' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Save writeIndex for next channel */
            /* '<S900>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
            writeIndex = circindex(i, 0, 1482);

            /* '<S900>:1:31' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S900>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
                DeciRateBassDelay[writeIndex] = rtb_Downsample_n[(colIdx << 3) +
                    sample];

                /*  increment write pointer */
                /* '<S900>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1482);
            }

            /*  Advance buffer index for next channel */
            /* '<S900>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 741, 1482);
        }

        /*  Reset */
        /* '<S900>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
        i = circindex(Model_Target_Medusa5H1Part3_DW.delayIndex_i, 8, 1482);

        /* '<S900>:1:46' delayIndex = bufferIndex; */
        Model_Target_Medusa5H1Part3_DW.delayIndex_i = i;

        /*  Read samples from delay line */
        /* '<S900>:1:49' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 2; colIdx++)
        {
            /*  Setup read pointer */
            /* '<S900>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
            writeIndex = circindex(i,
                                   -(Model_Target_PreAmp_p5_b0.MedusaDeciRateBassDelay
                                    + 8), 1482);

            /* '<S900>:1:54' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S900>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
                Model_Target_Medusa5H1Part3_B.audioOut_p[sample + (colIdx << 3)]
                    = DeciRateBassDelay[writeIndex];

                /*  increment write pointer */
                /* '<S900>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1482);
            }

            /*  Advance buffer index for next channel */
            /* '<S900>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 741, 1482);
        }

        /* End of MATLAB Function: '<S891>/MATLAB Function' */
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1096>/Submatrix' */
            Model_Target_Medusa5H1Part3_B.Submatrix[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_p[writeIndex];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1096>/Submatrix'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex] =
                Model_Target_Medusa5H1Part3_B.Submatrix[writeIndex];
        }

        /* MATLAB Function: '<S890>/MATLAB Function' incorporates:
         *  Buffer: '<S647>/BufferOut'
         */
        /* [Param:maxDelay] */
        /* MATLAB Function 'MedusaAlignmentDelay/MATLAB Function': '<S899>:1' */
        /*  Our delayline lives in global variable. We treat as a circular buffer.  */
        /*  figure out the frame size and channel count */
        /* '<S899>:1:9' [frameSize, numChannels] = size(audioIn); */
        /* '<S899>:1:10' frameSize = int32(frameSize); */
        /* '<S899>:1:11' stateLen = int32(maxDelay)+frameSize; */
        /* '<S899>:1:12' totalLen = int32(stateLen * numChannels); */
        /* '<S899>:1:13' audioOut = coder.nullcopy(audioIn); */
        /*  writeIndex points to our current write location in buffer */
        /* '<S899>:1:17' if isempty(delayIndex) */
        /*  delayBuffer is a circular buffer that holds previous samples */
        /*  Write data to delay buffer */
        /* '<S899>:1:24' bufferIndex = delayIndex; */
        i = Model_Target_Medusa5H1Part3_DW.delayIndex_d;

        /* '<S899>:1:26' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /*  Save writeIndex for next channel */
            /* '<S899>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
            writeIndex = circindex(i, 0, 1392);

            /* '<S899>:1:31' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S899>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
                MidrangeDelay[writeIndex] = Model_Target_B.BufferOut[(colIdx <<
                    3) + sample];

                /*  increment write pointer */
                /* '<S899>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1392);
            }

            /*  Advance buffer index for next channel */
            /* '<S899>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 174, 1392);
        }

        /*  Reset */
        /* '<S899>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
        i = circindex(Model_Target_Medusa5H1Part3_DW.delayIndex_d, 8, 1392);

        /* '<S899>:1:46' delayIndex = bufferIndex; */
        Model_Target_Medusa5H1Part3_DW.delayIndex_d = i;

        /*  Read samples from delay line */
        /* '<S899>:1:49' for channel = 1:numChannels */
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /*  Setup read pointer */
            /* '<S899>:1:52' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
            writeIndex = circindex(i,
                                   -(Model_Target_PreAmp_p5_b0.MedusaMidrangeDelay
                                    + 8), 1392);

            /* '<S899>:1:54' for sample = 1:frameSize */
            for (sample = 0; sample < 8; sample++)
            {
                /*  overwrite oldest sample with the current input sample */
                /* '<S899>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
                Model_Target_Medusa5H1Part3_B.audioOut_g[sample + (colIdx << 3)]
                    = MidrangeDelay[writeIndex];

                /*  increment write pointer */
                /* '<S899>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
                writeIndex = circindex(writeIndex, 1, 1392);
            }

            /*  Advance buffer index for next channel */
            /* '<S899>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
            i = circindex(i, 174, 1392);
        }

        /* End of MATLAB Function: '<S890>/MATLAB Function' */
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix2' */
            Model_Target_Medusa5H1Part3_B.Submatrix2[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix2'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 8] =
                Model_Target_Medusa5H1Part3_B.Submatrix2[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix4' */
            Model_Target_Medusa5H1Part3_B.Submatrix4[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 16];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix4'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 16] =
                Model_Target_Medusa5H1Part3_B.Submatrix4[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix6' */
            Model_Target_Medusa5H1Part3_B.Submatrix6[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 32];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix6'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 24] =
                Model_Target_Medusa5H1Part3_B.Submatrix6[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix7' */
            Model_Target_Medusa5H1Part3_B.Submatrix7[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 40];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate3' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix7'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 32] =
                Model_Target_Medusa5H1Part3_B.Submatrix7[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1096>/Submatrix1' */
            Model_Target_Medusa5H1Part3_B.Submatrix1[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_p[writeIndex + 8];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1096>/Submatrix1'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 40] =
                Model_Target_Medusa5H1Part3_B.Submatrix1[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix3' */
            Model_Target_Medusa5H1Part3_B.Submatrix3[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 8];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix3'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 48] =
                Model_Target_Medusa5H1Part3_B.Submatrix3[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix5' */
            Model_Target_Medusa5H1Part3_B.Submatrix5[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 24];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix5'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 56] =
                Model_Target_Medusa5H1Part3_B.Submatrix5[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix1' */
            Model_Target_Medusa5H1Part3_B.Submatrix1_a[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 48];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix1'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 64] =
                Model_Target_Medusa5H1Part3_B.Submatrix1_a[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1097>/Submatrix8' */
            Model_Target_Medusa5H1Part3_B.Submatrix8[writeIndex] =
                Model_Target_Medusa5H1Part3_B.audioOut_g[writeIndex + 56];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate5' incorporates:
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix8'
             */
            Model_Target_Medusa5H1Part3_B.MatrixConcatenate1[writeIndex + 72] =
                Model_Target_Medusa5H1Part3_B.Submatrix8[writeIndex];
        }

        /* S-Function (sdspsubmtrx): '<S1060>/Submatrix' incorporates:
         *  DataStoreRead: '<S1060>/Data Store Read1'
         */
        i = 0;
        for (colIdx = 0; colIdx < 10; colIdx++)
        {
            Model_Target_Medusa5H1Part3_B.Submatrix_g[i] =
                Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[(colIdx <<
                1) + 1];
            i++;
        }

        /* End of S-Function (sdspsubmtrx): '<S1060>/Submatrix' */

        /* Outputs for Enabled SubSystem: '<S999>/Mono-Surround' incorporates:
         *  EnablePort: '<S1011>/Enable'
         */
        if (Model_Target_Medusa5H1Part3_DW.MonoSurround_MODE)
        {
            /* Disable for If: '<S1015>/If' */
            Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem_b = -1;

            /* Disable for If: '<S1016>/If' */
            Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem_k = -1;
            Model_Target_Medusa5H1Part3_DW.MonoSurround_MODE = false;
        }

        /* End of Outputs for SubSystem: '<S999>/Mono-Surround' */

        /* S-Function (sdspsubmtrx): '<S1060>/Submatrix1' incorporates:
         *  DataStoreRead: '<S1060>/Data Store Read1'
         */
        i = 0;
        for (colIdx = 0; colIdx < 10; colIdx++)
        {
            Model_Target_Medusa5H1Part3_B.Submatrix1_c[i] =
                Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[colIdx << 1];
            Model_Target_Medusa5H1Part3_B.Submatrix1_c[i + 1] =
                Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS[(colIdx <<
                1) + 1];
            i += 2;
        }

        /* End of S-Function (sdspsubmtrx): '<S1060>/Submatrix1' */

        /* Math: '<S1060>/Transpose1' incorporates:
         *  S-Function (sdspsubmtrx): '<S1060>/Submatrix1'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 10; colIdx++)
            {
                PremixMatrix_a[colIdx + 10 * i] =
                    Model_Target_Medusa5H1Part3_B.Submatrix1_c[(colIdx << 1) + i];
            }
        }

        /* End of Math: '<S1060>/Transpose1' */

        /* Product: '<S1060>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1006>/Matrix Concatenate1'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 8; colIdx++)
            {
                sample = (i << 3) + colIdx;
                rtb_Downsample_n[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 10; writeIndex++)
                {
                    rtb_Downsample_n[sample] +=
                        Model_Target_Medusa5H1Part3_B.MatrixConcatenate1
                        [(writeIndex << 3) + colIdx] * PremixMatrix_a[10 * i +
                        writeIndex];
                }
            }
        }

        /* MATLAB Function: '<S999>/Selective Concatenation' incorporates:
         *  Merge: '<S587>/Merge'
         *  Product: '<S1060>/Matrix Multiply1'
         */
        memcpy(&Model_Target_Medusa5H1Part3_B.Merge[0], &rtb_Downsample_n[0],
               sizeof(real32_T) << 4U);

        /* M-S-Function: '<S999>/FeaturePath' */
        /*  Concatenate monosurround output (if available) to the center outputs */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/CS Processing/Selective Concatenation': '<S1012>:1' */
        /* '<S1012>:1:5' if MedusaPremixConfig.NumSurroundOut==0 */
        /* '<S1012>:1:6' CSOut = COut; */
        /* MATLAB Function: '<S1111>/MATLAB Function1' */
        /* MATLAB Function 'Surround Level Control Generic/Detect SLC REQ/MATLAB Function1': '<S1116>:1' */
        /*  Initialize previousCount */
        /* '<S1116>:1:8' if(isempty(previousCount)) */
        /* '<S1116>:1:12' SLC_On = false; */
        rtb_SLC_On = false;

        /*  Track changes in TriggerCount to indicate SLC Trigger */
        /* '<S1116>:1:15' if(TriggerCount ~= previousCount) */
        if (Model_Target_Medusa5H1Part3_DW.TriggerCount !=
                Model_Target_Medusa5H1Part3_DW.previousCount)
        {
            /* '<S1116>:1:16' SLC_On = true; */
            rtb_SLC_On = true;
        }

        /*  Update the previousCount to contain the previous value of Trigger Count for next instance */
        /* '<S1116>:1:20' previousCount = TriggerCount; */
        Model_Target_Medusa5H1Part3_DW.previousCount =
            Model_Target_Medusa5H1Part3_DW.TriggerCount;

        /* End of MATLAB Function: '<S1111>/MATLAB Function1' */

        /* Selector: '<S887>/Selector' incorporates:
         *  Delay: '<S887>/Delay6'
         */
        Model_Target_Medusa5H1Part3_B.Selector_p =
            Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[0];

        /* Selector: '<S887>/Selector2' incorporates:
         *  Delay: '<S887>/Delay6'
         */
        Model_Target_Medusa5H1Part3_B.Selector2 =
            Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[1];

        /* MATLAB Function: '<S1000>/Fade_Trigger_Generation' */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Fade Inputs/Fade_Trigger_Generation': '<S1051>:1' */
        /* '<S1051>:1:3' fadeOn = false; */
        fadeOn = false;

        /* Abs: '<S1000>/Abs2' incorporates:
         *  Delay: '<S1000>/Delay2'
         */
        /*  Generates function call triggers when incoming fade gain values change */
        /* '<S1051>:1:6' if(gainDifference > 0) */
        if (-Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE < 0)
        {
            i = Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE;
        }
        else
        {
            i = -Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE;
        }

        /* MATLAB Function: '<S1000>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1000>/Abs'
         *  Abs: '<S1000>/Abs1'
         *  Abs: '<S1000>/Abs2'
         *  Delay: '<S1000>/Delay'
         *  Delay: '<S1000>/Delay1'
         *  Sum: '<S1000>/Add'
         *  Sum: '<S1000>/Subtract1'
         *  Sum: '<S1000>/Subtract2'
         */
        if ((qhmath_abs_f(Model_Target_Medusa5H1Part3_B.Selector_p -
                          Model_Target_Medusa5H1Part3_DW.Delay_DSTATE) +
                (real32_T)i) + qhmath_abs_f
                (Model_Target_Medusa5H1Part3_B.Selector2 -
                 Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE) > 0.0F)
        {
            /* Outputs for Function Call SubSystem: '<S1003>/Fader Downmix' */
            /* If: '<S1071>/If' */
            /* '<S1051>:1:7' fadeTrigger_Left(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1071>/Fading Forward' incorporates:
                 *  ActionPort: '<S1076>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp_p5_b0.MedusaPremixForwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaPremixForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_p);

                /* End of Outputs for SubSystem: '<S1071>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1071>/Fading Backward' incorporates:
                 *  ActionPort: '<S1075>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp_p5_b0.MedusaPremixBackwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaPremixBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_p);

                /* End of Outputs for SubSystem: '<S1071>/Fading Backward' */
            }

            /* End of If: '<S1071>/If' */
            /*  #codegen */
            /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Left/Fader Downmix/MATLAB Function': '<S1077>:1' */
            /* '<S1077>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1077>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 77; i++)
            {
                /* Product: '<S1071>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1071>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1055>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_bn[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_p *
                    Model_Target_PreAmp_p5_b0.MedusaPremixDownmixWeights_Left[i];
            }

            /* Outputs for Function Call SubSystem: '<S1002>/Fader Downmix' */
            /* If: '<S1059>/If' */
            /* '<S1051>:1:8' fadeTrigger_CS(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1059>/Fading Forward' incorporates:
                 *  ActionPort: '<S1064>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp_p5_b0.MedusaPremixForwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaPremixForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_c);

                /* End of Outputs for SubSystem: '<S1059>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1059>/Fading Backward' incorporates:
                 *  ActionPort: '<S1063>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp_p5_b0.MedusaPremixBackwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaPremixBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_c);

                /* End of Outputs for SubSystem: '<S1059>/Fading Backward' */
            }

            /* End of If: '<S1059>/If' */
            /*  #codegen */
            /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Center Surround/Fader Downmix/MATLAB Function': '<S1065>:1' */
            /* '<S1065>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1065>:1:6' if(MedusaPremixConfig.includeCAE ==1 && CAE_Enable == 1) */
            for (i = 0; i < 20; i++)
            {
                /* Product: '<S1059>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1059>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1054>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_b[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_c *
                    Model_Target_PreAmp_p5_b0.MedusaPremixDownmixWeights_CS[i];
            }

            /* Outputs for Function Call SubSystem: '<S1004>/Fader Downmix' */
            /* If: '<S1083>/If' */
            /* '<S1051>:1:9' fadeTrigger_Right(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S1083>/Fading Forward' incorporates:
                 *  ActionPort: '<S1088>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp_p5_b0.MedusaPremixForwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaPremixForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_g);

                /* End of Outputs for SubSystem: '<S1083>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S1083>/Fading Backward' incorporates:
                 *  ActionPort: '<S1087>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp_p5_b0.MedusaPremixBackwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaPremixBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_g);

                /* End of Outputs for SubSystem: '<S1083>/Fading Backward' */
            }

            /* End of If: '<S1083>/If' */
            /*  #codegen */
            /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Full Mixing Matrix_Right/Fader Downmix/MATLAB Function': '<S1089>:1' */
            /* '<S1089>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S1089>:1:6' if(MedusaPremixConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 77; i++)
            {
                /* Product: '<S1083>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S1083>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S1056>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_g *
                    Model_Target_PreAmp_p5_b0.MedusaPremixDownmixWeights_Right[i];
            }

            /* '<S1051>:1:10' fadeOn = true; */
            fadeOn = true;

            /*  Indicates that fade is triggered */
        }

        for (i = 0; i < 77; i++)
        {
            /* Sum: '<S1004>/Add' incorporates:
             *  Constant: '<S1004>/Constant'
             *  DataStoreRead: '<S1086>/Data Store Read'
             *  Product: '<S1004>/Matrix Multiply'
             *  Product: '<S1083>/Matrix Multiply'
             *  Sum: '<S1004>/Subtract'
             */
            Model_Target_Medusa5H1Part3_B.Transpose1_o[i] = (1.0F -
                Model_Target_Medusa5H1Part3_B.Merge_g) *
                Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Right[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply[i];
        }

        /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1113>/RTC Request Response Trigger' */
        for (i = 0; i < 77; i++)
        {
            /* Sum: '<S1003>/Add' incorporates:
             *  Constant: '<S1003>/Constant'
             *  DataStoreRead: '<S1074>/Data Store Read'
             *  Product: '<S1003>/Matrix Multiply'
             *  Product: '<S1071>/Matrix Multiply'
             *  Sum: '<S1003>/Subtract'
             */
            PremixMatrixTarget[i] = (1.0F -
                Model_Target_Medusa5H1Part3_B.Merge_p) *
                Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_Left[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_bn[i];
        }

        for (i = 0; i < 20; i++)
        {
            /* Sum: '<S1002>/Add' incorporates:
             *  Constant: '<S1002>/Constant'
             *  DataStoreRead: '<S1062>/Data Store Read'
             *  Product: '<S1002>/Matrix Multiply'
             *  Product: '<S1059>/Matrix Multiply'
             *  Sum: '<S1002>/Subtract'
             */
            PremixMatrix_a[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_c) *
                Model_Target_Medusa5H1Part3_DW.Premix_SLCGain_CS[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_b[i];
        }

        /* MATLAB Function: '<S1005>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S1000>/Fade_Trigger_Generation'
         */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Premix/Premix with Mono-Surround & CAE with Fade Ramper/Generate Ramp Trigger/MATLAB Function': '<S1095>:1' */
        /* '<S1095>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1095>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On || fadeOn)
        {
            /* MATLAB Function: '<S1073>/control' */
            /* MATLAB Function: '<S1073>/control' */
            /* '<S1095>:1:7' rampOn = 1; */
            /* '<S1095>:1:8' ramp(); */
            Model_Target_control_p(PremixMatrixTarget,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Left,
                                   Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left);

            /* MATLAB Function: '<S1061>/control' */
            /* MATLAB Function: '<S1061>/control' */
            Model_Target_control_l(PremixMatrix_a,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.Premix_Freeze_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_frameCount_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_CS,
                                   Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS);

            /* MATLAB Function: '<S1085>/control' */
            /* MATLAB Function: '<S1085>/control' */
            Model_Target_control_c(Model_Target_Medusa5H1Part3_B.Transpose1_o,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Right,
                                   Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right);
        }

        /* End of MATLAB Function: '<S1005>/MATLAB Function' */
        /* End of Outputs for S-Function (RTC_NTF): '<S1113>/NTF Trigger' */

        /* MATLAB Function: '<S1061>/process' */
        Model_Target_process_p(&Model_Target_Medusa5H1Part3_DW.Premix_Freeze_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_currentGain_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_frameCount_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_CS,
                               Model_Target_Medusa5H1Part3_DW.Premix_targetGain_CS);

        /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1114>/RTC Request Response Trigger' */
        for (i = 0; i < 8; i++)
        {
            /* SignalConversion generated from: '<S1006>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1096>/Submatrix'
             */
            MatrixConcatenate[i] = Model_Target_Medusa5H1Part3_B.Submatrix[i];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix2'
             */
            MatrixConcatenate[i + 8] =
                Model_Target_Medusa5H1Part3_B.Submatrix2[i];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix4'
             */
            MatrixConcatenate[i + 16] =
                Model_Target_Medusa5H1Part3_B.Submatrix4[i];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix6'
             */
            MatrixConcatenate[i + 24] =
                Model_Target_Medusa5H1Part3_B.Submatrix6[i];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix7'
             */
            MatrixConcatenate[i + 32] =
                Model_Target_Medusa5H1Part3_B.Submatrix7[i];
        }

        /* Selector: '<S887>/Selector1' incorporates:
         *  Buffer: '<S647>/BufferOut'
         *  Sum: '<S936>/Add'
         */
        for (i = 0; i < 4; i++)
        {
            for (colIdx = 0; colIdx < 8; colIdx++)
            {
                Model_Target_Medusa5H1Part3_B.PremixMatrix_i[colIdx + (i << 3)] =
                    Model_Target_B.BufferOut[(tmp_2[i] << 3) + colIdx];
            }
        }

        /* End of Selector: '<S887>/Selector1' */

        /* Outputs for Atomic SubSystem: '<S887>/Expand Tail Components' */
        Model_Target_ExpandTailComponents();

        /* End of Outputs for SubSystem: '<S887>/Expand Tail Components' */
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S1098>/Submatrix' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             */
            MatrixConcatenate[writeIndex + 40] =
                Default57912PoolIirAudioOut[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1098>/Submatrix2' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate'
             */
            MatrixConcatenate[writeIndex + 48] =
                Default57912PoolIirAudioOut[writeIndex + 16];
        }

        /* Product: '<S1072>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1006>/Matrix Concatenate'
         *  DataStoreRead: '<S1072>/Mixing Gains'
         *  Math: '<S1072>/Transpose1'
         *  Merge: '<S587>/Merge'
         */
        for (i = 0; i < 8; i++)
        {
            for (colIdx = 0; colIdx < 11; colIdx++)
            {
                sample = (colIdx << 3) + i;
                Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 7; writeIndex++)
                {
                    Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] +=
                        MatrixConcatenate[(writeIndex << 3) + i] *
                        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left
                        [11 * writeIndex + colIdx];
                }
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge[16],
               &Model_Target_Medusa5H1Part3_B.MatrixConcatenate[0], 88U * sizeof
               (real32_T));

        /* End of Product: '<S1072>/Matrix Multiply1' */

        /* MATLAB Function: '<S1073>/process' */
        Model_Target_process_in
            (&Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Left,
             Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Left);
        for (writeIndex = 0; writeIndex < 8; writeIndex++)
        {
            /* SignalConversion generated from: '<S1006>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1096>/Submatrix1'
             */
            MatrixConcatenate[writeIndex] =
                Model_Target_Medusa5H1Part3_B.Submatrix1[writeIndex];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix3'
             */
            MatrixConcatenate[writeIndex + 8] =
                Model_Target_Medusa5H1Part3_B.Submatrix3[writeIndex];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix5'
             */
            MatrixConcatenate[writeIndex + 16] =
                Model_Target_Medusa5H1Part3_B.Submatrix5[writeIndex];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix1'
             */
            MatrixConcatenate[writeIndex + 24] =
                Model_Target_Medusa5H1Part3_B.Submatrix1_a[writeIndex];

            /* SignalConversion generated from: '<S1006>/Matrix Concatenate4' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             *  S-Function (sdspsubmtrx): '<S1097>/Submatrix8'
             */
            MatrixConcatenate[writeIndex + 32] =
                Model_Target_Medusa5H1Part3_B.Submatrix8[writeIndex];

            /* S-Function (sdspsubmtrx): '<S1098>/Submatrix1' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             */
            MatrixConcatenate[writeIndex + 40] =
                Default57912PoolIirAudioOut[writeIndex + 8];

            /* S-Function (sdspsubmtrx): '<S1098>/Submatrix3' incorporates:
             *  Concatenate: '<S1006>/Matrix Concatenate4'
             */
            MatrixConcatenate[writeIndex + 48] =
                Default57912PoolIirAudioOut[writeIndex + 24];
        }

        /* Product: '<S1084>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S1006>/Matrix Concatenate4'
         *  DataStoreRead: '<S1084>/Data Store Read1'
         *  Math: '<S1084>/Transpose1'
         *  Merge: '<S587>/Merge'
         */
        for (i = 0; i < 8; i++)
        {
            for (colIdx = 0; colIdx < 11; colIdx++)
            {
                sample = (colIdx << 3) + i;
                Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 7; writeIndex++)
                {
                    Model_Target_Medusa5H1Part3_B.MatrixConcatenate[sample] +=
                        MatrixConcatenate[(writeIndex << 3) + i] *
                        Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right
                        [11 * writeIndex + colIdx];
                }
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge[104],
               &Model_Target_Medusa5H1Part3_B.MatrixConcatenate[0], 88U * sizeof
               (real32_T));

        /* End of Product: '<S1084>/Matrix Multiply1' */

        /* MATLAB Function: '<S1085>/process' */
        Model_Target_process_f
            (&Model_Target_Medusa5H1Part3_DW.Premix_Freeze_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_currentGain_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_frameCount_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_rampCoeff_Right,
             Model_Target_Medusa5H1Part3_DW.Premix_targetGain_Right);

        /* MATLAB Function: '<S932>/Fade_Trigger_Generation' */
        /*  #codegen */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Fade Inputs/Fade_Trigger_Generation': '<S942>:1' */
        /* '<S942>:1:3' fadeOn = false; */
        fadeOn = false;

        /* Abs: '<S932>/Abs2' incorporates:
         *  Delay: '<S932>/Delay2'
         */
        /*  Generates function call triggers when incoming fade gain values change */
        /* '<S942>:1:6' if(gainDifference > 0) */
        if (-Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k < 0)
        {
            i = Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k;
        }
        else
        {
            i = -Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k;
        }

        /* MATLAB Function: '<S932>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S932>/Abs'
         *  Abs: '<S932>/Abs1'
         *  Abs: '<S932>/Abs2'
         *  Delay: '<S932>/Delay'
         *  Delay: '<S932>/Delay1'
         *  Sum: '<S932>/Add'
         *  Sum: '<S932>/Subtract1'
         *  Sum: '<S932>/Subtract2'
         */
        if ((qhmath_abs_f(Model_Target_Medusa5H1Part3_B.Selector_p -
                          Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_c) +
                (real32_T)i) + qhmath_abs_f
                (Model_Target_Medusa5H1Part3_B.Selector2 -
                 Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_m) > 0.0F)
        {
            /* Outputs for Function Call SubSystem: '<S935>/Fader Downmix' */
            /* If: '<S962>/If' */
            /* '<S942>:1:7' fadeTrigger_Left(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S962>/Fading Forward' incorporates:
                 *  ActionPort: '<S967>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerForwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_pk);

                /* End of Outputs for SubSystem: '<S962>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S962>/Fading Backward' incorporates:
                 *  ActionPort: '<S966>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerBackwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_pk);

                /* End of Outputs for SubSystem: '<S962>/Fading Backward' */
            }

            /* End of If: '<S962>/If' */
            /*  #codegen */
            /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Left/Fader Downmix/MATLAB Function': '<S968>:1' */
            /* '<S968>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S968>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 30; i++)
            {
                /* Product: '<S962>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S962>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S946>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_n[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_pk *
                    Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDownmixWeights_Left
                    [i];
            }

            /* Outputs for Function Call SubSystem: '<S934>/Fader Downmix' */
            /* If: '<S950>/If' */
            /* '<S942>:1:8' fadeTrigger_CS(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S950>/Fading Forward' incorporates:
                 *  ActionPort: '<S955>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerForwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_n);

                /* End of Outputs for SubSystem: '<S950>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S950>/Fading Backward' incorporates:
                 *  ActionPort: '<S954>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerBackwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_n);

                /* End of Outputs for SubSystem: '<S950>/Fading Backward' */
            }

            /* End of If: '<S950>/If' */
            /*  #codegen */
            /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Center Surround/Fader Downmix/MATLAB Function': '<S956>:1' */
            /* '<S956>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S956>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 12; i++)
            {
                /* Product: '<S950>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S950>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S945>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_e[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_n *
                    Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDownmixWeights_CS
                    [i];
            }

            /* Outputs for Function Call SubSystem: '<S936>/Fader Downmix' */
            /* If: '<S974>/If' */
            /* '<S942>:1:9' fadeTrigger_Right(); */
            if (Model_Target_Medusa5H1Part3_B.Selector_p >=
                    Model_Target_Medusa5H1Part3_B.Selector2)
            {
                /* Outputs for IfAction SubSystem: '<S974>/Fading Forward' incorporates:
                 *  ActionPort: '<S979>/Action Port'
                 */
                Model_Target_FadingForward
                    (Model_Target_Medusa5H1Part3_B.Selector2,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerForwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerForwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_go);

                /* End of Outputs for SubSystem: '<S974>/Fading Forward' */
            }
            else
            {
                /* Outputs for IfAction SubSystem: '<S974>/Fading Backward' incorporates:
                 *  ActionPort: '<S978>/Action Port'
                 */
                Model_Target_FadingBackward
                    (Model_Target_Medusa5H1Part3_B.Selector_p,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerBackwardDownmixThreshold,
                     Model_Target_PreAmp_p5_b0.MedusaFullRateMixerBackwardDownmixMax,
                     &Model_Target_Medusa5H1Part3_B.Merge_go);

                /* End of Outputs for SubSystem: '<S974>/Fading Backward' */
            }

            /* End of If: '<S974>/If' */
            /*  #codegen */
            /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Full Mixing Matrix_Right/Fader Downmix/MATLAB Function': '<S980>:1' */
            /* '<S980>:1:3' downmixWeights = weights; */
            /*  If CAE is supported and enabled, replace the tail weights with their CAE counterparts */
            /* '<S980>:1:6' if(MedusaFRMConfig.includeCAE == 1 && CAE_Enable == 1) */
            for (i = 0; i < 30; i++)
            {
                /* Product: '<S974>/Matrix Multiply' incorporates:
                 *  MATLAB Function: '<S974>/MATLAB Function'
                 *  S-Function (TOP_MEX): '<S947>/TOP'
                 */
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_i[i] =
                    Model_Target_Medusa5H1Part3_B.Merge_go *
                    Model_Target_PreAmp_p5_b0.MedusaFullRateMixerDownmixWeights_Right
                    [i];
            }

            /* '<S942>:1:10' fadeOn = true; */
            fadeOn = true;

            /*  Indicates that fade is triggered */
        }

        for (i = 0; i < 30; i++)
        {
            /* Sum: '<S936>/Add' incorporates:
             *  Constant: '<S936>/Constant'
             *  DataStoreRead: '<S977>/Data Store Read'
             *  Product: '<S936>/Matrix Multiply'
             *  Product: '<S974>/Matrix Multiply'
             *  Sum: '<S936>/Subtract'
             */
            Model_Target_Medusa5H1Part3_B.PremixMatrix_i[i] = (1.0F -
                Model_Target_Medusa5H1Part3_B.Merge_go) *
                Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Right[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_i[i];

            /* Sum: '<S935>/Add' incorporates:
             *  Constant: '<S935>/Constant'
             *  DataStoreRead: '<S965>/Data Store Read'
             *  Product: '<S935>/Matrix Multiply'
             *  Product: '<S962>/Matrix Multiply'
             *  Sum: '<S935>/Subtract'
             */
            PremixMatrix_e[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_pk) *
                Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_Left[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_n[i];
        }

        for (i = 0; i < 12; i++)
        {
            /* Sum: '<S934>/Add' incorporates:
             *  Constant: '<S934>/Constant'
             *  DataStoreRead: '<S953>/Data Store Read'
             *  Product: '<S934>/Matrix Multiply'
             *  Product: '<S950>/Matrix Multiply'
             *  Sum: '<S934>/Subtract'
             */
            PremixMatrix_m[i] = (1.0F - Model_Target_Medusa5H1Part3_B.Merge_n) *
                Model_Target_Medusa5H1Part3_DW.FRM_SLCGain_CS[i] +
                Model_Target_Medusa5H1Part3_B.MatrixMultiply_e[i];
        }

        /* MATLAB Function: '<S937>/MATLAB Function' incorporates:
         *  MATLAB Function: '<S932>/Fade_Trigger_Generation'
         */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/Full-rate Mixer/Full-Rate Mixer with CAE & Fade Ramper/Generate Ramp Trigger/MATLAB Function': '<S986>:1' */
        /* '<S986>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S986>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On || fadeOn)
        {
            /* MATLAB Function: '<S964>/control' */
            /* MATLAB Function: '<S964>/control' */
            /* '<S986>:1:7' rampOn = 1; */
            /* '<S986>:1:8' ramp(); */
            Model_Target_control_m(PremixMatrix_e,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Left,
                                   Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left);

            /* MATLAB Function: '<S952>/control' */
            /* MATLAB Function: '<S952>/control' */
            Model_Target_control_e(PremixMatrix_m,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.FRM_Freeze_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_frameCount_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_CS,
                                   Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS);

            /* MATLAB Function: '<S976>/control' */
            /* MATLAB Function: '<S976>/control' */
            Model_Target_control_a
                (&Model_Target_Medusa5H1Part3_B.PremixMatrix_i[0],
                 Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                 Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                 &Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Right,
                 Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right,
                 Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Right,
                 Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Right,
                 Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right);
        }

        /* End of MATLAB Function: '<S937>/MATLAB Function' */
        for (writeIndex = 0; writeIndex < 32; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S987>/Submatrix2' incorporates:
             *  Buffer: '<S648>/BufferOut'
             *  Concatenate: '<S938>/Matrix Concatenate'
             */
            Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[writeIndex]
                = Model_Target_B.BufferOut_c[writeIndex];

            /* S-Function (sdspsubmtrx): '<S987>/Submatrix4' incorporates:
             *  Buffer: '<S648>/BufferOut'
             *  Concatenate: '<S938>/Matrix Concatenate'
             */
            Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[writeIndex
                + 32] = Model_Target_B.BufferOut_c[writeIndex + 64];

            /* S-Function (sdspsubmtrx): '<S987>/Submatrix5' incorporates:
             *  Buffer: '<S648>/BufferOut'
             *  Concatenate: '<S938>/Matrix Concatenate'
             */
            Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[writeIndex
                + 64] = Model_Target_B.BufferOut_c[writeIndex + 96];
        }

        /* SignalConversion generated from: '<S938>/Matrix Concatenate1' incorporates:
         *  Concatenate: '<S938>/Matrix Concatenate'
         */
        memcpy(&Model_Target_Medusa5H1Part3_B.MatrixConcatenate1_j[0],
               &Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[0], 96U
               * sizeof(real32_T));
        for (writeIndex = 0; writeIndex < 32; writeIndex++)
        {
            /* S-Function (sdspsubmtrx): '<S987>/Submatrix3' incorporates:
             *  Buffer: '<S648>/BufferOut'
             *  Concatenate: '<S938>/Matrix Concatenate2'
             */
            Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[writeIndex] =
                Model_Target_B.BufferOut_c[writeIndex + 32];

            /* S-Function (sdspsubmtrx): '<S987>/Submatrix6' incorporates:
             *  Buffer: '<S648>/BufferOut'
             *  Concatenate: '<S938>/Matrix Concatenate2'
             */
            Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[writeIndex +
                32] = Model_Target_B.BufferOut_c[writeIndex + 128];

            /* S-Function (sdspsubmtrx): '<S987>/Submatrix7' incorporates:
             *  Buffer: '<S648>/BufferOut'
             *  Concatenate: '<S938>/Matrix Concatenate2'
             */
            Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[writeIndex +
                64] = Model_Target_B.BufferOut_c[writeIndex + 160];
        }

        /* SignalConversion generated from: '<S938>/Matrix Concatenate1' incorporates:
         *  Concatenate: '<S938>/Matrix Concatenate2'
         */
        memcpy(&Model_Target_Medusa5H1Part3_B.MatrixConcatenate1_j[96],
               &Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[0], 96U *
               sizeof(real32_T));

        /* Math: '<S951>/Transpose1' incorporates:
         *  DataStoreRead: '<S951>/Data Store Read'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 6; colIdx++)
            {
                PremixMatrix_m[colIdx + 6 * i] =
                    Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS[(colIdx <<
                    1) + i];
            }
        }

        for (i = 0; i < 12; i++)
        {
            rtb_Transpose1_o_0[i] = PremixMatrix_m[i];
        }

        /* End of Math: '<S951>/Transpose1' */

        /* Product: '<S951>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S938>/Matrix Concatenate1'
         *  Merge: '<S587>/Merge1'
         */
        for (i = 0; i < 2; i++)
        {
            for (colIdx = 0; colIdx < 32; colIdx++)
            {
                sample = (i << 5) + colIdx;
                audioOut[sample] = 0.0F;
                for (writeIndex = 0; writeIndex < 6; writeIndex++)
                {
                    audioOut[sample] +=
                        Model_Target_Medusa5H1Part3_B.MatrixConcatenate1_j
                        [(writeIndex << 5) + colIdx] * rtb_Transpose1_o_0[6 * i
                        + writeIndex];
                }
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge1[0], &audioOut[0], sizeof
               (real32_T) << 6U);

        /* End of Product: '<S951>/Matrix Multiply1' */

        /* MATLAB Function: '<S952>/process' */
        Model_Target_process(&Model_Target_Medusa5H1Part3_DW.FRM_Freeze_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_currentGain_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_frameCount_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_CS,
                             Model_Target_Medusa5H1Part3_DW.FRM_targetGain_CS);

        /* Math: '<S963>/Transpose1' incorporates:
         *  DataStoreRead: '<S963>/Data Store Read'
         */
        for (i = 0; i < 10; i++)
        {
            PremixMatrix_e[3 * i] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i];
            PremixMatrix_e[3 * i + 1] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i + 10];
            PremixMatrix_e[3 * i + 2] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left[i + 20];
        }

        /* End of Math: '<S963>/Transpose1' */

        /* Product: '<S963>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S938>/Matrix Concatenate'
         *  Merge: '<S587>/Merge1'
         */
        for (i = 0; i < 10; i++)
        {
            for (colIdx = 0; colIdx < 32; colIdx++)
            {
                writeIndex = (i << 5) + colIdx;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    = 0.0F;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i] *
                    Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[colIdx];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 1] *
                    Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[colIdx
                    + 32];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 2] *
                    Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs_m[colIdx
                    + 64];
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge1[64],
               &Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[0], 320U *
               sizeof(real32_T));

        /* End of Product: '<S963>/Matrix Multiply1' */

        /* MATLAB Function: '<S964>/process' */
        Model_Target_process_o(&Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Left,
                               Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Left);

        /* Math: '<S975>/Transpose1' incorporates:
         *  DataStoreRead: '<S975>/Data Store Read'
         */
        for (i = 0; i < 10; i++)
        {
            PremixMatrix_e[3 * i] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i];
            PremixMatrix_e[3 * i + 1] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i + 10];
            PremixMatrix_e[3 * i + 2] =
                Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right[i + 20];
        }

        /* End of Math: '<S975>/Transpose1' */

        /* Product: '<S975>/Matrix Multiply1' incorporates:
         *  Concatenate: '<S938>/Matrix Concatenate2'
         *  Merge: '<S587>/Merge1'
         */
        for (i = 0; i < 10; i++)
        {
            for (colIdx = 0; colIdx < 32; colIdx++)
            {
                writeIndex = (i << 5) + colIdx;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    = 0.0F;
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i] *
                    Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[colIdx];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 1] *
                    Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[colIdx
                    + 32];
                Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[writeIndex]
                    += PremixMatrix_e[3 * i + 2] *
                    Model_Target_Medusa5H1Part3_B.Right_CenterChannelInputs[colIdx
                    + 64];
            }
        }

        memcpy(&Model_Target_Medusa5H1Part3_B.Merge1[384],
               &Model_Target_Medusa5H1Part3_B.Left_CenterChannelInputs[0], 320U *
               sizeof(real32_T));

        /* End of Product: '<S975>/Matrix Multiply1' */

        /* MATLAB Function: '<S976>/process' */
        Model_Target_process_i(&Model_Target_Medusa5H1Part3_DW.FRM_Freeze_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_currentGain_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_frameCount_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_rampCoeff_Right,
                               Model_Target_Medusa5H1Part3_DW.FRM_targetGain_Right);

        /* MATLAB Function: '<S1131>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1131>/Abs'
         *  Abs: '<S1131>/Abs1'
         *  Delay: '<S1131>/Delay'
         *  Delay: '<S1131>/Delay1'
         *  Sum: '<S1131>/Add'
         *  Sum: '<S1131>/Subtract1'
         *  Sum: '<S1131>/Subtract2'
         */
        Model_Target_Fade_Trigger_Generation(qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector_p -
             Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_p) + qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector2 -
             Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_o),
            &(Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsDownmixWeights[0]),
            Model_Target_Medusa5H1Part3_B.Selector_p,
            Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsForwardDownmixThreshold,
            Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsForwardDownmixMax,
            Model_Target_Medusa5H1Part3_B.Selector2,
            Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsBackwardDownmixThreshold,
            Model_Target_PreAmp_p5_b0.MedusaVLSDrvGainsBackwardDownmixMax,
            &Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n);
        for (i = 0; i < 12; i++)
        {
            /* Sum: '<S1133>/Add' incorporates:
             *  Constant: '<S1133>/Constant'
             *  DataStoreRead: '<S1144>/Data Store Read'
             *  Product: '<S1133>/Matrix Multiply'
             *  Product: '<S1142>/Matrix Multiply'
             *  Sum: '<S1133>/Subtract'
             */
            PremixMatrix_m[i] = (1.0F -
                                 Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n.downmix)
                * Model_Target_Medusa5H1Part3_DW.VLSDrv_SLCGain[i] +
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n.MatrixMultiply
                [i];
        }

        /* MATLAB Function: '<S1134>/MATLAB Function' */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Generate Ramp Trigger/MATLAB Function': '<S1151>:1' */
        /* '<S1151>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1151>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On ||
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_n.fadeOn)
        {
            /* MATLAB Function: '<S1143>/control' */
            /* MATLAB Function: '<S1143>/control' */
            /* '<S1151>:1:7' rampOn = 1; */
            /* '<S1151>:1:8' ramp(); */
            Model_Target_control_as(PremixMatrix_m,
                                    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                    Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                    &Model_Target_Medusa5H1Part3_DW.VLSDrv_Freeze,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_frameCount,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_rampCoeff,
                                    Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain);
        }

        /* End of MATLAB Function: '<S1134>/MATLAB Function' */
        for (i = 0; i < 12; i++)
        {
            /* Merge: '<S587>/Merge2' incorporates:
             *  DataStoreRead: '<S1133>/Mixing Gains'
             */
            Model_Target_Medusa5H1Part3_B.Merge2[i] =
                Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain[i];
        }

        /* MATLAB Function: '<S1143>/process' */
        Model_Target_process_c(&Model_Target_Medusa5H1Part3_DW.VLSDrv_Freeze,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_currentGain,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_frameCount,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_rampCoeff,
                               Model_Target_Medusa5H1Part3_DW.VLSDrv_targetGain);

        /* MATLAB Function: '<S1156>/Fade_Trigger_Generation' incorporates:
         *  Abs: '<S1156>/Abs'
         *  Abs: '<S1156>/Abs1'
         *  Delay: '<S1156>/Delay'
         *  Delay: '<S1156>/Delay1'
         *  Sum: '<S1156>/Add'
         *  Sum: '<S1156>/Subtract1'
         *  Sum: '<S1156>/Subtract2'
         */
        Model_Target_Fade_Trigger_Generation(qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector_p -
             Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_e) + qhmath_abs_f
            (Model_Target_Medusa5H1Part3_B.Selector2 -
             Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_n),
            &(Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsDownmixWeights[0]),
            Model_Target_Medusa5H1Part3_B.Selector_p,
            Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsForwardDownmixThreshold,
            Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsForwardDownmixMax,
            Model_Target_Medusa5H1Part3_B.Selector2,
            Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsBackwardDownmixThreshold,
            Model_Target_PreAmp_p5_b0.MedusaVLSPaxGainsBackwardDownmixMax,
            &Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a);
        for (i = 0; i < 12; i++)
        {
            /* Sum: '<S1158>/Add' incorporates:
             *  Constant: '<S1158>/Constant'
             *  DataStoreRead: '<S1169>/Data Store Read'
             *  Product: '<S1158>/Matrix Multiply'
             *  Product: '<S1167>/Matrix Multiply'
             *  Sum: '<S1158>/Subtract'
             */
            PremixMatrix_m[i] = (1.0F -
                                 Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a.downmix)
                * Model_Target_Medusa5H1Part3_DW.VLSPax_SLCGain[i] +
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a.MatrixMultiply
                [i];
        }

        /* MATLAB Function: '<S1159>/MATLAB Function' */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Pax/Generate Ramp Trigger/MATLAB Function': '<S1176>:1' */
        /* '<S1176>:1:3' rampOn = 0; */
        /*  DEBUG parameter */
        /*  Trigger ramping if SLC OR Fade is triggered */
        /* '<S1176>:1:6' if(SLC_On || Fade_On) */
        if (rtb_SLC_On ||
                Model_Target_Medusa5H1Part3_B.sf_Fade_Trigger_Generation_a.fadeOn)
        {
            /* MATLAB Function: '<S1168>/control' */
            /* MATLAB Function: '<S1168>/control' */
            /* '<S1176>:1:7' rampOn = 1; */
            /* '<S1176>:1:8' ramp(); */
            Model_Target_control_j(PremixMatrix_m,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_db_per_second,
                                   Model_TargetPreAmpMedusaSurroundLevelControlIndexRtcOut.REQ_ramp_milliseconds,
                                   &Model_Target_Medusa5H1Part3_DW.VLSPax_Freeze,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_frameCount,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_rampCoeff,
                                   Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain);
        }

        /* End of MATLAB Function: '<S1159>/MATLAB Function' */
        for (i = 0; i < 12; i++)
        {
            /* Merge: '<S587>/Merge3' incorporates:
             *  DataStoreRead: '<S1158>/Mixing Gains'
             */
            Model_Target_Medusa5H1Part3_B.Merge3[i] =
                Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain[i];
        }

        /* MATLAB Function: '<S1168>/process' */
        Model_Target_process_e(&Model_Target_Medusa5H1Part3_DW.VLSPax_Freeze,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_currentGain,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_frameCount,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_rampCoeff,
                               Model_Target_Medusa5H1Part3_DW.VLSPax_targetGain);

        /* End of Outputs for S-Function (RTC_NTF): '<S1114>/NTF Trigger' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S587>/Bypass' incorporates:
         *  ActionPort: '<S885>/Action Port'
         */
        /* Merge: '<S587>/Merge' incorporates:
         *  SignalConversion generated from: '<S885>/PremixOut'
         */
        memset(&Model_Target_Medusa5H1Part3_B.Merge[0], 0, 192U * sizeof
               (real32_T));

        /* Merge: '<S587>/Merge1' incorporates:
         *  SignalConversion generated from: '<S885>/FRMixerOut'
         */
        memset(&Model_Target_Medusa5H1Part3_B.Merge1[0], 0, 704U * sizeof
               (real32_T));
        for (i = 0; i < 12; i++)
        {
            /* Merge: '<S587>/Merge2' incorporates:
             *  SignalConversion generated from: '<S885>/DgainsOut'
             */
            Model_Target_Medusa5H1Part3_B.Merge2[i] = 0.0F;

            /* Merge: '<S587>/Merge3' incorporates:
             *  SignalConversion generated from: '<S885>/PgainsOut'
             */
            Model_Target_Medusa5H1Part3_B.Merge3[i] = 0.0F;
        }

        /* End of Outputs for SubSystem: '<S587>/Bypass' */
    }

    /* End of If: '<S587>/If' */
    for (i = 0; i < 18; i++)
    {
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /* Selector: '<S888>/Selector' incorporates:
             *  Merge: '<S587>/Merge'
             */
            Model_Target_Medusa5H1Part3_B.Selector[colIdx + (i << 3)] =
                Model_Target_Medusa5H1Part3_B.Merge[(tmp[i] << 3) + colIdx];
        }
    }

    for (i = 0; i < 6; i++)
    {
        for (colIdx = 0; colIdx < 8; colIdx++)
        {
            /* Selector: '<S888>/Selector1' incorporates:
             *  Merge: '<S587>/Merge'
             */
            Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[colIdx + (i << 3)] =
                Model_Target_Medusa5H1Part3_B.Merge[(tmp_0[i] << 3) + colIdx];
        }
    }

    for (i = 0; i < 22; i++)
    {
        for (colIdx = 0; colIdx < 32; colIdx++)
        {
            /* Selector: '<S888>/Selector4' incorporates:
             *  Merge: '<S587>/Merge1'
             */
            Model_Target_Medusa5H1Part3_B.Selector4[colIdx + (i << 5)] =
                Model_Target_Medusa5H1Part3_B.Merge1[(tmp_1[i] << 5) + colIdx];
        }
    }

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S889>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S889>/NTF Trigger' */
}

/* Update for atomic system: '<S558>/Medusa5H1 Part 3' */
void Model_Target_Medusa5H1Part3_Update(void)
{
    /* Update for If: '<S587>/If' */
    if (Model_Target_Medusa5H1Part3_DW.If_ActiveSubsystem == 0)
    {
        /* Update for IfAction SubSystem: '<S587>/On' incorporates:
         *  ActionPort: '<S887>/Action Port'
         */
        /* Update for Delay: '<S1000>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S887>/Delay6' */
        Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[0] =
            Model_Target_B.sf_fade_l.tgtGains[0];
        Model_Target_Medusa5H1Part3_DW.Delay6_DSTATE[1] =
            Model_Target_B.sf_fade_l.tgtGains[1];

        /* Update for Delay: '<S1000>/Delay2' incorporates:
         *  Constant: '<S887>/Constant3'
         */
        Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE = 0;

        /* Update for Delay: '<S1000>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* Update for Delay: '<S932>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_c =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S932>/Delay2' incorporates:
         *  Constant: '<S887>/Constant3'
         */
        Model_Target_Medusa5H1Part3_DW.Delay2_DSTATE_k = 0;

        /* Update for Delay: '<S932>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_m =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* Update for Delay: '<S1131>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_p =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S1131>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_o =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* Update for Delay: '<S1156>/Delay' */
        Model_Target_Medusa5H1Part3_DW.Delay_DSTATE_e =
            Model_Target_Medusa5H1Part3_B.Selector_p;

        /* Update for Delay: '<S1156>/Delay1' */
        Model_Target_Medusa5H1Part3_DW.Delay1_DSTATE_n =
            Model_Target_Medusa5H1Part3_B.Selector2;

        /* End of Update for SubSystem: '<S587>/On' */
    }

    /* End of Update for If: '<S587>/If' */
}

/* Output and update for function-call system: '<S1203>/init' */
void InitTrigger_Model_141_472_249_99(void)
{
    /* MATLAB Function: '<S1200>/FirGenericInitFcn' */
    /* MATLAB Function: '<S1200>/FirGenericInitFcn' incorporates:
     *  Constant: '<S1191>/filterMapping'
     *  S-Function (TOP_MEX): '<S1198>/TOP2'
     *  S-Function (TOP_MEX): '<S1225>/TOP'
     *  Selector: '<S888>/Selector'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1205>:1' */
    /* '<S1205>:1:3' init(); */
    /*  Generic FIR function to work with M inputs, N outputs and K filters */
    /*  */
    /*  Parameters: */
    /*    u:              input channels [frame size x number of inputs] */
    /*    CoeffsTarget:    coefficient sets [total filter lengths x 1] */
    /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
    /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
    /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
    /*  */
    /*  Global parameters: */
    /*    States:         array of states [totalBufferSize x 1] */
    /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
    /*                    function call [codeWorkMemorySize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericInitFcn': '<S1201>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1201>:1:18' [FrameSize, NumInputs]  = size(u); */
    /* '<S1201>:1:19' NumOutputs = numel(InputMapping); */
    /*  Get the work memory and states size */
    /* '<S1201>:1:25' WorkMemorySize = numel(CodeWorkMemory); */
    /* '<S1201>:1:26' StateBufferSize = numel(StateBuffer); */
    /*  Set correct data types */
    /* '<S1201>:1:29' CoeffsLengths = uint32(CoeffsLengths); */
    /* '<S1201>:1:30' NumCoeffSets = uint32(numel(CoeffsLengths)); */
    /* '<S1201>:1:31' FrameSize = uint32(FrameSize); */
    /* '<S1201>:1:32' NumOutputs = uint32(NumOutputs); */
    /* '<S1201>:1:33' NumInputs = uint32(NumInputs); */
    /* '<S1201>:1:34' WorkMemorySize = uint32(WorkMemorySize); */
    /* '<S1201>:1:35' StateBufferSize = uint32(StateBufferSize); */
    /*  Reconstitute Variant */
    /* '<S1201>:1:38' VariantSelect = char(VariantUint8); */
    /* '<S1201>:1:40' switch(VariantSelect) */
    /* '<S1201>:1:52' case {'Hexagon'} */
    /* '<S1201>:1:53' y = fir_hexagon_init(u, CoeffsTarget, StateBuffer, CoeffsLengths, InputMapping, CoeffsMapping, ... */
    /* '<S1201>:1:54'             FrameSize, NumCoeffSets, NumInputs, NumOutputs, CodeWorkMemory); */
    fir_init(&MedusaDrHoligramFirEq20126CodeWorkMemory[0],
             &Model_Target_Medusa5H1Part3_B.Selector[0],
             &MedusaDrHoligramFirEq62995CoeffsTarget[0],
             &MedusaDrHoligramFirEq12043StateBuffer[0],
             &(Model_Target_PreAmp_p6_b0.MedusaDRHoligramPaddedFilterLengths[0]),
             &(Model_Target_PreAmp_p6_b0.MedusaDRHoligramInputMapping[0]),
             &Model_Target_ConstP.filterMapping_Value[0], 8U, 66U, 18U, 66U,
             &MedusaDrHoligramFirEq20126CodeWorkMemory[0]);

    /* '<S1201>:1:55' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S1207>/init' */
void InitTrigger_Model_141_472_249_224(void)
{
    /* MATLAB Function: '<S1206>/SignalBreakFcn' */
    /* MATLAB Function: '<S1206>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1198>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1209>:1' */
    /* '<S1209>:1:3' init(); */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1208>:1' */
    /* '<S1208>:1:3' y = u; */
    memcpy(&MedusaDrHoligramFirEq62995CoeffsTarget[0],
           &(Model_Target_PreAmp_p6_b1.MedusaDRHoligramFIRCoeffs[0]), 35112U *
           sizeof(real32_T));
}

/* Output and update for function-call system: '<S1214>/init' */
void InitTrigger_Model_141_472_255_172_156(void)
{
    /* MATLAB Function: '<S1213>/PoolIirInit' */
    /* MATLAB Function: '<S1213>/PoolIirInit' incorporates:
     *  Gain: '<S1196>/Gain'
     *  S-Function (TOP_MEX): '<S1210>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1219>:1' */
    /* '<S1219>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1216>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1216>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1216>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1216>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1216>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1216>:1:28' else */
    /* '<S1216>:1:29' switch(VariantStr) */
    /* '<S1216>:1:30' case{"Hexagon"} */
    /* '<S1216>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1216>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1216>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&MedusaDrHoligramIirEq53194states[0],
                 &MedusaDrHoligramIirEq2PoolIirAudioIn[0], 8U, 66U,
                 &(Model_Target_PreAmp_p6_b0.MedusaDRHoligramPoolIirTunableConfigPooliirNumStages
                   [0]), &MedusaDrHoligramIirEq36493PoolIirCoeffs[0],
                 &MedusaDrHoligramIirEq53194states[0], 174257U, 1U, 5280U);

    /* '<S1216>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1222>/init' */
void InitTrigger_Model_141_472_255_172_192(void)
{
    /* MATLAB Function: '<S1221>/SignalBreakFcn' */
    /* MATLAB Function: '<S1221>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1210>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1224>:1' */
    /* '<S1224>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1223>:1' */
    /* '<S1223>:1:3' y = u; */
    memcpy(&MedusaDrHoligramIirEq36493PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p6_b0.MedusaDRHoligramPoolIirTunableConfigpooliirCoeffs
             [0]), 5346U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S1232>/init' */
void InitTrigger_Model_141_473_12_172_156(void)
{
    /* MATLAB Function: '<S1231>/PoolIirInit' */
    /* MATLAB Function: '<S1231>/PoolIirInit' incorporates:
     *  Gain: '<S1227>/Gain'
     *  S-Function (TOP_MEX): '<S1228>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1237>:1' */
    /* '<S1237>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1234>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1234>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1234>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1234>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1234>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1234>:1:28' else */
    /* '<S1234>:1:29' switch(VariantStr) */
    /* '<S1234>:1:30' case{"Hexagon"} */
    /* '<S1234>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1234>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1234>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&HoligramFrIir16314states[0],
                 &HoligramFrIir17389PoolIirAudioIn[0], 32U, 22U,
                 &(Model_Target_PreAmp_p6_b0.MedusaFRHoligramIirConfigPooliirNumStages
                   [0]), &HoligramFrIir29898PoolIirCoeffs[0],
                 &HoligramFrIir16314states[0], 7761U, 1U, 704U);

    /* '<S1234>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1240>/init' */
void InitTrigger_Model_141_473_12_172_192(void)
{
    /* MATLAB Function: '<S1239>/SignalBreakFcn' */
    /* MATLAB Function: '<S1239>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1228>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1242>:1' */
    /* '<S1242>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1241>:1' */
    /* '<S1241>:1:3' y = u; */
    memcpy(&HoligramFrIir29898PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p6_b0.MedusaFRHoligramIirConfigpooliirCoeffs[0]),
           726U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S1250>/init' */
void InitTrigger_Model_141_595_232_99(void)
{
    /* MATLAB Function: '<S1247>/FirGenericInitFcn' */
    /* MATLAB Function: '<S1247>/FirGenericInitFcn' incorporates:
     *  Constant: '<S1193>/filterMapping'
     *  Constant: '<S1193>/filterMapping1'
     *  S-Function (TOP_MEX): '<S1193>/TOP2'
     *  Selector: '<S888>/Selector1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1252>:1' */
    /* '<S1252>:1:3' init(); */
    /*  Generic FIR function to work with M inputs, N outputs and K filters */
    /*  */
    /*  Parameters: */
    /*    u:              input channels [frame size x number of inputs] */
    /*    CoeffsTarget:    coefficient sets [total filter lengths x 1] */
    /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
    /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
    /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
    /*  */
    /*  Global parameters: */
    /*    States:         array of states [totalBufferSize x 1] */
    /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
    /*                    function call [codeWorkMemorySize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericInitFcn': '<S1248>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1248>:1:18' [FrameSize, NumInputs]  = size(u); */
    /* '<S1248>:1:19' NumOutputs = numel(InputMapping); */
    /*  Get the work memory and states size */
    /* '<S1248>:1:25' WorkMemorySize = numel(CodeWorkMemory); */
    /* '<S1248>:1:26' StateBufferSize = numel(StateBuffer); */
    /*  Set correct data types */
    /* '<S1248>:1:29' CoeffsLengths = uint32(CoeffsLengths); */
    /* '<S1248>:1:30' NumCoeffSets = uint32(numel(CoeffsLengths)); */
    /* '<S1248>:1:31' FrameSize = uint32(FrameSize); */
    /* '<S1248>:1:32' NumOutputs = uint32(NumOutputs); */
    /* '<S1248>:1:33' NumInputs = uint32(NumInputs); */
    /* '<S1248>:1:34' WorkMemorySize = uint32(WorkMemorySize); */
    /* '<S1248>:1:35' StateBufferSize = uint32(StateBufferSize); */
    /*  Reconstitute Variant */
    /* '<S1248>:1:38' VariantSelect = char(VariantUint8); */
    /* '<S1248>:1:40' switch(VariantSelect) */
    /* '<S1248>:1:52' case {'Hexagon'} */
    /* '<S1248>:1:53' y = fir_hexagon_init(u, CoeffsTarget, StateBuffer, CoeffsLengths, InputMapping, CoeffsMapping, ... */
    /* '<S1248>:1:54'             FrameSize, NumCoeffSets, NumInputs, NumOutputs, CodeWorkMemory); */
    fir_init(&DrHeadrestFirEq31952CodeWorkMemory[0],
             &Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[0],
             &DrHeadrestFirEq63094CoeffsTarget[0],
             &DrHeadrestFirEq6203StateBuffer[0],
             &(Model_Target_PreAmp_p6_b0.MedusaHeadrestCompEQPaddedFilterLengths[
               0]), &Model_Target_ConstP.filterMapping1_Value[0],
             &Model_Target_ConstP.filterMapping_Value_a[0], 8U, 12U, 6U, 12U,
             &DrHeadrestFirEq31952CodeWorkMemory[0]);

    /* '<S1248>:1:55' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S1254>/init' */
void InitTrigger_Model_141_595_232_224(void)
{
    /* MATLAB Function: '<S1253>/SignalBreakFcn' */
    /* MATLAB Function: '<S1253>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1193>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1256>:1' */
    /* '<S1256>:1:3' init(); */
    /* MATLAB Function 'Fir/Fir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1255>:1' */
    /* '<S1255>:1:3' y = u; */
    memcpy(&DrHeadrestFirEq63094CoeffsTarget[0],
           &(Model_Target_PreAmp_p6_b1.MedusaHeadrestCompEQFIRCoeffs[0]), 6384U *
           sizeof(real32_T));
}

/* Output and update for function-call system: '<S1261>/init' */
void InitTrigger_Model_141_595_238_172_156(void)
{
    /* MATLAB Function: '<S1260>/PoolIirInit' */
    /* MATLAB Function: '<S1260>/PoolIirInit' incorporates:
     *  Gain: '<S1245>/Gain'
     *  S-Function (TOP_MEX): '<S1257>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1266>:1' */
    /* '<S1266>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1263>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1263>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1263>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1263>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1263>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1263>:1:28' else */
    /* '<S1263>:1:29' switch(VariantStr) */
    /* '<S1263>:1:30' case{"Hexagon"} */
    /* '<S1263>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1263>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1263>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&VlsHeadrestEq57429states[0], &VlsHeadrestEq2098PoolIirAudioIn
                 [0], 8U, 12U,
                 &(Model_Target_PreAmp_p6_b0.MedusaHeadrestCompEQIirConfigPooliirNumStages
                   [0]), &VlsHeadrestEq15002PoolIirCoeffs[0],
                 &VlsHeadrestEq57429states[0], 5777U, 1U, 960U);

    /* '<S1263>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1269>/init' */
void InitTrigger_Model_141_595_238_172_192(void)
{
    /* MATLAB Function: '<S1268>/SignalBreakFcn' */
    /* MATLAB Function: '<S1268>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1257>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1271>:1' */
    /* '<S1271>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1270>:1' */
    /* '<S1270>:1:3' y = u; */
    memcpy(&VlsHeadrestEq15002PoolIirCoeffs[0],
           &(Model_Target_PreAmp_p6_b0.MedusaHeadrestCompEQIirConfigpooliirCoeffs
             [0]), 972U * sizeof(real32_T));
}

/* Output and update for function-call system: '<S1190>/REQ' */
void HandleReqPreAmpMedusaHoligramDisable(void)
{
    /* Outputs for Function Call SubSystem: '<S588>/Enable State Write' */
    /* DataStoreWrite: '<S1188>/Data Store Write' incorporates:
     *  Constant: '<S1188>/Constant'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1275>:1' */
    /* '<S1275>:1:3' go(); */
    Model_Target_Medusa5H1Part4_DW.MedusaHoligramEnable = 0U;

    /* End of Outputs for SubSystem: '<S588>/Enable State Write' */
}

/* Function for MATLAB Function: '<S1191>/Sum Channels' */
static void Model_Target_sum(const real32_T x_data[], const int32_T x_size[2],
    real32_T y[8])
{
    int32_T b_xj;
    int32_T i;
    int32_T xj;
    i = x_size[1];
    if (x_size[1] == 0)
    {
        for (i = 0; i < 8; i++)
        {
            y[i] = 0.0F;
        }
    }
    else
    {
        for (xj = 0; xj < 8; xj++)
        {
            y[xj] = x_data[xj];
        }

        for (xj = 2; xj <= i; xj++)
        {
            int32_T xoffset;
            xoffset = (xj - 1) << 3;
            for (b_xj = 0; b_xj < 8; b_xj++)
            {
                y[b_xj] += x_data[xoffset + b_xj];
            }
        }
    }
}

/* System initialize for atomic system: '<S558>/Medusa5H1 Part 4' */
void Model_Target_Medusa5H1Part4_Init(void)
{
    /* Start for If: '<S588>/If' */
    Model_Target_Medusa5H1Part4_DW.If_ActiveSubsystem = -1;

    /* Start for DataStoreMemory: '<S588>/Data Store Memory' */
    Model_Target_Medusa5H1Part4_DW.MedusaHoligramEnable = 1U;

    /* SystemInitialize for IfAction SubSystem: '<S588>/On' */

    /* user code (Initialize function Body) */

    /* InitTriggerControl '<S1207>/ITC1' */
    InitTrigger_Model_141_472_249_224();

    /* InitTriggerControl '<S1203>/ITC1' */
    InitTrigger_Model_141_472_249_99();

    /* InitTriggerControl '<S1222>/ITC1' */
    InitTrigger_Model_141_472_255_172_192();

    /* InitTriggerControl '<S1214>/ITC1' */
    InitTrigger_Model_141_472_255_172_156();

    /* InitTriggerControl '<S1254>/ITC1' */
    InitTrigger_Model_141_595_232_224();

    /* InitTriggerControl '<S1250>/ITC1' */
    InitTrigger_Model_141_595_232_99();

    /* InitTriggerControl '<S1269>/ITC1' */
    InitTrigger_Model_141_595_238_172_192();

    /* InitTriggerControl '<S1261>/ITC1' */
    InitTrigger_Model_141_595_238_172_156();

    /* InitTriggerControl '<S1240>/ITC1' */
    InitTrigger_Model_141_473_12_172_192();

    /* InitTriggerControl '<S1232>/ITC1' */
    InitTrigger_Model_141_473_12_172_156();

    /* End of SystemInitialize for SubSystem: '<S588>/On' */
}

/* Output and update for atomic system: '<S558>/Medusa5H1 Part 4' */
void Model_Target_Medusa5H1Part4(void)
{
    int32_T delayChans[66];
    int32_T delayChans_0[12];
    int32_T rtb_y_k_size[2];
    int32_T i;
    int32_T i_0;
    int32_T readIdx;
    int32_T writeIdx;
    real32_T rtb_y_gq[144];
    real32_T rtb_y_mg[96];
    real32_T tmp[96];
    int8_T rtAction;
    int8_T rtPrevAction;

    /* If: '<S588>/If' incorporates:
     *  DataStoreRead: '<S588>/Enable State Read'
     */
    rtPrevAction = Model_Target_Medusa5H1Part4_DW.If_ActiveSubsystem;
    rtAction = (int8_T)(Model_Target_Medusa5H1Part4_DW.MedusaHoligramEnable <=
                        0U);
    Model_Target_Medusa5H1Part4_DW.If_ActiveSubsystem = rtAction;
    if ((rtPrevAction != rtAction) && (rtPrevAction == 0))
    {
    }

    if (rtAction == 0)
    {
        int32_T loop_ub;
        if (rtPrevAction != 0)
        {
        }

        /* S-Function (TOP_MEX): '<S1198>/TOP1' */
        /*  Generic FIR function to work with M inputs, N outputs and K filters */
        /*  */
        /*  Parameters: */
        /*    u:              input channels [frame size x number of inputs] */
        /*    CoeffsTarget:   coefficient sets, translated to target specfic format [total filter lengths x 1] */
        /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
        /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
        /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
        /*    VariantStr:     string corresponding to the variant type */
        /*  */
        /*  Global parameters: */
        /*    States:         array of states [totalBufferSize x 1] */
        /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
        /*                    function call [codeWorkMemorySize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericProcessFcn': '<S1202>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1202>:1:20' [FrameSize, ~]  = size(u); */
        /* '<S1202>:1:21' NumOutputs = numel(InputMapping); */
        /*  Define persistent variables for SharcPlusAccel Variant */
        /*  Set correct data types */
        /* '<S1202>:1:29' CoeffsLengths = uint32(CoeffsLengths); */
        /* '<S1202>:1:30' FrameSize = uint32(FrameSize); */
        /* '<S1202>:1:31' NumOutputs = uint32(NumOutputs); */
        /* '<S1202>:1:32' InputMapping = uint32(InputMapping); */
        /*  Reconstitute Variant */
        /* '<S1202>:1:35' VariantSelect = char(VariantUint8); */
        /*  Simulation */
        /* '<S1202>:1:38' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1202>:1:58' else */
        /* '<S1202>:1:59' switch(VariantSelect) */
        /* '<S1202>:1:65' case {'Hexagon'} */
        /* '<S1202>:1:66' y = fir_hexagon_process(u, CodeWorkMemory, NumOutputs); */
        /* MATLAB Function: '<S1191>/Delay Line Update' incorporates:
         *  S-Function (TOP_MEX): '<S1198>/TOP1'
         *  S-Function (TOP_MEX): '<S1225>/TOP'
         *  Selector: '<S888>/Selector'
         */
        /*  Note: This block only reads 'states' to get the delayed samples. A */
        /*  separate function is responsible for writing to 'states' to update the  */
        /*  delay line Data Store Memory. Thus it is important to ensure all DSM   */
        /*  write happens before DSM read. */
        /*  */
        /*  This is different from pooldelay, as the delay for ALL channel is */
        /*  intentionally set to be the max amount to allow for 'double' sharing */
        /*  between FIR filter and delay buffer. */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 4/On/DR Mix Matrix with Hybrid Holigram EQ/Delay Line Update': '<S1194>:1' */
        /* '<S1194>:1:15' numOutput = numel(delayChans); */
        /* '<S1194>:1:16' [frameSize, numChannelIn] = size(u); */
        /* '<S1194>:1:17' y = single(zeros(frameSize, numOutput)); */
        /* '<S1194>:1:18' delayChans = int32(delayChans); */
        for (i = 0; i < 66; i++)
        {
            delayChans[i] = (int32_T)
                Model_Target_PreAmp_p6_b0.MedusaDRHoligramFilterLengths[i];
        }

        /*  Write incoming input to delay line */
        /* '<S1194>:1:21' writeIdx = stateIndex; */
        writeIdx = Model_Target_Medusa5H1Part4_DW.stateIndex;

        /* '<S1194>:1:22' for sample = 1:frameSize */
        for (readIdx = 0; readIdx < 8; readIdx++)
        {
            /* '<S1194>:1:23' for i = 1:numChannelIn */
            for (i = 0; i < 18; i++)
            {
                /* '<S1194>:1:24' states(writeIdx+1,i) = u(sample, i); */
                PeripheralDelayBuffer[writeIdx + 660 * i] =
                    Model_Target_Medusa5H1Part3_B.Selector[(i << 3) + readIdx];

                /*  add 1 for Matlab indexing */
            }

            /* '<S1194>:1:26' writeIdx = circindex(writeIdx, int32(1), fixedDelayLength); */
            writeIdx = circindex(writeIdx, 1, Model_Target_fixedDelayLength);
        }

        /* '<S1194>:1:28' stateIndex = writeIdx; */
        Model_Target_Medusa5H1Part4_DW.stateIndex = writeIdx;

        /*  Read out values from delay line */
        /* '<S1194>:1:31' for i = 1:numOutput */
        for (writeIdx = 0; writeIdx < 66; writeIdx++)
        {
            /* '<S1194>:1:32' inputIdx = inputMapping(i); */
            /*  which input to delay */
            /* '<S1194>:1:33' delay = delayChans(i); */
            /*  delay amount */
            /* '<S1194>:1:34' offset = - (delay + frameSize); */
            /*  offset from start index */
            /* '<S1194>:1:35' readIdx = circindex(stateIndex, offset, fixedDelayLength); */
            readIdx = circindex(Model_Target_Medusa5H1Part4_DW.stateIndex,
                                -(delayChans[writeIdx] + 8),
                                Model_Target_fixedDelayLength);

            /* '<S1194>:1:37' for sample = 1:frameSize */
            for (i = 0; i < 8; i++)
            {
                /* '<S1194>:1:38' y(sample, i) = states(readIdx+1, inputIdx+1); */
                Model_Target_Medusa5H1Part4_B.y_k[i + (writeIdx << 3)] =
                    PeripheralDelayBuffer[660 * (int32_T)
                    Model_Target_PreAmp_p6_b0.MedusaDRHoligramInputMapping[writeIdx]
                    + readIdx];

                /*  add 1 for Matlab indexing */
                /* '<S1194>:1:39' readIdx = circindex(readIdx, int32(1), fixedDelayLength); */
                readIdx = circindex(readIdx, 1, Model_Target_fixedDelayLength);
            }
        }

        /* End of MATLAB Function: '<S1191>/Delay Line Update' */

        /* Gain: '<S1196>/Gain' */
        memcpy(&MedusaDrHoligramIirEq2PoolIirAudioIn[0],
               &Model_Target_Medusa5H1Part4_B.y_k[0], 528U * sizeof(real32_T));

        /* MATLAB Function: '<S1213>/PoolIirProcess' incorporates:
         *  Gain: '<S1196>/Gain'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1217>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1217>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1217>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1217>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1217>:1:29' else */
        /* '<S1217>:1:30' switch(VariantStr) */
        /* '<S1217>:1:31' case{"Hexagon"} */
        /* '<S1217>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        pooliir_process(&MedusaDrHoligramIirEq3543PoolIirAudioOut[0],
                        &MedusaDrHoligramIirEq2PoolIirAudioIn[0],
                        &MedusaDrHoligramIirEq53194states[0]);

        /* MATLAB Function: '<S1200>/FirGenericProcessFcn' incorporates:
         *  Selector: '<S888>/Selector'
         */
        fir_process(&Model_Target_Medusa5H1Part4_B.y_k[0],
                    &Model_Target_Medusa5H1Part3_B.Selector[0],
                    &MedusaDrHoligramFirEq20126CodeWorkMemory[0], 66U);

        /* Sum: '<S1191>/Add' incorporates:
         *  MATLAB Function: '<S1200>/FirGenericProcessFcn'
         */
        for (i = 0; i < 528; i++)
        {
            Model_Target_Medusa5H1Part4_B.y_k[i] +=
                MedusaDrHoligramIirEq3543PoolIirAudioOut[i];
        }

        /* End of Sum: '<S1191>/Add' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1207>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1203>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1222>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1214>/ITC1' */
        /* MATLAB Function: '<S1191>/Sum Channels' incorporates:
         *  S-Function (TOP_MEX): '<S1226>/TOP'
         *  Sum: '<S1191>/Add'
         */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 4/On/DR Mix Matrix with Hybrid Holigram EQ/Sum Channels': '<S1197>:1' */
        /* '<S1197>:1:2' [frame_size, ~] = size(in); */
        /* '<S1197>:1:3' [num_output, ~] = size(startIdx); */
        /* '<S1197>:1:5' y = coder.nullcopy(single(zeros(frame_size, num_output))); */
        /* '<S1197>:1:6' for iter = 1:num_output-1 */
        for (writeIdx = 0; writeIdx < 17; writeIdx++)
        {
            real32_T tmp_0;

            /* '<S1197>:1:7' start_idx = startIdx(iter); */
            /* '<S1197>:1:8' end_idx = startIdx(iter+1)-1; */
            /* '<S1197>:1:9' y(:,iter) = sum(in(:,start_idx+1:end_idx+1),2); */
            tmp_0 =
                (Model_Target_PreAmp_p6_b0.MedusaDRHoligramOutputMapping[writeIdx
                 + 1] - 1.0F) + 1.0F;
            if (Model_Target_PreAmp_p6_b0.MedusaDRHoligramOutputMapping[writeIdx]
                + 1.0F > tmp_0)
            {
                readIdx = 0;
                i = 0;
            }
            else
            {
                readIdx = (int32_T)
                    (Model_Target_PreAmp_p6_b0.MedusaDRHoligramOutputMapping[writeIdx]
                     + 1.0F) - 1;
                i = (int32_T)tmp_0;
            }

            rtb_y_k_size[0] = 8;
            loop_ub = i - readIdx;
            rtb_y_k_size[1] = loop_ub;
            for (i = 0; i < loop_ub; i++)
            {
                for (i_0 = 0; i_0 < 8; i_0++)
                {
                    Model_Target_Medusa5H1Part4_B.rtb_y_k_data[i_0 + (i << 3)] =
                        Model_Target_Medusa5H1Part4_B.y_k[((readIdx + i) << 3) +
                        i_0];
                }
            }

            Model_Target_sum(Model_Target_Medusa5H1Part4_B.rtb_y_k_data,
                             rtb_y_k_size, &rtb_y_gq[writeIdx << 3]);
        }

        /* '<S1197>:1:11' start_idx = startIdx(end); */
        /* '<S1197>:1:12' y(:,end) = sum(in(:,start_idx+1:end),2); */
        if (Model_Target_PreAmp_p6_b0.MedusaDRHoligramOutputMapping[17] + 1.0F >
            66.0F)
        {
            writeIdx = 0;
            readIdx = 0;
        }
        else
        {
            writeIdx = (int32_T)
                (Model_Target_PreAmp_p6_b0.MedusaDRHoligramOutputMapping[17] +
                 1.0F) - 1;
            readIdx = 66;
        }

        rtb_y_k_size[0] = 8;
        loop_ub = readIdx - writeIdx;
        rtb_y_k_size[1] = loop_ub;
        for (i = 0; i < loop_ub; i++)
        {
            for (i_0 = 0; i_0 < 8; i_0++)
            {
                Model_Target_Medusa5H1Part4_B.rtb_y_k_data[i_0 + (i << 3)] =
                    Model_Target_Medusa5H1Part4_B.y_k[((writeIdx + i) << 3) +
                    i_0];
            }
        }

        Model_Target_sum(Model_Target_Medusa5H1Part4_B.rtb_y_k_data,
                         rtb_y_k_size, &rtb_y_gq[136]);

        /* End of MATLAB Function: '<S1191>/Sum Channels' */
        /* SignalConversion generated from: '<S1189>/PeripheralOut' incorporates:
         *  Concatenate: '<S1279>/Matrix Concatenate'
         */
        memcpy(&Model_Target_Medusa5H1Part5_B.MatrixConcatenate[0], &rtb_y_gq[0],
               144U * sizeof(real32_T));

        /* S-Function (TOP_MEX): '<S1193>/TOP1' */
        /*  Generic FIR function to work with M inputs, N outputs and K filters */
        /*  */
        /*  Parameters: */
        /*    u:              input channels [frame size x number of inputs] */
        /*    CoeffsTarget:   coefficient sets, translated to target specfic format [total filter lengths x 1] */
        /*    CoeffsLengths:  array of filter lengths [number of filters x 1] */
        /*    InputMapping:   zero-based input mapping for each filter  [number of outputs x 1] */
        /*    CoeffsMapping:  zero-based filter mapping for each filter [number of outputs x 1] */
        /*    VariantStr:     string corresponding to the variant type */
        /*  */
        /*  Global parameters: */
        /*    States:         array of states [totalBufferSize x 1] */
        /*    CodeWorkMemory: working memory set up during roommode reset/init CRL */
        /*                    function call [codeWorkMemorySize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'Fir/Fir/TargetSpecific/FirGenericProcessFcn': '<S1249>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1249>:1:20' [FrameSize, ~]  = size(u); */
        /* '<S1249>:1:21' NumOutputs = numel(InputMapping); */
        /*  Define persistent variables for SharcPlusAccel Variant */
        /*  Set correct data types */
        /* '<S1249>:1:29' CoeffsLengths = uint32(CoeffsLengths); */
        /* '<S1249>:1:30' FrameSize = uint32(FrameSize); */
        /* '<S1249>:1:31' NumOutputs = uint32(NumOutputs); */
        /* '<S1249>:1:32' InputMapping = uint32(InputMapping); */
        /*  Reconstitute Variant */
        /* '<S1249>:1:35' VariantSelect = char(VariantUint8); */
        /*  Simulation */
        /* '<S1249>:1:38' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1249>:1:58' else */
        /* '<S1249>:1:59' switch(VariantSelect) */
        /* '<S1249>:1:65' case {'Hexagon'} */
        /* '<S1249>:1:66' y = fir_hexagon_process(u, CodeWorkMemory, NumOutputs); */
        /* MATLAB Function: '<S1193>/Delay Line Update' incorporates:
         *  Constant: '<S1193>/filterMapping1'
         *  S-Function (TOP_MEX): '<S1193>/TOP1'
         *  Selector: '<S888>/Selector1'
         */
        /*  Note: This block only reads 'states' to get the delayed samples. A */
        /*  separate function is responsible for writing to 'states' to update the  */
        /*  delay line Data Store Memory. Thus it is important to ensure all DSM   */
        /*  write happens before DSM read. */
        /*  */
        /*  This is different from pooldelay, as the delay for ALL channel is */
        /*  intentionally set to be the max amount to allow for 'double' sharing */
        /*  between FIR filter and delay buffer. */
        /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 4/On/Headrest Comp EQ/Delay Line Update': '<S1243>:1' */
        /* '<S1243>:1:15' numOutput = numel(delayChans); */
        /* '<S1243>:1:16' [frameSize, numChannelIn] = size(u); */
        /* '<S1243>:1:17' y = single(zeros(frameSize, numOutput)); */
        /* '<S1243>:1:18' delayChans = int32(delayChans); */
        for (i = 0; i < 12; i++)
        {
            delayChans_0[i] = (int32_T)
                Model_Target_PreAmp_p6_b0.MedusaHeadrestCompEQFilterLengths[i];
        }

        /*  Write incoming input to delay line */
        /* '<S1243>:1:21' writeIdx = stateIndex; */
        writeIdx = Model_Target_Medusa5H1Part4_DW.stateIndex_e;

        /* '<S1243>:1:22' for sample = 1:frameSize */
        for (readIdx = 0; readIdx < 8; readIdx++)
        {
            /* '<S1243>:1:23' for i = 1:numChannelIn */
            for (i = 0; i < 6; i++)
            {
                /* '<S1243>:1:24' states(writeIdx+1,i) = u(sample, i); */
                Model_Target_Medusa5H1Part4_DW.states[writeIdx + 540 * i] =
                    Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[(i << 3) +
                    readIdx];

                /*  add 1 for Matlab indexing */
            }

            /* '<S1243>:1:26' writeIdx = circindex(writeIdx, int32(1), fixedDelayLength); */
            writeIdx = circindex(writeIdx, 1, Model_Target_fixedDelayLength_l);
        }

        /* '<S1243>:1:28' stateIndex = writeIdx; */
        Model_Target_Medusa5H1Part4_DW.stateIndex_e = writeIdx;

        /*  Read out values from delay line */
        /* '<S1243>:1:31' for i = 1:numOutput */
        for (writeIdx = 0; writeIdx < 12; writeIdx++)
        {
            /* '<S1243>:1:32' inputIdx = inputMapping(i); */
            /*  which input to delay */
            /* '<S1243>:1:33' delay = delayChans(i); */
            /*  delay amount */
            /* '<S1243>:1:34' offset = - (delay + frameSize); */
            /*  offset from start index */
            /* '<S1243>:1:35' readIdx = circindex(stateIndex, offset, fixedDelayLength); */
            readIdx = circindex(Model_Target_Medusa5H1Part4_DW.stateIndex_e,
                                -(delayChans_0[writeIdx] + 8),
                                Model_Target_fixedDelayLength_l);

            /* '<S1243>:1:37' for sample = 1:frameSize */
            for (i = 0; i < 8; i++)
            {
                /* '<S1243>:1:38' y(sample, i) = states(readIdx+1, inputIdx+1); */
                rtb_y_mg[i + (writeIdx << 3)] =
                    Model_Target_Medusa5H1Part4_DW.states[540 * (int32_T)
                    Model_Target_ConstP.filterMapping1_Value[writeIdx] + readIdx];

                /*  add 1 for Matlab indexing */
                /* '<S1243>:1:39' readIdx = circindex(readIdx, int32(1), fixedDelayLength); */
                readIdx = circindex(readIdx, 1, Model_Target_fixedDelayLength_l);
            }
        }

        /* End of MATLAB Function: '<S1193>/Delay Line Update' */

        /* Gain: '<S1245>/Gain' */
        memcpy(&VlsHeadrestEq2098PoolIirAudioIn[0], &rtb_y_mg[0], 96U * sizeof
               (real32_T));

        /* MATLAB Function: '<S1260>/PoolIirProcess' incorporates:
         *  Gain: '<S1245>/Gain'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1264>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1264>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1264>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1264>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1264>:1:29' else */
        /* '<S1264>:1:30' switch(VariantStr) */
        /* '<S1264>:1:31' case{"Hexagon"} */
        /* '<S1264>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        pooliir_process(&VlsHeadrestEq817PoolIirAudioOut[0],
                        &VlsHeadrestEq2098PoolIirAudioIn[0],
                        &VlsHeadrestEq57429states[0]);

        /* MATLAB Function: '<S1247>/FirGenericProcessFcn' incorporates:
         *  Selector: '<S888>/Selector1'
         */
        fir_process(&tmp[0], &Model_Target_Medusa5H1Part3_B.LoRoLsRsLsrRsr[0],
                    &DrHeadrestFirEq31952CodeWorkMemory[0], 12U);

        /* Sum: '<S1193>/Add' incorporates:
         *  Concatenate: '<S1279>/Matrix Concatenate'
         *  MATLAB Function: '<S1247>/FirGenericProcessFcn'
         */
        for (i = 0; i < 96; i++)
        {
            Model_Target_Medusa5H1Part5_B.MatrixConcatenate[i + 152] = tmp[i] +
                VlsHeadrestEq817PoolIirAudioOut[i];
        }

        /* End of Sum: '<S1193>/Add' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1254>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1250>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1269>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1261>/ITC1' */
        /* Gain: '<S1227>/Gain' incorporates:
         *  Selector: '<S888>/Selector4'
         */
        memcpy(&HoligramFrIir17389PoolIirAudioIn[0],
               &Model_Target_Medusa5H1Part3_B.Selector4[0], 704U * sizeof
               (real32_T));

        /* End of Outputs for S-Function (InitTriggerControl): '<S1240>/ITC1' */
        /* End of Outputs for S-Function (InitTriggerControl): '<S1232>/ITC1' */

        /* MATLAB Function: '<S1231>/PoolIirProcess' incorporates:
         *  Gain: '<S1227>/Gain'
         */
        /*  Process function for Pooliir */
        /*  */
        /*  Parameters: */
        /*    x:              input channels [frame size x number of inputs] */
        /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
        /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
        /*   */
        /*  Global parameters: */
        /*    states: working memory set up during roommode reset/init CRL */
        /*                    function call [StatesSize x 1] */
        /* -------------------------------------------------------------------------- */
        /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1235>:1' */
        /*  Extract configuration information from inputs */
        /* '<S1235>:1:15' [~, NumChannels] = size(x); */
        /*  Initialize variables */
        /* '<S1235>:1:20' VariantStr = char(VariantUint8); */
        /* '<S1235>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
        /* '<S1235>:1:29' else */
        /* '<S1235>:1:30' switch(VariantStr) */
        /* '<S1235>:1:31' case{"Hexagon"} */
        /* '<S1235>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
        pooliir_process(&HoligramFrIir16350PoolIirAudioOut[0],
                        &HoligramFrIir17389PoolIirAudioIn[0],
                        &HoligramFrIir16314states[0]);

        /* Merge: '<S588>/Merge2' incorporates:
         *  Gain: '<S1238>/Gain'
         */
        memcpy(&Model_Target_Medusa5H1Part4_B.Merge2[0],
               &HoligramFrIir16350PoolIirAudioOut[0], 704U * sizeof(real32_T));
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S588>/Bypass' incorporates:
         *  ActionPort: '<S1187>/Action Port'
         */
        /* SignalConversion generated from: '<S1187>/PeripheralOut' incorporates:
         *  Concatenate: '<S1279>/Matrix Concatenate'
         */
        memset(&Model_Target_Medusa5H1Part5_B.MatrixConcatenate[0], 0, 144U *
               sizeof(real32_T));

        /* SignalConversion generated from: '<S1187>/HeadrestOut' incorporates:
         *  Concatenate: '<S1279>/Matrix Concatenate'
         */
        memset(&Model_Target_Medusa5H1Part5_B.MatrixConcatenate[152], 0, 96U *
               sizeof(real32_T));

        /* Merge: '<S588>/Merge2' incorporates:
         *  SignalConversion generated from: '<S1187>/FROut'
         */
        memset(&Model_Target_Medusa5H1Part4_B.Merge2[0], 0, 704U * sizeof
               (real32_T));

        /* End of Outputs for SubSystem: '<S588>/Bypass' */
    }

    /* End of If: '<S588>/If' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1190>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1190>/NTF Trigger' */
}

/* Output and update for function-call system: '<S1280>/REQ' */
void HandleReqPreAmpMedusaOverheadHoligramDisable(void)
{
    /* Outputs for Function Call SubSystem: '<S589>/Triggered Subsystem' */
    /* DataStoreWrite: '<S1281>/Data Store Write' incorporates:
     *  Constant: '<S1281>/Constant'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1287>:1' */
    /* '<S1287>:1:3' go(); */
    Model_Target_Medusa5H1Part5_DW.MedusaOverheadHoligramEnable = 0.0;

    /* End of Outputs for SubSystem: '<S589>/Triggered Subsystem' */
}

/* System initialize for atomic system: '<S558>/Medusa5H1 Part 5' */
void Model_Target_Medusa5H1Part5_Init(void)
{
    /* Start for DataStoreMemory: '<S589>/Data Store Memory' */
    Model_Target_Medusa5H1Part5_DW.MedusaOverheadHoligramEnable = 1.0;
}

/* Outputs for atomic system: '<S558>/Medusa5H1 Part 5' */
void Model_Target_Medusa5H1Part5(void)
{
    int32_T i;
    int32_T i_0;
    static const int8_T tmp[30] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21,
        22, 23, 24, 25, 26, 27, 28, 29, 30
    };

    /* If: '<S589>/If' incorporates:
     *  Constant: '<S1283>/Constant'
     *  DataStoreRead: '<S589>/Data Store Read'
     */
    if (Model_Target_Medusa5H1Part5_DW.MedusaOverheadHoligramEnable > 0.0)
    {
        /* Outputs for IfAction SubSystem: '<S589>/On' incorporates:
         *  ActionPort: '<S1279>/Action Port'
         */
        for (i = 0; i < 8; i++)
        {
            Model_Target_Medusa5H1Part5_B.MatrixConcatenate[i + 144] = 0.0F;
        }

        for (i = 0; i < 30; i++)
        {
            for (i_0 = 0; i_0 < 8; i_0++)
            {
                /* Merge: '<S589>/Merge' incorporates:
                 *  Concatenate: '<S1279>/Matrix Concatenate'
                 *  Selector: '<S1279>/Selector'
                 */
                Model_Target_Medusa5H1Part5_B.Merge[i_0 + (i << 3)] =
                    Model_Target_Medusa5H1Part5_B.MatrixConcatenate[(tmp[i] << 3)
                    + i_0];
            }
        }

        /* Merge: '<S589>/Merge1' incorporates:
         *  Constant: '<S1283>/Constant'
         *  Merge: '<S588>/Merge2'
         *  SignalConversion generated from: '<S1279>/FRMixerOut'
         */
        memcpy(&Model_Target_Medusa5H1Part5_B.Merge1[0],
               &Model_Target_Medusa5H1Part4_B.Merge2[0], 704U * sizeof(real32_T));

        /* End of Outputs for SubSystem: '<S589>/On' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S589>/Bypass' incorporates:
         *  ActionPort: '<S1278>/Action Port'
         */
        /* Merge: '<S589>/Merge' incorporates:
         *  SignalConversion generated from: '<S1278>/DRBypass'
         */
        memset(&Model_Target_Medusa5H1Part5_B.Merge[0], 0, 240U * sizeof
               (real32_T));

        /* Merge: '<S589>/Merge1' incorporates:
         *  SignalConversion generated from: '<S1278>/FRBypass'
         */
        memset(&Model_Target_Medusa5H1Part5_B.Merge1[0], 0, 704U * sizeof
               (real32_T));

        /* End of Outputs for SubSystem: '<S589>/Bypass' */
    }

    /* End of If: '<S589>/If' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1280>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1280>/NTF Trigger' */
}

/* System initialize for atomic system: '<S558>/Medusa5H1 Part 6' */
void Model_Target_Medusa5H1Part6_Init(void)
{
    /* '<S1293>:1:18' delayIndex = int32(0); */
    /* '<S1294>:1:18' delayIndex = int32(0); */
}

/* Output and update for atomic system: '<S558>/Medusa5H1 Part 6' */
void Model_Target_Medusa5H1Part6(void)
{
    int32_T bufferIndex;
    int32_T channel;
    int32_T sample;
    int32_T writeIndex;

    /* MATLAB Function: '<S1290>/MATLAB Function' incorporates:
     *  Merge: '<S589>/Merge'
     *  S-Function (TOP_MEX): '<S1292>/TOP5'
     */
    /* [Param: maxDelay] */
    /* MATLAB Function 'MedusaTunableDelay/MATLAB Function': '<S1293>:1' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /*  figure out the frame size and channel count */
    /* '<S1293>:1:9' [frameSize, numChannels] = size(audioIn); */
    /* '<S1293>:1:10' frameSize = int32(frameSize); */
    /* '<S1293>:1:11' stateLen = int32(maxDelay)+frameSize; */
    /* '<S1293>:1:12' totalLen = int32(stateLen * numChannels); */
    /* '<S1293>:1:13' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1293>:1:17' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1293>:1:24' bufferIndex = delayIndex; */
    bufferIndex = Model_Target_Medusa5H1Part6_DW.delayIndex_j;

    /* '<S1293>:1:26' for channel = 1:numChannels */
    for (channel = 0; channel < 30; channel++)
    {
        /*  Save writeIndex for next channel */
        /* '<S1293>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(bufferIndex, 0, 10170);

        /* '<S1293>:1:31' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1293>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            DeciRateSpeakerDelay[writeIndex] =
                Model_Target_Medusa5H1Part5_B.Merge[(channel << 3) + sample];

            /*  increment write pointer */
            /* '<S1293>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 10170);
        }

        /*  Advance buffer index for next channel */
        /* '<S1293>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 339, 10170);
    }

    /*  Reset */
    /* '<S1293>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_Medusa5H1Part6_DW.delayIndex_j, 8,
                            10170);

    /* '<S1293>:1:46' delayIndex = bufferIndex; */
    Model_Target_Medusa5H1Part6_DW.delayIndex_j = bufferIndex;

    /*  Read samples from delay line */
    /* '<S1293>:1:49' for channel = 1:numChannels */
    for (channel = 0; channel < 30; channel++)
    {
        /*  Setup read pointer */
        /* '<S1293>:1:52' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(bufferIndex,
                               -(Model_Target_PreAmp_p8_b0.MedusaDRSpeakerDelay[channel]
                                + 8), 10170);

        /* '<S1293>:1:54' for sample = 1:frameSize */
        for (sample = 0; sample < 8; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1293>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_Medusa5H1Part6_B.audioOut_d[sample + (channel << 3)] =
                DeciRateSpeakerDelay[writeIndex];

            /*  increment write pointer */
            /* '<S1293>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 10170);
        }

        /*  Advance buffer index for next channel */
        /* '<S1293>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 339, 10170);
    }

    /* End of MATLAB Function: '<S1290>/MATLAB Function' */
    /* MATLAB Function: '<S1291>/MATLAB Function' incorporates:
     *  Merge: '<S589>/Merge1'
     *  S-Function (TOP_MEX): '<S1292>/TOP3'
     */
    /* [Param: maxDelay] */
    /* MATLAB Function 'MedusaTunableDelay/MATLAB Function': '<S1294>:1' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /*  figure out the frame size and channel count */
    /* '<S1294>:1:9' [frameSize, numChannels] = size(audioIn); */
    /* '<S1294>:1:10' frameSize = int32(frameSize); */
    /* '<S1294>:1:11' stateLen = int32(maxDelay)+frameSize; */
    /* '<S1294>:1:12' totalLen = int32(stateLen * numChannels); */
    /* '<S1294>:1:13' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1294>:1:17' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1294>:1:24' bufferIndex = delayIndex; */
    bufferIndex = Model_Target_Medusa5H1Part6_DW.delayIndex;

    /* '<S1294>:1:26' for channel = 1:numChannels */
    for (channel = 0; channel < 22; channel++)
    {
        /*  Save writeIndex for next channel */
        /* '<S1294>:1:29' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        writeIndex = circindex(bufferIndex, 0, 30822);

        /* '<S1294>:1:31' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1294>:1:34' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            FullRateSpeakerDelay[writeIndex] =
                Model_Target_Medusa5H1Part5_B.Merge1[(channel << 5) + sample];

            /*  increment write pointer */
            /* '<S1294>:1:37' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 30822);
        }

        /*  Advance buffer index for next channel */
        /* '<S1294>:1:41' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 1401, 30822);
    }

    /*  Reset */
    /* '<S1294>:1:45' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_Medusa5H1Part6_DW.delayIndex, 32, 30822);

    /* '<S1294>:1:46' delayIndex = bufferIndex; */
    Model_Target_Medusa5H1Part6_DW.delayIndex = bufferIndex;

    /*  Read samples from delay line */
    /* '<S1294>:1:49' for channel = 1:numChannels */
    for (channel = 0; channel < 22; channel++)
    {
        /*  Setup read pointer */
        /* '<S1294>:1:52' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        writeIndex = circindex(bufferIndex,
                               -(Model_Target_PreAmp_p8_b0.MedusaFRSpeakerDelay[channel]
                                + 32), 30822);

        /* '<S1294>:1:54' for sample = 1:frameSize */
        for (sample = 0; sample < 32; sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1294>:1:57' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_Medusa5H1Part6_B.audioOut[sample + (channel << 5)] =
                FullRateSpeakerDelay[writeIndex];

            /*  increment write pointer */
            /* '<S1294>:1:60' readIndex = circindex(readIndex, int32(1), totalLen); */
            writeIndex = circindex(writeIndex, 1, 30822);
        }

        /*  Advance buffer index for next channel */
        /* '<S1294>:1:65' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        bufferIndex = circindex(bufferIndex, 1401, 30822);
    }

    /* End of MATLAB Function: '<S1291>/MATLAB Function' */
}

/* Output and update for function-call system: '<S1340>/init' */
void InitTrigger_Model_416_65(void)
{
    /* MATLAB Function: '<S1337>/FirEvenInit' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1343>:1' */
    /* '<S1343>:1:3' init(); */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenInit': '<S1338>:1' */
    /* '<S1338>:1:4' [FilterLength, NumFilters] = size(FlippedCoefficients); */
    /* '<S1338>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Simulation  */
    /* '<S1338>:1:10' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1338>:1:12' else */
    /* '<S1338>:1:13' y = fireven_hexagon_init(uint32(FrameSize), uint32(NumChannels), uint32(NumFilters), uint32(FilterLength), single(FlippedCoefficients), uint32(CodeWorkMemory), uint32(MaxNumOfThreds)); */
    fireven_init(&NearWiggle50534CodeWorkMemory[0], 8U, 2U, 2U, 1024U,
                 &NearWiggle35727FirEvenCoeffs[0],
                 &NearWiggle50534CodeWorkMemory[0], 1U);

    /*  NOTE: The CRL mechanism requires an output for the function call, */
    /*  and appears to be optimized out if that return value isn't used.  */
    /*  This is a dummy operation to make sure CRL ends up in generated code */
    /* '<S1338>:1:17' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S1341>/init' */
void InitTrigger_Model_416_84(void)
{
    /* MATLAB Function: '<S1337>/SignalBreak' */
    /* MATLAB Function: '<S1337>/SignalBreak' incorporates:
     *  S-Function (TOP_MEX): '<S1333>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1344>:1' */
    /* '<S1344>:1:3' init(); */
    memcpy(&NearWiggle35727FirEvenCoeffs[0],
           &(Model_Target_PreAmp_p13_b0.NearWiggleCoeffs[0]), sizeof(real32_T) <<
           11U);

    /* MATLAB Function 'FirEven/FirEven/Hexagon/SignalBreak': '<S1342>:1' */
    /* '<S1342>:1:3' y = u; */
}

/*
 * Output and update for function-call system:
 *    '<S1523>/index to linear'
 *    '<S1524>/index to linear gain mapping'
 *    '<S1526>/index to linear'
 */
void Model_Target_indextolinear(real32_T rtu_scale, real32_T rtu_offset,
    uint32_T rtu_index, B_indextolinear_Model_Target_T *localB)
{
    /*  The midrange curve is configured as a piecewise linear plot, with */
    /*  configurable values of the maximum boost ('maxB') and maximum cut ('maxC') */
    /*  in dB.  */
    /*     dB ^ */
    /*        | */
    /*  maxB  ----------/ */
    /*        |        / */
    /*        |       / */
    /*   0    ------|---|----> index */
    /*        |   /128  255 */
    /*        |  / */
    /*  maxC  --/ */
    /*        | */
    /*  Hence, for any given index, the gain is calculated as a value in  */
    /*  between 0 and 1 for boost and 0 and -1 for cut. This will later be */
    /*  multiplied with the maxB or maxC to get the actual gain value.  */
    /*  (y - y1) / (x - x1) = (y1 - y2) / (x1 - x2) */
    /*  (y - 0) / (x - 128) = (0 - 1) / (128 - 255) */
    /*                    y = (x - 128)/127 */
    /*  'offset' represents the center point between boost and cut (i.e. 128) and */
    /*  'scale' represents how many intervals are available for boost/cut (i.e. 127) */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Bass/index to linear': '<S1535>:1' */
    /*  Apply the tuning calibration */
    /* '<S1535>:1:27' floatIndex = single(index); */
    /* '<S1535>:1:28' linearGain = single((floatIndex - offset) / scale); */
    localB->linearGain = qhmath_div_f((real32_T)rtu_index - rtu_offset,
        rtu_scale);

    /*  Ensure the result is between -1 and 1 */
    /* '<S1535>:1:31' linearGain = min(linearGain, 1); */
    localB->linearGain = fminf(localB->linearGain, 1.0F);

    /* '<S1535>:1:32' linearGain = max(linearGain, -1); */
    localB->linearGain = fmaxf(localB->linearGain, -1.0F);
}

/*
 * Output and update for function-call system:
 *    '<S1523>/ramp parameters'
 *    '<S1526>/ramp parameters'
 */
void Model_Target_rampparameters_g(real32_T rtu_data, uint32_T rtu_rampTimeRTC,
    uint32_T rtu_rampRateRTC, const real_T rtp_rampRateBounds[2], const real_T
    rtp_rampTimeBounds[2], B_rampparameters_Model_Target_k_T *localB)
{
    real32_T y;
    y = rtu_data;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Bass/ramp parameters': '<S1536>:1' */
    /*  Ramp time mentioned in the RTC message gets priority over the tune */
    /*  variable. Boundary conditions are also included based on BDSP values. */
    /*  If neither ramp time nor rate are given in the RTC message (i.e. both */
    /*  = 0), then the ramp time in the Tune variable is taken as the default */
    /*  value for that message. */
    /* '<S1536>:1:11' ramptime = single(data); */
    /* '<S1536>:1:12' rampRate = single(0); */
    localB->rampRate = 0.0F;

    /* '<S1536>:1:14' if (rampRateRTC) */
    if (rtu_rampRateRTC != 0U)
    {
        /* '<S1536>:1:15' rampRate = single(rampRateRTC); */
        /* '<S1536>:1:16' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S1536>:1:17' rampRate = min(rampRateBounds(2), rampRate); */
        localB->rampRate = fminf((real32_T)rtp_rampRateBounds[1], fmaxf
            ((real32_T)rtp_rampRateBounds[0], (real32_T)rtu_rampRateRTC));
    }

    /* '<S1536>:1:19' if (rampTimeRTC) */
    if (rtu_rampTimeRTC != 0U)
    {
        /* '<S1536>:1:20' ramptime = single(rampTimeRTC); */
        y = (real32_T)rtu_rampTimeRTC;
    }

    /* '<S1536>:1:22' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S1536>:1:23' ramptime = min(rampTimeBounds(2), ramptime); */
    localB->ramptime = fminf((real32_T)rtp_rampTimeBounds[1], fmaxf((real32_T)
        rtp_rampTimeBounds[0], y));
}

/*
 * Output and update for function-call system:
 *    '<S1523>/SetDsm'
 *    '<S1523>/SetDsm1'
 */
void Model_Target_SetDsm_m(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1528>/Data Store Write' incorporates:
     *  Constant: '<S1528>/Constant'
     */
    Model_TargetControlDsms.PreAmpBassFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1523>/tone control' */
void Model_Target_tonecontrol(real32_T rtu_boost_max_db, real32_T rtu_cut_max_db,
    real32_T rtu_normalized_gain_impact, real32_T rtu_db_per_sec, real32_T
    rtu_ramp_time_ms, real32_T rtu_sample_rate_in_hertz, real32_T rtu_frame_size)
{
    suFnE4DIYISSjYbtQHPXOwD_Model_Target_T phaseConfig[2];
    real32_T currentGain_tmp;
    real32_T currentImpact_db;
    real32_T db_diff;
    real32_T quantum_ms;
    real32_T targetEffectiveGain;
    real32_T targetImpact_db;
    real32_T x;
    boolean_T currentIsBoost;
    boolean_T targetIsBoost;

    /*  %inputs */
    /*  % inputs % parameters */
    /* parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Bass/tone control': '<S1538>:1' */
    /*  See Control summary at the end: */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step now performed on canvas) */
    /*  Step 2a: IMPACT-TARGET Translate the normalized gain into a dB impact */
    /*  based on the maximum boost or cut values. */
    /*  ("-1" = maximum cut, "1" = maximum boost.) */
    /* '<S1538>:1:16' targetIsBoost = (normalized_gain_impact >= 0); */
    targetIsBoost = (rtu_normalized_gain_impact >= 0.0F);

    /* '<S1538>:1:17' if (targetIsBoost) */
    if (targetIsBoost)
    {
        /* '<S1538>:1:18' targetImpact_db = normalized_gain_impact * boost_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_boost_max_db;

        /* '<S1538>:1:19' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: undb20.m 11244 2011-10-31 18:51:23Z rg20270 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  1 or greater */
    }
    else
    {
        /* '<S1538>:1:20' else */
        /* '<S1538>:1:21' targetImpact_db = normalized_gain_impact * cut_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_cut_max_db;

        /* '<S1538>:1:22' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: undb20.m 11244 2011-10-31 18:51:23Z rg20270 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  less than 1 */
    }

    /* '<S1538>:1:25' actualTargetGainLinear = targetEffectiveGain; */
    /*  Step 2b: IMPACT-CURRENT Fetch the current gain from the previously */
    /*  active ramper. */
    /* '<S1538>:1:29' currentPhase = Phase; */
    /* '<S1538>:1:30' currentGain = Rampers(currentPhase).currentGain; */
    currentGain_tmp = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
        Model_TargetControlDsms.PreAmpBassPhase - 1].currentGain;

    /* '<S1538>:1:31' currentIsBoost = (currentGain >= 1); */
    currentIsBoost = (currentGain_tmp >= 1.0F);

    /* '<S1538>:1:32' currentImpact_db = db20(currentGain); */
    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: db20.m 11813 2012-07-11 17:31:25Z rs7109 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    currentImpact_db = qhmath_log_f(qhmath_abs_f(currentGain_tmp)) * 8.68588924F;

    /*  Setup processing to continue on seamlessly while we work here */
    /* '<S1538>:1:35' Rampers(1).currentGain = currentGain; */
    /* '<S1538>:1:36' Phase = uint32(1); */
    Model_TargetControlDsms.PreAmpBassPhase = 1U;

    /*  reset phase to 1 */
    /*  Now that we have both current and target impacts, find the difference */
    /* '<S1538>:1:38' db_diff = abs(currentImpact_db - targetImpact_db); */
    db_diff = qhmath_abs_f(currentImpact_db - targetImpact_db);

    /*  Step 3a: TIME- If a slope in dB/second is provided, ignore the ramp time */
    /* '<S1538>:1:41' if (db_per_sec) */
    if (rtu_db_per_sec != 0.0F)
    {
        /* '<S1538>:1:42' ramp_ms = db_diff / single(db_per_sec) * 1000; */
        x = qhmath_div_f(db_diff, rtu_db_per_sec) * 1000.0F;
    }
    else
    {
        /* '<S1538>:1:43' else */
        /* '<S1538>:1:44' ramp_ms = single(ramp_time_ms); */
        x = rtu_ramp_time_ms;
    }

    /*  Step 3b: TIME- QUANTIZE the desired ramp time to our FrameSize.  */
    /* '<S1538>:1:48' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);

    /* '<S1538>:1:49' numFrames = ramp_ms / quantum_ms; */
    /* '<S1538>:1:50' numFrames = max (1, ceil(numFrames)); */
    x = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(x, quantum_ms)));

    /*  Step 4a: PHASES- Determine whether ramping from current gain to target */
    /*  gain requires a unity crossing in linear gain. */
    /* '<S1538>:1:54' isTwoPhase = (currentIsBoost ~= targetIsBoost) && ... */
    /* '<S1538>:1:55'              (currentGain ~= 1) && ... % cannot cross if you're already there */
    /* '<S1538>:1:56'              (targetImpact_db ~= 1); */
    /*  % cannot cross if you're already there */
    /*  no crossing needed when impact already nothing */
    /*  Setup a structure to hold information about what the rampers should do */
    /* '<S1538>:1:58' twoSingles = {single(0) single(0)}; */
    /* '<S1538>:1:59' phaseConfig = struct('frames',twoSingles,'target_linear',twoSingles,'current_linear',twoSingles); */
    /* '<S1538>:1:60' phaseConfig = tone_control_split(numFrames,currentImpact_db,db_diff,... */
    /* '<S1538>:1:61'     currentGain,currentIsBoost,rgain_SILENT_GAIN,targetIsBoost,... */
    /* '<S1538>:1:62'     targetEffectiveGain,isTwoPhase,phaseConfig); */
    /* '<S1538>:1:104' if (isTwoPhase) */
    if ((currentIsBoost != targetIsBoost) && (currentGain_tmp != 1.0F) &&
            (targetImpact_db != 1.0F))
    {
        /*  Both boost and cut phases will be required to get where we are going. */
        /*  Make sure we have at least two frames to work with: */
        /* '<S1538>:1:107' numFrames = max (2, round(numFrames)); */
        x = fmaxf(2.0F, x);

        /*  Divide up our ramp time into pieces for each phase to use */
        /* '<S1538>:1:110' phase1Frames = ceil(numFrames * abs(currentImpact_db) / db_diff); */
        targetImpact_db = qhmath_ceil_f(qhmath_div_f(x * qhmath_abs_f
            (currentImpact_db), db_diff));

        /* '<S1538>:1:111' phase2Frames = numFrames - phase1Frames; */
        /*  Make sure phase 2 has at least 1 frame to work with */
        /* '<S1538>:1:114' phase2Frames = max(1, phase2Frames); */
        phaseConfig[1].frames = fmaxf(1.0F, x - targetImpact_db);

        /*  Setup Phase 1 ramper that takes us to zero impact (i.e. unity gain) */
        /* '<S1538>:1:117' phaseConfig(1).current_linear   = currentGain; */
        phaseConfig[0].current_linear = currentGain_tmp;

        /*  we know this is not 1 */
        /* '<S1538>:1:118' phaseConfig(1).target_linear    = NudgeUnity(1,currentIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1538>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1538>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = 1.00000048F;
        }
        else
        {
            /* '<S1538>:1:96' else */
            /* '<S1538>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = 0.999999523F;
        }

        /* '<S1538>:1:119' phaseConfig(1).frames           = phase1Frames; */
        phaseConfig[0].frames = targetImpact_db;

        /*  Setup Phase 2 ramper that delivers us to target impact */
        /* '<S1538>:1:122' phaseConfig(2).current_linear   = NudgeUnity(1,targetIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1538>:1:94' if (isPositive) */
        if (targetIsBoost)
        {
            /* '<S1538>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].current_linear = 1.00000048F;
        }
        else
        {
            /* '<S1538>:1:96' else */
            /* '<S1538>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].current_linear = 0.999999523F;
        }

        /*  start quiet */
        /* '<S1538>:1:123' phaseConfig(2).target_linear    = targetEffectiveGain; */
        phaseConfig[1].target_linear = targetEffectiveGain;

        /*  we know this is not 0 */
        /* '<S1538>:1:124' phaseConfig(2).frames           = phase2Frames; */
    }
    else
    {
        /* '<S1538>:1:125' else */
        /*  Only one phase is needed to accomplish our goal. We are are the */
        /*  target side of unity... but we must determine which side that is */
        /* '<S1538>:1:128' if (currentGain == 1) */
        if (currentGain_tmp == 1.0F)
        {
            /*  One is in-between sides: use the target to determine the side */
            /* '<S1538>:1:130' isBoost = targetIsBoost; */
            currentIsBoost = targetIsBoost;
        }
        else
        {
            /* '<S1538>:1:131' else */
            /*  Current gain is already on one side of unity so use that */
            /* '<S1538>:1:133' isBoost = currentIsBoost; */
        }

        /* '<S1538>:1:135' phaseConfig(1).current_linear   = NudgeUnity(currentGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1538>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1538>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].current_linear = fmaxf(currentGain_tmp, 1.00000048F);

            /* '<S1538>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = fmaxf(targetEffectiveGain,
                1.00000048F);
        }
        else
        {
            /* '<S1538>:1:96' else */
            /* '<S1538>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].current_linear = fminf(currentGain_tmp, 0.999999523F);

            /* '<S1538>:1:96' else */
            /* '<S1538>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = fminf(targetEffectiveGain,
                0.999999523F);
        }

        /* '<S1538>:1:136' phaseConfig(1).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1538>:1:94' if (isPositive) */
        /* '<S1538>:1:137' phaseConfig(1).frames           = numFrames; */
        phaseConfig[0].frames = x;

        /*  Setup Phase 2 ramper to sit at the target gain */
        /* '<S1538>:1:140' phaseConfig(2).current_linear   = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1538>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1538>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            targetImpact_db = fmaxf(targetEffectiveGain, 1.00000048F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S1538>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }
        else
        {
            /* '<S1538>:1:96' else */
            /* '<S1538>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            targetImpact_db = fminf(targetEffectiveGain, 0.999999523F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S1538>:1:96' else */
            /* '<S1538>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }

        /* '<S1538>:1:141' phaseConfig(2).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1538>:1:94' if (isPositive) */
        /* '<S1538>:1:142' phaseConfig(2).frames           = single(0); */
        phaseConfig[1].frames = 0.0F;
    }

    /*  Step 4b: PHASES- Setup rampers for both phases */
    /* '<S1538>:1:65' for currentPhase=1:2 */
    /* '<S1538>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[0].frames != 0.0F)
    {
        /* '<S1538>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1538>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1538>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpBassRampers[0].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[0].target_linear,
                phaseConfig[0].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[0].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1538>:1:70' else */
        /* '<S1538>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpBassRampers[0].rampCoeff = 1.0F;
    }

    /* '<S1538>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1538>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpBassRampers[0].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1538>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpBassRampers[0].currentGain = phaseConfig[0].
        current_linear;

    /* '<S1538>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpBassRampers[0].frameCount = (int32_T)
        phaseConfig[0].frames;

    /* '<S1538>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[1].frames != 0.0F)
    {
        /* '<S1538>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1538>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1538>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpBassRampers[1].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[1].target_linear,
                phaseConfig[1].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[1].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1538>:1:70' else */
        /* '<S1538>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpBassRampers[1].rampCoeff = 1.0F;
    }

    /* '<S1538>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1538>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpBassRampers[1].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1538>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpBassRampers[1].currentGain = phaseConfig[1].
        current_linear;

    /* '<S1538>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpBassRampers[1].frameCount = (int32_T)
        phaseConfig[1].frames;

    /*  unfreeze the gain. (This step now performed on canvas) */
}

/* Output and update for function-call system: '<S1527>/REQ' */
void HandleReqPreAmpBassSet(void)
{
    /* MATLAB Function: '<S1523>/index to linear' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1542>:1' */
    /* '<S1542>:1:3' go(); */
    Model_Target_indextolinear(Model_Target_PreAmp_p0_b0.BassScale,
        Model_Target_PreAmp_p0_b0.BassOffset,
        Model_TargetPreAmpBassSetRtcOut.REQ_gain_index,
        &Model_Target_PreAmpPart1_B.sf_indextolinear);

    /* MATLAB Function: '<S1523>/ramp parameters' */
    Model_Target_rampparameters_g(Model_Target_PreAmp_p0_b0.Bassramptime,
        Model_TargetPreAmpBassSetRtcOut.REQ_ramp_milliseconds,
        Model_TargetPreAmpBassSetRtcOut.REQ_ramp_db_per_second,
        Model_Target_ConstP.pooled1, Model_Target_ConstP.pooled2,
        &Model_Target_PreAmpPart1_B.sf_rampparameters);

    /* Outputs for Function Call SubSystem: '<S1523>/SetDsm' */
    Model_Target_SetDsm_m(1U);

    /* End of Outputs for SubSystem: '<S1523>/SetDsm' */

    /* MATLAB Function: '<S1523>/tone control' */
    /* MATLAB Function: '<S1523>/tone control' incorporates:
     *  S-Function (AudioStats_MEX): '<S1523>/Audio Stats'
     */
    Model_Target_tonecontrol(Model_Target_PreAmp_p0_b0.BassBoostMaximum_dB,
        Model_Target_PreAmp_p0_b0.BassCutMaximum_dB,
        Model_Target_PreAmpPart1_B.sf_indextolinear.linearGain,
        Model_Target_PreAmpPart1_B.sf_rampparameters.rampRate,
        Model_Target_PreAmpPart1_B.sf_rampparameters.ramptime,
        44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1523>/SetDsm1' */
    Model_Target_SetDsm_m(0U);

    /* End of Outputs for SubSystem: '<S1523>/SetDsm1' */
}

/* Output and update for atomic system: '<S1523>/tone' */
void Model_Target_tone(const real32_T rtu_boost_coeffs[3], const real32_T
                       rtu_cut_coeffs[3], const real32_T rtu_audioIn[64],
                       B_tone_Model_Target_T *localB, DW_tone_Model_Target_T
                       *localDW)
{
    int32_T q0;
    int32_T qY;
    real32_T aCoeffs;
    real32_T bCoeffs_idx_0;
    real32_T bCoeffs_idx_1;
    real32_T gain;
    real32_T k;
    uint32_T ramper;

    /*     % inputs % parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Bass/tone': '<S1537>:1' */
    /*  Data Store objects (registered in "Edit Data" dialog */
    /*  Keep memory for the filter persistent from frame to frame */
    /*  figure out the frame size and channel count */
    /* '<S1537>:1:15' [frame_size, channel_count] = size(audioIn); */
    /* '<S1537>:1:17' if (isempty(toneFilterStates)) */
    /*  set the size and datatype of the output buffer */
    /* '<S1537>:1:23' audioOut = coder.nullcopy(audioIn); */
    /* '<S1537>:1:25' ramper = Phase; */
    ramper = Model_TargetControlDsms.PreAmpBassPhase;

    /* '<S1537>:1:26' ramperCount = numel(Rampers); */
    /* '<S1537>:1:28' if (Freeze == false) */
    if (Model_TargetControlDsms.PreAmpBassFreeze == 0U)
    {
        /* '<S1537>:1:29' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount == 0)
        {
            /*  The current ramper is finished. Is there another one? */
            /* '<S1537>:1:31' if (ramper < ramperCount && Rampers(ramper+1).frameCount > 0) */
            if ((Model_TargetControlDsms.PreAmpBassPhase < 2U) &&
                    (Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                     Model_TargetControlDsms.PreAmpBassPhase].frameCount > 0))
            {
                /*  Yes - move on to the next phase */
                /* '<S1537>:1:33' ramper = ramper + 1; */
                qY = (int32_T)(Model_TargetControlDsms.PreAmpBassPhase +
                               /*MW:OvSatOk*/ 1U);
                ramper = Model_TargetControlDsms.PreAmpBassPhase + 1U;

                /* '<S1537>:1:34' Phase = ramper; */
                Model_TargetControlDsms.PreAmpBassPhase =
                    Model_TargetControlDsms.PreAmpBassPhase + 1U;

                /* '<S1537>:1:35' k = Rampers(ramper).rampCoeff; */
                k = Model_TargetControlDsms.PreAmpBassRampers[qY - 1].rampCoeff;

                /* '<S1537>:1:36' gain = Rampers(ramper).currentGain; */
                gain = Model_TargetControlDsms.PreAmpBassRampers[qY - 1].
                    currentGain;

                /* '<S1537>:1:37' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                q0 = Model_TargetControlDsms.PreAmpBassRampers[qY - 1].
                    frameCount;
                if (q0 < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpBassRampers[qY - 1].frameCount
                        = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpBassRampers[qY - 1].frameCount
                        = q0 - 1;
                }
            }
            else
            {
                /* '<S1537>:1:38' else */
                /*   Stop ramping and SNAP to the target */
                /* '<S1537>:1:40' k = single(1); */
                k = 1.0F;

                /* '<S1537>:1:41' gain = Rampers(ramper).targetGain; */
                gain = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpBassPhase - 1].targetGain;

                /*  Update completion flag */
            }
        }
        else
        {
            /* '<S1537>:1:44' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S1537>:1:46' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].rampCoeff;

            /* '<S1537>:1:47' gain = Rampers(ramper).currentGain; */
            gain = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].currentGain;

            /* '<S1537>:1:48' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            q0 = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount;
            if (q0 < -2147483647)
            {
                Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount =
                    MIN_int32_T;
            }
            else
            {
                Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpBassPhase - 1].frameCount = q0
                    - 1;
            }
        }
    }
    else
    {
        /* '<S1537>:1:50' else */
        /*  Frozen. Stay at current gain */
        /* '<S1537>:1:52' k = single(1); */
        k = 1.0F;

        /* '<S1537>:1:53' gain = Rampers(ramper).currentGain; */
        gain = Model_TargetControlDsms.PreAmpBassRampers[(int32_T)
            Model_TargetControlDsms.PreAmpBassPhase - 1].currentGain;
    }

    /*  Apply the tone filter */
    /* '<S1537>:1:57' if (gain < 1) */
    if (gain < 1.0F)
    {
        /*  Cut */
        /* '<S1537>:1:59' bCoeffs = cut_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_cut_coeffs[0];
        bCoeffs_idx_1 = rtu_cut_coeffs[1];

        /* '<S1537>:1:60' aCoeffs = cut_coeffs(3); */
        aCoeffs = rtu_cut_coeffs[2];
    }
    else
    {
        /* '<S1537>:1:61' else */
        /*  Boost */
        /* '<S1537>:1:63' bCoeffs = boost_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_boost_coeffs[0];
        bCoeffs_idx_1 = rtu_boost_coeffs[1];

        /* '<S1537>:1:64' aCoeffs = boost_coeffs(3); */
        aCoeffs = rtu_boost_coeffs[2];
    }

    /*  [filtered,toneFilterStates] = filter(bCoeffs, aCoeffs, audioIn, toneFilterStates); */
    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S1537>:1:70' for n=1:frame_size */
    for (q0 = 0; q0 < 32; q0++)
    {
        real32_T filterOut;
        real32_T filterOut_tmp;

        /*  Update the gain and then subtract one before applying it to the */
        /*  filtered signal. Disregarding phase shifting  */
        /* '<S1537>:1:73' gain = gain * k; */
        gain *= k;

        /* '<S1537>:1:74' filterGain = gain - 1; */
        /*  Loop through channels adding in gain-adjusted filtered samples */
        /* '<S1537>:1:76' for chanIdx = 1:channel_count */
        /* '<S1537>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut = bCoeffs_idx_0 * rtu_audioIn[q0] + localDW->toneFilterStates
            [0];

        /* '<S1537>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[0] = bCoeffs_idx_1 * rtu_audioIn[q0] + aCoeffs
            * filterOut;

        /* '<S1537>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0] = (gain - 1.0F) * filterOut + rtu_audioIn[q0];

        /* '<S1537>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut_tmp = rtu_audioIn[q0 + 32];
        filterOut = filterOut_tmp * bCoeffs_idx_0 + localDW->toneFilterStates[1];

        /* '<S1537>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[1] = filterOut_tmp * bCoeffs_idx_1 + aCoeffs *
            filterOut;

        /* '<S1537>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0 + 32] = (gain - 1.0F) * filterOut + filterOut_tmp;
    }

    /* '<S1537>:1:85' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpBassRampers[(int32_T)ramper - 1].currentGain =
        gain;
}

/*
 * Output and update for function-call system:
 *    '<S1524>/SetDsm'
 *    '<S1524>/SetDsm1'
 */
void Model_Target_SetDsm_c1(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1546>/Data Store Write' incorporates:
     *  Constant: '<S1546>/Constant'
     */
    Model_TargetControlDsms.PreAmpMidrangeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1524>/tone control' */
void Model_Target_tonecontrol_l(real32_T rtu_boost_max_db, real32_T
    rtu_cut_max_db, real32_T rtu_normalized_gain_impact, real32_T rtu_db_per_sec,
    real32_T rtu_ramp_time_ms, real32_T rtu_sample_rate_in_hertz, real32_T
    rtu_frame_size)
{
    suFnE4DIYISSjYbtQHPXOwD_Model_Target_T phaseConfig[2];
    real32_T currentGain_tmp;
    real32_T currentImpact_db;
    real32_T db_diff;
    real32_T phase1Frames;
    real32_T quantum_ms;
    real32_T targetEffectiveGain;
    real32_T x;
    boolean_T currentIsBoost;
    boolean_T targetIsBoost;

    /*  See Controlsummary at the end; */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Midrange/tone control': '<S1556>:1' */
    /* '<S1556>:1:10' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step now performed on canvas) */
    /*  Step 2a: IMPACT-TARGET Translate the normalized gain into a dB impact */
    /*  based on the maximum boost or cut values. */
    /*  ("-1" = maximum cut, "1" = maximum boost.) */
    /* '<S1556>:1:18' [targetIsBoost,targetImpact_db,targetEffectiveGain,... */
    /* '<S1556>:1:19'     actualTargetGainLinear] = ... */
    /* '<S1556>:1:20'     tone_control_split1(normalized_gain_impact,boost_max_db,cut_max_db); */
    /*  NudgeUnity end */
    /* '<S1556>:1:105' targetIsBoost = (normalized_gain_impact >= 0); */
    targetIsBoost = (rtu_normalized_gain_impact >= 0.0F);

    /* '<S1556>:1:106' if (targetIsBoost) */
    if (targetIsBoost)
    {
        /* '<S1556>:1:107' targetImpact_db = normalized_gain_impact * boost_max_db; */
        phase1Frames = rtu_normalized_gain_impact * rtu_boost_max_db;

        /* '<S1556>:1:108' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: undb20.m 11244 2011-10-31 18:51:23Z rg20270 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(phase1Frames *
            2.30258512F, 20.0F));

        /*  1 or greater */
    }
    else
    {
        /* '<S1556>:1:109' else */
        /* '<S1556>:1:110' targetImpact_db = normalized_gain_impact * cut_max_db; */
        phase1Frames = rtu_normalized_gain_impact * rtu_cut_max_db;

        /* '<S1556>:1:111' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: undb20.m 11244 2011-10-31 18:51:23Z rg20270 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(phase1Frames *
            2.30258512F, 20.0F));

        /*  less than 1 */
    }

    /*  remember the actual target because we will nudge this value away from one */
    /*  during the ramper calculations. This actual target value is used below as */
    /*  the target in the ramper data itself. */
    /* '<S1556>:1:116' actualTargetGainLinear = targetEffectiveGain; */
    /*  Step 2b: IMPACT-CURRENT Fetch the current gain from the previously */
    /*  active ramper. */
    /* '<S1556>:1:24' currentPhase = Phase; */
    /* '<S1556>:1:25' currentGain = Rampers(currentPhase).currentGain; */
    currentGain_tmp = Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
        Model_TargetControlDsms.PreAmpMidrangePhase - 1].currentGain;

    /* '<S1556>:1:26' currentIsBoost = (currentGain >= 1); */
    currentIsBoost = (currentGain_tmp >= 1.0F);

    /* '<S1556>:1:27' currentImpact_db = db20(currentGain); */
    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: db20.m 11813 2012-07-11 17:31:25Z rs7109 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    currentImpact_db = qhmath_log_f(qhmath_abs_f(currentGain_tmp)) * 8.68588924F;

    /*  Setup processing to continue on seamlessly while we work here */
    /* '<S1556>:1:30' Rampers(1).currentGain = currentGain; */
    /* '<S1556>:1:31' Phase = uint32(1); */
    Model_TargetControlDsms.PreAmpMidrangePhase = 1U;

    /*  reset phase to 1 */
    /*  Now that we have both current and target impacts, find the difference */
    /* '<S1556>:1:33' db_diff = abs(currentImpact_db - targetImpact_db); */
    db_diff = qhmath_abs_f(currentImpact_db - phase1Frames);

    /*  Step 3a: TIME- If a slope in dB/second is provided, ignore the ramp time */
    /*  and instead calculate a new ramp time that matches the slope. */
    /* '<S1556>:1:37' if (db_per_sec) */
    if (rtu_db_per_sec != 0.0F)
    {
        /* '<S1556>:1:38' ramp_ms = db_diff / single(db_per_sec) * 1000; */
        x = qhmath_div_f(db_diff, rtu_db_per_sec) * 1000.0F;
    }
    else
    {
        /* '<S1556>:1:39' else */
        /* '<S1556>:1:40' ramp_ms = single(ramp_time_ms); */
        x = rtu_ramp_time_ms;
    }

    /*  Step 3b: TIME- QUANTIZE the desired ramp time to our FrameSize.  */
    /* '<S1556>:1:44' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);

    /* '<S1556>:1:45' numFrames = ramp_ms / quantum_ms; */
    /* '<S1556>:1:46' numFrames = max (1, ceil(numFrames)); */
    x = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(x, quantum_ms)));

    /*  Step 4a: PHASES- Determine whether ramping from current gain to target */
    /*  gain requires a unity crossing in linear gain.  */
    /* '<S1556>:1:50' isTwoPhase = (currentIsBoost ~= targetIsBoost) && ... */
    /* '<S1556>:1:51'     (currentGain ~= 1) && ... % cannot cross if you're already there */
    /* '<S1556>:1:52'     (targetImpact_db ~= 1); */
    /*  % cannot cross if you're already there */
    /*  no crossing needed when impact already nothing */
    /*  Setup a structure to hold information about what the rampers should do */
    /* '<S1556>:1:54' twoSingles = {single(0) single(0)}; */
    /* '<S1556>:1:55' phaseConfig = struct('frames',twoSingles,'target_linear',twoSingles,'current_linear',twoSingles); */
    /* '<S1556>:1:56' phaseConfig = tone_control_split2(numFrames,currentImpact_db,... */
    /* '<S1556>:1:57'     db_diff,currentGain,currentIsBoost,rgain_SILENT_GAIN,targetIsBoost,... */
    /* '<S1556>:1:58'     targetEffectiveGain,isTwoPhase,phaseConfig); */
    /* tone_control_split1 */
    /* '<S1556>:1:125' if (isTwoPhase) */
    if ((currentIsBoost != targetIsBoost) && (currentGain_tmp != 1.0F) &&
            (phase1Frames != 1.0F))
    {
        /*  Both boost and cut phases will be required to get where we are going. */
        /*  Make sure we have at least two frames to work with: */
        /* '<S1556>:1:128' numFrames = max (2, round(numFrames)); */
        x = fmaxf(2.0F, x);

        /*  Divide up our ramp time into pieces for each phase to use */
        /* '<S1556>:1:131' phase1Frames = ceil(numFrames * abs(currentImpact_db) / db_diff); */
        phase1Frames = qhmath_ceil_f(qhmath_div_f(x * qhmath_abs_f
            (currentImpact_db), db_diff));

        /* '<S1556>:1:132' phase2Frames = numFrames - phase1Frames; */
        /*  Make sure phase 2 has at least 1 frame to work with */
        /* '<S1556>:1:135' phase2Frames = max(1, phase2Frames); */
        phaseConfig[1].frames = fmaxf(1.0F, x - phase1Frames);

        /*  Setup Phase 1 ramper that takes us to zero impact (i.e. unity gain) */
        /* '<S1556>:1:138' phaseConfig(1).current_linear   = currentGain; */
        phaseConfig[0].current_linear = currentGain_tmp;

        /*  we know this is not 1 */
        /* '<S1556>:1:139' phaseConfig(1).target_linear    = NudgeUnity(1,currentIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1556>:1:95' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1556>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = 1.00000048F;
        }
        else
        {
            /* '<S1556>:1:97' else */
            /* '<S1556>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = 0.999999523F;
        }

        /* '<S1556>:1:140' phaseConfig(1).frames           = phase1Frames; */
        phaseConfig[0].frames = phase1Frames;

        /*  Setup Phase 2 ramper that delivers us to target impact */
        /* '<S1556>:1:143' phaseConfig(2).current_linear   = NudgeUnity(1,targetIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1556>:1:95' if (isPositive) */
        if (targetIsBoost)
        {
            /* '<S1556>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].current_linear = 1.00000048F;
        }
        else
        {
            /* '<S1556>:1:97' else */
            /* '<S1556>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].current_linear = 0.999999523F;
        }

        /*  start quiet */
        /* '<S1556>:1:144' phaseConfig(2).target_linear    = targetEffectiveGain; */
        phaseConfig[1].target_linear = targetEffectiveGain;

        /*  we know this is not 0 */
        /* '<S1556>:1:145' phaseConfig(2).frames           = phase2Frames; */
    }
    else
    {
        /* '<S1556>:1:146' else */
        /*  Only one phase is needed to accomplish our goal. We are are the */
        /*  target side of unity... but we must determine which side that is */
        /* '<S1556>:1:149' if (currentGain == 1) */
        if (currentGain_tmp == 1.0F)
        {
            /*  One is in-between sides: use the target to determine the side */
            /* '<S1556>:1:151' isBoost = targetIsBoost; */
            currentIsBoost = targetIsBoost;
        }
        else
        {
            /* '<S1556>:1:152' else */
            /*  Current gain is already on one side of unity so use that */
            /* '<S1556>:1:154' isBoost = currentIsBoost; */
        }

        /* '<S1556>:1:156' phaseConfig(1).current_linear   = NudgeUnity(currentGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1556>:1:95' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1556>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].current_linear = fmaxf(currentGain_tmp, 1.00000048F);

            /* '<S1556>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = fmaxf(targetEffectiveGain,
                1.00000048F);
        }
        else
        {
            /* '<S1556>:1:97' else */
            /* '<S1556>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].current_linear = fminf(currentGain_tmp, 0.999999523F);

            /* '<S1556>:1:97' else */
            /* '<S1556>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = fminf(targetEffectiveGain,
                0.999999523F);
        }

        /* '<S1556>:1:157' phaseConfig(1).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1556>:1:95' if (isPositive) */
        /* '<S1556>:1:158' phaseConfig(1).frames           = numFrames; */
        phaseConfig[0].frames = x;

        /*  Setup Phase 2 ramper to sit at the target gain */
        /* '<S1556>:1:161' phaseConfig(2).current_linear   = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1556>:1:95' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1556>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phase1Frames = fmaxf(targetEffectiveGain, 1.00000048F);
            phaseConfig[1].current_linear = phase1Frames;

            /* '<S1556>:1:96' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].target_linear = phase1Frames;
        }
        else
        {
            /* '<S1556>:1:97' else */
            /* '<S1556>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phase1Frames = fminf(targetEffectiveGain, 0.999999523F);
            phaseConfig[1].current_linear = phase1Frames;

            /* '<S1556>:1:97' else */
            /* '<S1556>:1:98' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].target_linear = phase1Frames;
        }

        /* '<S1556>:1:162' phaseConfig(2).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1556>:1:95' if (isPositive) */
        /* '<S1556>:1:163' phaseConfig(2).frames           = single(0); */
        phaseConfig[1].frames = 0.0F;
    }

    /*  Step 4b: PHASES- Setup rampers for both phases */
    /* '<S1556>:1:61' for currentPhase=1:2 */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /* '<S1556>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[0].frames != 0.0F)
    {
        /* '<S1556>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1556>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1556>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpMidrangeRampers[0].rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[0].
                            target_linear, phaseConfig[0].current_linear)),
                          qhmath_div_f(quantum_ms * phaseConfig[0].frames *
                           rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1556>:1:70' else */
        /* '<S1556>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpMidrangeRampers[0].rampCoeff = 1.0F;
    }

    /*  Output control signals */
    /* '<S1556>:1:75' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpMidrangeRampers[0].frameCount = (int32_T)
        phaseConfig[0].frames;

    /* '<S1556>:1:76' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1556>:1:77' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpMidrangeRampers[0].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1556>:1:78' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpMidrangeRampers[0].currentGain = phaseConfig[0]
        .current_linear;

    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /* '<S1556>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[1].frames != 0.0F)
    {
        /* '<S1556>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1556>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1556>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpMidrangeRampers[1].rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[1].
                            target_linear, phaseConfig[1].current_linear)),
                          qhmath_div_f(quantum_ms * phaseConfig[1].frames *
                           rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1556>:1:70' else */
        /* '<S1556>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpMidrangeRampers[1].rampCoeff = 1.0F;
    }

    /*  Output control signals */
    /* '<S1556>:1:75' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpMidrangeRampers[1].frameCount = (int32_T)
        phaseConfig[1].frames;

    /* '<S1556>:1:76' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1556>:1:77' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpMidrangeRampers[1].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1556>:1:78' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpMidrangeRampers[1].currentGain = phaseConfig[1]
        .current_linear;

    /*  unfreeze the gain (This step now performed on canvas) */
}

/* Output and update for function-call system: '<S1545>/REQ' */
void HandleReqPreAmpMidrangeSet(void)
{
    int32_T rampRate;
    real32_T y;

    /* MATLAB Function: '<S1524>/index to linear gain mapping' */
    /* MATLAB Function: '<S1524>/index to linear gain mapping' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1560>:1' */
    /* '<S1560>:1:3' go(); */
    Model_Target_indextolinear(Model_Target_PreAmp_p0_b0.MidrangeScale,
        Model_Target_PreAmp_p0_b0.MidrangeOffset,
        Model_TargetPreAmpMidrangeSetRtcOut.REQ_gain_index,
        &Model_Target_PreAmpPart1_B.sf_indextolineargainmapping_m);

    /* MATLAB Function: '<S1524>/calculate ramp parameters' */
    /* MATLAB Function: '<S1524>/calculate ramp parameters' */
    y = Model_Target_PreAmp_p0_b0.MidrangeRampTime;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Midrange/calculate ramp parameters': '<S1552>:1' */
    /*  Ramp time mentioned in the RTC message gets priority over the tune */
    /*  variable. Boundary conditions are also included based on BDSP values. */
    /* '<S1552>:1:8' ramptime = single(rampTimeTune); */
    /* '<S1552>:1:9' rampRate = single(0); */
    rampRate = 0;

    /* '<S1552>:1:11' if (rampRateRTC) */
    if (Model_TargetPreAmpMidrangeSetRtcOut.REQ_ramp_db_per_second != 0U)
    {
        /* '<S1552>:1:12' rampRate = single(rampRateRTC); */
        /* '<S1552>:1:13' rampRate = max(rampRateBounds(1), rampRate); */
        /* '<S1552>:1:14' rampRate = min(rampRateBounds(2), rampRate); */
        rampRate = (int32_T)fminf(50000.0F, fmaxf(5.0F, (real32_T)
            Model_TargetPreAmpMidrangeSetRtcOut.REQ_ramp_db_per_second));
    }

    /* '<S1552>:1:16' if (rampTimeRTC) */
    if (Model_TargetPreAmpMidrangeSetRtcOut.REQ_ramp_milliseconds != 0U)
    {
        /* '<S1552>:1:17' ramptime = single(rampTimeRTC); */
        y = (real32_T)Model_TargetPreAmpMidrangeSetRtcOut.REQ_ramp_milliseconds;
    }

    /* Outputs for Function Call SubSystem: '<S1524>/SetDsm' */
    /* '<S1552>:1:19' ramptime = max(rampTimeBounds(1), ramptime); */
    /* '<S1552>:1:20' ramptime = min(rampTimeBounds(2), ramptime); */
    Model_Target_SetDsm_c1(1U);

    /* End of Outputs for SubSystem: '<S1524>/SetDsm' */

    /* MATLAB Function: '<S1524>/tone control' */
    /* MATLAB Function: '<S1524>/calculate ramp parameters' */
    /* MATLAB Function: '<S1524>/tone control' incorporates:
     *  MATLAB Function: '<S1524>/calculate ramp parameters'
     *  S-Function (AudioStats_MEX): '<S1524>/Audio Stats'
     */
    Model_Target_tonecontrol_l(Model_Target_PreAmp_p0_b0.MidrangeBoostMaximum_dB,
        Model_Target_PreAmp_p0_b0.MidrangeCutMaximum_dB,
        Model_Target_PreAmpPart1_B.sf_indextolineargainmapping_m.linearGain,
        (real32_T)rampRate, fminf(3000.0F, fmaxf(1.0F, y)), 44307.692307692312,
        32.0);

    /* Outputs for Function Call SubSystem: '<S1524>/SetDsm1' */
    Model_Target_SetDsm_c1(0U);

    /* End of Outputs for SubSystem: '<S1524>/SetDsm1' */
}

/* Output and update for atomic system: '<S1524>/tone' */
void Model_Target_tone_k(const real32_T rtu_boost_coeffs[5], const real32_T
    rtu_cut_coeffs[5], const real32_T rtu_audioIn[64], B_tone_Model_Target_b_T
    *localB, DW_tone_Model_Target_d_T *localDW)
{
    int32_T q0;
    int32_T qY;
    real32_T aCoeffs_idx_0;
    real32_T aCoeffs_idx_1;
    real32_T bCoeffs_idx_0;
    real32_T bCoeffs_idx_2;
    real32_T gain;
    real32_T k;
    uint32_T ramper;

    /*     % inputs % parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Midrange/tone': '<S1555>:1' */
    /*  Data Store objects (registered in "Edit Data" dialog */
    /*  Keep memory for the filter persistent from frame to frame */
    /*  figure out the frame size and channel count */
    /* '<S1555>:1:15' [frame_size, channel_count] = size(audioIn); */
    /* '<S1555>:1:17' if (isempty(toneFilterStates)) */
    /*  set the size and datatype of the output buffer */
    /* '<S1555>:1:22' audioOut = coder.nullcopy(audioIn); */
    /* '<S1555>:1:24' ramper = Phase; */
    ramper = Model_TargetControlDsms.PreAmpMidrangePhase;

    /* '<S1555>:1:25' ramperCount = numel(Rampers); */
    /* '<S1555>:1:27' if (Freeze == false) */
    if (Model_TargetControlDsms.PreAmpMidrangeFreeze == 0U)
    {
        /* '<S1555>:1:28' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangePhase - 1].frameCount == 0)
        {
            /*  The current ramper is finished. Is there another one? */
            /* '<S1555>:1:30' if (ramper < ramperCount && Rampers(ramper+1).frameCount > 0) */
            if ((Model_TargetControlDsms.PreAmpMidrangePhase < 2U) &&
                    (Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                     Model_TargetControlDsms.PreAmpMidrangePhase].frameCount > 0))
            {
                /*  Yes - move on to the next phase */
                /* '<S1555>:1:32' ramper = ramper + 1; */
                qY = (int32_T)(Model_TargetControlDsms.PreAmpMidrangePhase +
                               /*MW:OvSatOk*/ 1U);
                ramper = Model_TargetControlDsms.PreAmpMidrangePhase + 1U;

                /* '<S1555>:1:33' Phase = ramper; */
                Model_TargetControlDsms.PreAmpMidrangePhase =
                    Model_TargetControlDsms.PreAmpMidrangePhase + 1U;

                /* '<S1555>:1:34' k = Rampers(ramper).rampCoeff; */
                k = Model_TargetControlDsms.PreAmpMidrangeRampers[qY - 1].
                    rampCoeff;

                /* '<S1555>:1:35' gain = Rampers(ramper).currentGain; */
                gain = Model_TargetControlDsms.PreAmpMidrangeRampers[qY - 1].
                    currentGain;

                /* '<S1555>:1:36' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                q0 = Model_TargetControlDsms.PreAmpMidrangeRampers[qY - 1].
                    frameCount;
                if (q0 < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpMidrangeRampers[qY - 1].
                        frameCount = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpMidrangeRampers[qY - 1].
                        frameCount = q0 - 1;
                }
            }
            else
            {
                /* '<S1555>:1:37' else */
                /*   Stop ramping and SNAP to the target */
                /* '<S1555>:1:39' k = single(1); */
                k = 1.0F;

                /* '<S1555>:1:40' gain = Rampers(ramper).targetGain; */
                gain = Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpMidrangePhase - 1].targetGain;

                /*  Update completion flag */
            }
        }
        else
        {
            /* '<S1555>:1:43' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S1555>:1:45' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangePhase - 1].rampCoeff;

            /* '<S1555>:1:46' gain = Rampers(ramper).currentGain; */
            gain = Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangePhase - 1].currentGain;

            /* '<S1555>:1:47' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            q0 = Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                Model_TargetControlDsms.PreAmpMidrangePhase - 1].frameCount;
            if (q0 < -2147483647)
            {
                Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpMidrangePhase - 1].frameCount =
                    MIN_int32_T;
            }
            else
            {
                Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpMidrangePhase - 1].frameCount =
                    q0 - 1;
            }
        }
    }
    else
    {
        /* '<S1555>:1:49' else */
        /*  Frozen. Stay at current gain */
        /* '<S1555>:1:51' k = single(1); */
        k = 1.0F;

        /* '<S1555>:1:52' gain = Rampers(ramper).currentGain; */
        gain = Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)
            Model_TargetControlDsms.PreAmpMidrangePhase - 1].currentGain;
    }

    /*  Apply the tone filter */
    /* '<S1555>:1:56' if (gain < 1) */
    if (gain < 1.0F)
    {
        /*  Cut */
        /* '<S1555>:1:58' aCoeffs = cut_coeffs(1:2); */
        aCoeffs_idx_0 = rtu_cut_coeffs[0];
        aCoeffs_idx_1 = rtu_cut_coeffs[1];

        /* '<S1555>:1:59' bCoeffs = cut_coeffs(3:5); */
        bCoeffs_idx_0 = rtu_cut_coeffs[2];
        bCoeffs_idx_2 = rtu_cut_coeffs[4];
    }
    else
    {
        /* '<S1555>:1:60' else */
        /*  Boost */
        /* '<S1555>:1:62' aCoeffs = boost_coeffs(1:2); */
        aCoeffs_idx_0 = rtu_boost_coeffs[0];
        aCoeffs_idx_1 = rtu_boost_coeffs[1];

        /* '<S1555>:1:63' bCoeffs = boost_coeffs(3:5); */
        bCoeffs_idx_0 = rtu_boost_coeffs[2];
        bCoeffs_idx_2 = rtu_boost_coeffs[4];
    }

    /*  [filtered,toneFilterStates] = filter(bCoeffs, aCoeffs, audioIn, toneFilterStates); */
    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S1555>:1:69' for n=1:frame_size */
    for (q0 = 0; q0 < 32; q0++)
    {
        real32_T filterOut;
        real32_T filterOut_tmp;

        /*  Update the gain and then subtract one before applying it to the */
        /*  filtered signal. Disregarding phase shifting  */
        /* '<S1555>:1:72' gain = gain * k; */
        gain *= k;

        /* '<S1555>:1:73' filterGain = gain - 1; */
        /*  Loop through channels adding in gain-adjusted filtered samples */
        /* '<S1555>:1:75' for chanIdx = 1:channel_count */
        /* '<S1555>:1:77' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(1,chanIdx); */
        filterOut = bCoeffs_idx_0 * rtu_audioIn[q0] + localDW->toneFilterStates
            [0];

        /* '<S1555>:1:78' toneFilterStates(1,chanIdx) = toneFilterStates(2,chanIdx) - aCoeffs(1) * filterOut; */
        localDW->toneFilterStates[0] = localDW->toneFilterStates[1] -
            aCoeffs_idx_0 * filterOut;

        /* '<S1555>:1:79' toneFilterStates(2,chanIdx) = bCoeffs(3) * audioIn(n,chanIdx) - (aCoeffs(2) * filterOut); */
        localDW->toneFilterStates[1] = bCoeffs_idx_2 * rtu_audioIn[q0] -
            aCoeffs_idx_1 * filterOut;

        /* '<S1555>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0] = (gain - 1.0F) * filterOut + rtu_audioIn[q0];

        /* '<S1555>:1:77' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(1,chanIdx); */
        filterOut_tmp = rtu_audioIn[q0 + 32];
        filterOut = filterOut_tmp * bCoeffs_idx_0 + localDW->toneFilterStates[2];

        /* '<S1555>:1:78' toneFilterStates(1,chanIdx) = toneFilterStates(2,chanIdx) - aCoeffs(1) * filterOut; */
        localDW->toneFilterStates[2] = localDW->toneFilterStates[3] -
            aCoeffs_idx_0 * filterOut;

        /* '<S1555>:1:79' toneFilterStates(2,chanIdx) = bCoeffs(3) * audioIn(n,chanIdx) - (aCoeffs(2) * filterOut); */
        localDW->toneFilterStates[3] = filterOut_tmp * bCoeffs_idx_2 -
            aCoeffs_idx_1 * filterOut;

        /* '<S1555>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0 + 32] = (gain - 1.0F) * filterOut + filterOut_tmp;
    }

    /* '<S1555>:1:85' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpMidrangeRampers[(int32_T)ramper - 1].
        currentGain = gain;
}

/*
 * Output and update for function-call system:
 *    '<S1526>/SetDsm'
 *    '<S1526>/SetDsm1'
 */
void Model_Target_SetDsm_i(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1582>/Data Store Write' incorporates:
     *  Constant: '<S1582>/Constant'
     */
    Model_TargetControlDsms.PreAmpTrebleFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1526>/tone control' */
void Model_Target_tonecontrol_f(real32_T rtu_boost_max_db, real32_T
    rtu_cut_max_db, real32_T rtu_normalized_gain_impact, real32_T rtu_db_per_sec,
    real32_T rtu_ramp_time_ms, real32_T rtu_sample_rate_in_hertz, real32_T
    rtu_frame_size)
{
    suFnE4DIYISSjYbtQHPXOwD_Model_Target_T phaseConfig[2];
    real32_T currentGain_tmp;
    real32_T currentImpact_db;
    real32_T db_diff;
    real32_T quantum_ms;
    real32_T targetEffectiveGain;
    real32_T targetImpact_db;
    real32_T x;
    boolean_T currentIsBoost;
    boolean_T targetIsBoost;

    /*  %inputs */
    /*  % inputs % parameters */
    /* parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Treble/tone control': '<S1592>:1' */
    /*  See Control summary at the end: */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step now performed on canvas) */
    /*  Step 2a: IMPACT-TARGET Translate the normalized gain into a dB impact */
    /*  based on the maximum boost or cut values. */
    /*  ("-1" = maximum cut, "1" = maximum boost.) */
    /* '<S1592>:1:16' targetIsBoost = (normalized_gain_impact >= 0); */
    targetIsBoost = (rtu_normalized_gain_impact >= 0.0F);

    /* '<S1592>:1:17' if (targetIsBoost) */
    if (targetIsBoost)
    {
        /* '<S1592>:1:18' targetImpact_db = normalized_gain_impact * boost_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_boost_max_db;

        /* '<S1592>:1:19' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: undb20.m 11244 2011-10-31 18:51:23Z rg20270 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  1 or greater */
    }
    else
    {
        /* '<S1592>:1:20' else */
        /* '<S1592>:1:21' targetImpact_db = normalized_gain_impact * cut_max_db; */
        targetImpact_db = rtu_normalized_gain_impact * rtu_cut_max_db;

        /* '<S1592>:1:22' targetEffectiveGain = undb20(targetImpact_db); */
        /* UNDB20  Decibels to linear quantity */
        /*    Converts x from DB to absolute magnitude assuming that x is in volts. */
        /*    y = 10^(x/20) */
        /*  */
        /*  See also: DB20, UNDB10 */
        /*    Copyright 2018-2019 Bose Corporation */
        /*  Created : 9/7/1994 Bill Berardi */
        /* $Id: undb20.m 11244 2011-10-31 18:51:23Z rg20270 $ */
        /* 'undb20:12' y = exp(x * log(10)/20); */
        targetEffectiveGain = qhmath_exp_f(qhmath_div_f(targetImpact_db *
            2.30258512F, 20.0F));

        /*  less than 1 */
    }

    /* '<S1592>:1:25' actualTargetGainLinear = targetEffectiveGain; */
    /*  Step 2b: IMPACT-CURRENT Fetch the current gain from the previously */
    /*  active ramper. */
    /* '<S1592>:1:29' currentPhase = Phase; */
    /* '<S1592>:1:30' currentGain = Rampers(currentPhase).currentGain; */
    currentGain_tmp = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
        Model_TargetControlDsms.PreAmpTreblePhase - 1].currentGain;

    /* '<S1592>:1:31' currentIsBoost = (currentGain >= 1); */
    currentIsBoost = (currentGain_tmp >= 1.0F);

    /* '<S1592>:1:32' currentImpact_db = db20(currentGain); */
    /* DB20  Linear quantity to decibels */
    /*    Converts x to dB assuming that x represents volts. */
    /*    y=20*log10(abs(x)); */
    /*  */
    /*  See Also: DB10, UNDB20 */
    /*    Copyright 2018-2019 Bose Corporation */
    /*  Bill Berardi */
    /*  $Id: db20.m 11813 2012-07-11 17:31:25Z rs7109 $ */
    /* 'db20:12' y = 20/log(10)*log(abs(x)); */
    currentImpact_db = qhmath_log_f(qhmath_abs_f(currentGain_tmp)) * 8.68588924F;

    /*  Setup processing to continue on seamlessly while we work here */
    /* '<S1592>:1:35' Rampers(1).currentGain = currentGain; */
    /* '<S1592>:1:36' Phase = uint32(1); */
    Model_TargetControlDsms.PreAmpTreblePhase = 1U;

    /*  reset phase to 1 */
    /*  Now that we have both current and target impacts, find the difference */
    /* '<S1592>:1:38' db_diff = abs(currentImpact_db - targetImpact_db); */
    db_diff = qhmath_abs_f(currentImpact_db - targetImpact_db);

    /*  Step 3a: TIME- If a slope in dB/second is provided, ignore the ramp time */
    /* '<S1592>:1:41' if (db_per_sec) */
    if (rtu_db_per_sec != 0.0F)
    {
        /* '<S1592>:1:42' ramp_ms = db_diff / single(db_per_sec) * 1000; */
        x = qhmath_div_f(db_diff, rtu_db_per_sec) * 1000.0F;
    }
    else
    {
        /* '<S1592>:1:43' else */
        /* '<S1592>:1:44' ramp_ms = single(ramp_time_ms); */
        x = rtu_ramp_time_ms;
    }

    /*  Step 3b: TIME- QUANTIZE the desired ramp time to our FrameSize.  */
    /* '<S1592>:1:48' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);

    /* '<S1592>:1:49' numFrames = ramp_ms / quantum_ms; */
    /* '<S1592>:1:50' numFrames = max (1, ceil(numFrames)); */
    x = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(x, quantum_ms)));

    /*  Step 4a: PHASES- Determine whether ramping from current gain to target */
    /*  gain requires a unity crossing in linear gain. */
    /* '<S1592>:1:54' isTwoPhase = (currentIsBoost ~= targetIsBoost) && ... */
    /* '<S1592>:1:55'              (currentGain ~= 1) && ... % cannot cross if you're already there */
    /* '<S1592>:1:56'              (targetImpact_db ~= 1); */
    /*  % cannot cross if you're already there */
    /*  no crossing needed when impact already nothing */
    /*  Setup a structure to hold information about what the rampers should do */
    /* '<S1592>:1:58' twoSingles = {single(0) single(0)}; */
    /* '<S1592>:1:59' phaseConfig = struct('frames',twoSingles,'target_linear',twoSingles,'current_linear',twoSingles); */
    /* '<S1592>:1:60' phaseConfig = tone_control_split(numFrames,currentImpact_db,db_diff,... */
    /* '<S1592>:1:61'     currentGain,currentIsBoost,rgain_SILENT_GAIN,targetIsBoost,... */
    /* '<S1592>:1:62'     targetEffectiveGain,isTwoPhase,phaseConfig); */
    /* '<S1592>:1:104' if (isTwoPhase) */
    if ((currentIsBoost != targetIsBoost) && (currentGain_tmp != 1.0F) &&
            (targetImpact_db != 1.0F))
    {
        /*  Both boost and cut phases will be required to get where we are going. */
        /*  Make sure we have at least two frames to work with: */
        /* '<S1592>:1:107' numFrames = max (2, round(numFrames)); */
        x = fmaxf(2.0F, x);

        /*  Divide up our ramp time into pieces for each phase to use */
        /* '<S1592>:1:110' phase1Frames = ceil(numFrames * abs(currentImpact_db) / db_diff); */
        targetImpact_db = qhmath_ceil_f(qhmath_div_f(x * qhmath_abs_f
            (currentImpact_db), db_diff));

        /* '<S1592>:1:111' phase2Frames = numFrames - phase1Frames; */
        /*  Make sure phase 2 has at least 1 frame to work with */
        /* '<S1592>:1:114' phase2Frames = max(1, phase2Frames); */
        phaseConfig[1].frames = fmaxf(1.0F, x - targetImpact_db);

        /*  Setup Phase 1 ramper that takes us to zero impact (i.e. unity gain) */
        /* '<S1592>:1:117' phaseConfig(1).current_linear   = currentGain; */
        phaseConfig[0].current_linear = currentGain_tmp;

        /*  we know this is not 1 */
        /* '<S1592>:1:118' phaseConfig(1).target_linear    = NudgeUnity(1,currentIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1592>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1592>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = 1.00000048F;
        }
        else
        {
            /* '<S1592>:1:96' else */
            /* '<S1592>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = 0.999999523F;
        }

        /* '<S1592>:1:119' phaseConfig(1).frames           = phase1Frames; */
        phaseConfig[0].frames = targetImpact_db;

        /*  Setup Phase 2 ramper that delivers us to target impact */
        /* '<S1592>:1:122' phaseConfig(2).current_linear   = NudgeUnity(1,targetIsBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1592>:1:94' if (isPositive) */
        if (targetIsBoost)
        {
            /* '<S1592>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].current_linear = 1.00000048F;
        }
        else
        {
            /* '<S1592>:1:96' else */
            /* '<S1592>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].current_linear = 0.999999523F;
        }

        /*  start quiet */
        /* '<S1592>:1:123' phaseConfig(2).target_linear    = targetEffectiveGain; */
        phaseConfig[1].target_linear = targetEffectiveGain;

        /*  we know this is not 0 */
        /* '<S1592>:1:124' phaseConfig(2).frames           = phase2Frames; */
    }
    else
    {
        /* '<S1592>:1:125' else */
        /*  Only one phase is needed to accomplish our goal. We are are the */
        /*  target side of unity... but we must determine which side that is */
        /* '<S1592>:1:128' if (currentGain == 1) */
        if (currentGain_tmp == 1.0F)
        {
            /*  One is in-between sides: use the target to determine the side */
            /* '<S1592>:1:130' isBoost = targetIsBoost; */
            currentIsBoost = targetIsBoost;
        }
        else
        {
            /* '<S1592>:1:131' else */
            /*  Current gain is already on one side of unity so use that */
            /* '<S1592>:1:133' isBoost = currentIsBoost; */
        }

        /* '<S1592>:1:135' phaseConfig(1).current_linear   = NudgeUnity(currentGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1592>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1592>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].current_linear = fmaxf(currentGain_tmp, 1.00000048F);

            /* '<S1592>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[0].target_linear = fmaxf(targetEffectiveGain,
                1.00000048F);
        }
        else
        {
            /* '<S1592>:1:96' else */
            /* '<S1592>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].current_linear = fminf(currentGain_tmp, 0.999999523F);

            /* '<S1592>:1:96' else */
            /* '<S1592>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[0].target_linear = fminf(targetEffectiveGain,
                0.999999523F);
        }

        /* '<S1592>:1:136' phaseConfig(1).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1592>:1:94' if (isPositive) */
        /* '<S1592>:1:137' phaseConfig(1).frames           = numFrames; */
        phaseConfig[0].frames = x;

        /*  Setup Phase 2 ramper to sit at the target gain */
        /* '<S1592>:1:140' phaseConfig(2).current_linear   = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1592>:1:94' if (isPositive) */
        if (currentIsBoost)
        {
            /* '<S1592>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            targetImpact_db = fmaxf(targetEffectiveGain, 1.00000048F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S1592>:1:95' adjustedLinearGain = max(linearGain, 1 + silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }
        else
        {
            /* '<S1592>:1:96' else */
            /* '<S1592>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            targetImpact_db = fminf(targetEffectiveGain, 0.999999523F);
            phaseConfig[1].current_linear = targetImpact_db;

            /* '<S1592>:1:96' else */
            /* '<S1592>:1:97' adjustedLinearGain = min(linearGain, 1 - silentGain); */
            phaseConfig[1].target_linear = targetImpact_db;
        }

        /* '<S1592>:1:141' phaseConfig(2).target_linear    = NudgeUnity(targetEffectiveGain,isBoost,rgain_SILENT_GAIN); */
        /*  Nudge the gain values a bit if they are sitting right at one (aka unity). */
        /*  When a control set goes live, ensure that the current gain will move. */
        /*  If current gain is one, replace with a value very close to one. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. Remember that normally we */
        /*  worry about gains of 0 -- this checks instead against 1 because filter */
        /*  gain is effective gain minuus 1. */
        /* '<S1592>:1:94' if (isPositive) */
        /* '<S1592>:1:142' phaseConfig(2).frames           = single(0); */
        phaseConfig[1].frames = 0.0F;
    }

    /*  Step 4b: PHASES- Setup rampers for both phases */
    /* '<S1592>:1:65' for currentPhase=1:2 */
    /* '<S1592>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[0].frames != 0.0F)
    {
        /* '<S1592>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1592>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1592>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpTrebleRampers[0].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[0].target_linear,
                phaseConfig[0].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[0].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1592>:1:70' else */
        /* '<S1592>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpTrebleRampers[0].rampCoeff = 1.0F;
    }

    /* '<S1592>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1592>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpTrebleRampers[0].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1592>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpTrebleRampers[0].currentGain = phaseConfig[0].
        current_linear;

    /* '<S1592>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpTrebleRampers[0].frameCount = (int32_T)
        phaseConfig[0].frames;

    /* '<S1592>:1:66' if (phaseConfig(currentPhase).frames) */
    if (phaseConfig[1].frames != 0.0F)
    {
        /* '<S1592>:1:67' ramp_ms = quantum_ms * phaseConfig(currentPhase).frames; */
        /* '<S1592>:1:68' factor = log(phaseConfig(currentPhase).target_linear / phaseConfig(currentPhase).current_linear); */
        /* '<S1592>:1:69' RampCoef = exp(factor / (sample_rate_in_hertz * ramp_ms / 1000)); */
        Model_TargetControlDsms.PreAmpTrebleRampers[1].rampCoeff = qhmath_exp_f
            (qhmath_div_f(qhmath_log_f(qhmath_div_f(phaseConfig[1].target_linear,
                phaseConfig[1].current_linear)), qhmath_div_f(quantum_ms *
               phaseConfig[1].frames * rtu_sample_rate_in_hertz, 1000.0F)));
    }
    else
    {
        /* '<S1592>:1:70' else */
        /* '<S1592>:1:71' RampCoef = single(1); */
        Model_TargetControlDsms.PreAmpTrebleRampers[1].rampCoeff = 1.0F;
    }

    /* '<S1592>:1:73' Rampers(currentPhase).rampCoeff   = single(RampCoef); */
    /* '<S1592>:1:74' Rampers(currentPhase).targetGain  = actualTargetGainLinear; */
    Model_TargetControlDsms.PreAmpTrebleRampers[1].targetGain =
        targetEffectiveGain;

    /*  phase 1 value ignored. */
    /* '<S1592>:1:75' Rampers(currentPhase).currentGain = single(phaseConfig(currentPhase).current_linear); */
    Model_TargetControlDsms.PreAmpTrebleRampers[1].currentGain = phaseConfig[1].
        current_linear;

    /* '<S1592>:1:76' Rampers(currentPhase).frameCount  = int32(phaseConfig(currentPhase).frames); */
    Model_TargetControlDsms.PreAmpTrebleRampers[1].frameCount = (int32_T)
        phaseConfig[1].frames;

    /*  unfreeze the gain. (This step now performed on canvas) */
}

/* Output and update for function-call system: '<S1581>/REQ' */
void HandleReqPreAmpTrebleSet(void)
{
    /* MATLAB Function: '<S1526>/index to linear' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1596>:1' */
    /* '<S1596>:1:3' go(); */
    Model_Target_indextolinear(Model_Target_PreAmp_p0_b0.TrebleScale,
        Model_Target_PreAmp_p0_b0.TrebleOffset,
        Model_TargetPreAmpTrebleSetRtcOut.REQ_gain_index,
        &Model_Target_PreAmpPart1_B.sf_indextolinear_fx);

    /* MATLAB Function: '<S1526>/ramp parameters' */
    Model_Target_rampparameters_g(Model_Target_PreAmp_p0_b0.Trebleramptime,
        Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_milliseconds,
        Model_TargetPreAmpTrebleSetRtcOut.REQ_ramp_db_per_second,
        Model_Target_ConstP.pooled1, Model_Target_ConstP.pooled2,
        &Model_Target_PreAmpPart1_B.sf_rampparameters_lv);

    /* Outputs for Function Call SubSystem: '<S1526>/SetDsm' */
    Model_Target_SetDsm_i(1U);

    /* End of Outputs for SubSystem: '<S1526>/SetDsm' */

    /* MATLAB Function: '<S1526>/tone control' */
    /* MATLAB Function: '<S1526>/tone control' incorporates:
     *  S-Function (AudioStats_MEX): '<S1526>/Audio Stats'
     */
    Model_Target_tonecontrol_f(Model_Target_PreAmp_p0_b0.TrebleBoostMaximum_dB,
        Model_Target_PreAmp_p0_b0.TrebleCutMaximum_dB,
        Model_Target_PreAmpPart1_B.sf_indextolinear_fx.linearGain,
        Model_Target_PreAmpPart1_B.sf_rampparameters_lv.rampRate,
        Model_Target_PreAmpPart1_B.sf_rampparameters_lv.ramptime,
        44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1526>/SetDsm1' */
    Model_Target_SetDsm_i(0U);

    /* End of Outputs for SubSystem: '<S1526>/SetDsm1' */
}

/* Output and update for atomic system: '<S1526>/tone' */
void Model_Target_tone_j(const real32_T rtu_boost_coeffs[3], const real32_T
    rtu_cut_coeffs[3], const real32_T rtu_audioIn[64], B_tone_Model_Target_g_T
    *localB, DW_tone_Model_Target_h_T *localDW)
{
    int32_T q0;
    int32_T qY;
    real32_T aCoeffs;
    real32_T bCoeffs_idx_0;
    real32_T bCoeffs_idx_1;
    real32_T gain;
    real32_T k;
    uint32_T ramper;

    /*     % inputs % parameters */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/Treble/tone': '<S1591>:1' */
    /*  Data Store objects (registered in "Edit Data" dialog */
    /*  Keep memory for the filter persistent from frame to frame */
    /*  figure out the frame size and channel count */
    /* '<S1591>:1:15' [frame_size, channel_count] = size(audioIn); */
    /* '<S1591>:1:17' if (isempty(toneFilterStates)) */
    /*  set the size and datatype of the output buffer */
    /* '<S1591>:1:23' audioOut = coder.nullcopy(audioIn); */
    /* '<S1591>:1:25' ramper = Phase; */
    ramper = Model_TargetControlDsms.PreAmpTreblePhase;

    /* '<S1591>:1:26' ramperCount = numel(Rampers); */
    /* '<S1591>:1:28' if (Freeze == false) */
    if (Model_TargetControlDsms.PreAmpTrebleFreeze == 0U)
    {
        /* '<S1591>:1:29' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount == 0)
        {
            /*  The current ramper is finished. Is there another one? */
            /* '<S1591>:1:31' if (ramper < ramperCount && Rampers(ramper+1).frameCount > 0) */
            if ((Model_TargetControlDsms.PreAmpTreblePhase < 2U) &&
                    (Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                     Model_TargetControlDsms.PreAmpTreblePhase].frameCount > 0))
            {
                /*  Yes - move on to the next phase */
                /* '<S1591>:1:33' ramper = ramper + 1; */
                qY = (int32_T)(Model_TargetControlDsms.PreAmpTreblePhase +
                               /*MW:OvSatOk*/ 1U);
                ramper = Model_TargetControlDsms.PreAmpTreblePhase + 1U;

                /* '<S1591>:1:34' Phase = ramper; */
                Model_TargetControlDsms.PreAmpTreblePhase =
                    Model_TargetControlDsms.PreAmpTreblePhase + 1U;

                /* '<S1591>:1:35' k = Rampers(ramper).rampCoeff; */
                k = Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                    rampCoeff;

                /* '<S1591>:1:36' gain = Rampers(ramper).currentGain; */
                gain = Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                    currentGain;

                /* '<S1591>:1:37' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                q0 = Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                    frameCount;
                if (q0 < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                        frameCount = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpTrebleRampers[qY - 1].
                        frameCount = q0 - 1;
                }
            }
            else
            {
                /* '<S1591>:1:38' else */
                /*   Stop ramping and SNAP to the target */
                /* '<S1591>:1:40' k = single(1); */
                k = 1.0F;

                /* '<S1591>:1:41' gain = Rampers(ramper).targetGain; */
                gain = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpTreblePhase - 1].targetGain;

                /*  Update completion flag */
            }
        }
        else
        {
            /* '<S1591>:1:44' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S1591>:1:46' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].rampCoeff;

            /* '<S1591>:1:47' gain = Rampers(ramper).currentGain; */
            gain = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].currentGain;

            /* '<S1591>:1:48' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            q0 = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount;
            if (q0 < -2147483647)
            {
                Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount =
                    MIN_int32_T;
            }
            else
            {
                Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
                    Model_TargetControlDsms.PreAmpTreblePhase - 1].frameCount =
                    q0 - 1;
            }
        }
    }
    else
    {
        /* '<S1591>:1:50' else */
        /*  Frozen. Stay at current gain */
        /* '<S1591>:1:52' k = single(1); */
        k = 1.0F;

        /* '<S1591>:1:53' gain = Rampers(ramper).currentGain; */
        gain = Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)
            Model_TargetControlDsms.PreAmpTreblePhase - 1].currentGain;
    }

    /*  Apply the tone filter */
    /* '<S1591>:1:57' if (gain < 1) */
    if (gain < 1.0F)
    {
        /*  Cut */
        /* '<S1591>:1:59' bCoeffs = cut_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_cut_coeffs[0];
        bCoeffs_idx_1 = rtu_cut_coeffs[1];

        /* '<S1591>:1:60' aCoeffs = cut_coeffs(3); */
        aCoeffs = rtu_cut_coeffs[2];
    }
    else
    {
        /* '<S1591>:1:61' else */
        /*  Boost */
        /* '<S1591>:1:63' bCoeffs = boost_coeffs(1:2); */
        bCoeffs_idx_0 = rtu_boost_coeffs[0];
        bCoeffs_idx_1 = rtu_boost_coeffs[1];

        /* '<S1591>:1:64' aCoeffs = boost_coeffs(3); */
        aCoeffs = rtu_boost_coeffs[2];
    }

    /*  [filtered,toneFilterStates] = filter(bCoeffs, aCoeffs, audioIn, toneFilterStates); */
    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S1591>:1:70' for n=1:frame_size */
    for (q0 = 0; q0 < 32; q0++)
    {
        real32_T filterOut;
        real32_T filterOut_tmp;

        /*  Update the gain and then subtract one before applying it to the */
        /*  filtered signal. Disregarding phase shifting  */
        /* '<S1591>:1:73' gain = gain * k; */
        gain *= k;

        /* '<S1591>:1:74' filterGain = gain - 1; */
        /*  Loop through channels adding in gain-adjusted filtered samples */
        /* '<S1591>:1:76' for chanIdx = 1:channel_count */
        /* '<S1591>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut = bCoeffs_idx_0 * rtu_audioIn[q0] + localDW->toneFilterStates
            [0];

        /* '<S1591>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[0] = bCoeffs_idx_1 * rtu_audioIn[q0] + aCoeffs
            * filterOut;

        /* '<S1591>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0] = (gain - 1.0F) * filterOut + rtu_audioIn[q0];

        /* '<S1591>:1:78' filterOut = (bCoeffs(1) * audioIn(n,chanIdx)) + toneFilterStates(chanIdx); */
        filterOut_tmp = rtu_audioIn[q0 + 32];
        filterOut = filterOut_tmp * bCoeffs_idx_0 + localDW->toneFilterStates[1];

        /* '<S1591>:1:79' toneFilterStates(chanIdx) = (bCoeffs(2) * audioIn(n,chanIdx)) + (aCoeffs(1) * filterOut); */
        localDW->toneFilterStates[1] = filterOut_tmp * bCoeffs_idx_1 + aCoeffs *
            filterOut;

        /* '<S1591>:1:81' audioOut(n,chanIdx) = audioIn(n,chanIdx) + (filterOut * filterGain); */
        localB->audioOut[q0 + 32] = (gain - 1.0F) * filterOut + filterOut_tmp;
    }

    /* '<S1591>:1:85' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.PreAmpTrebleRampers[(int32_T)ramper - 1].currentGain
        = gain;
}

/* System initialize for atomic system: '<S4>/PreAmpPart1' */
void Model_Target_PreAmpPart1_Init(void)
{
    /* SystemInitialize for MATLAB Function: '<S1576>/MATLAB Function' */
    /* '<S1567>:1:10' currentFadeInd = 0; */
    /* '<S1567>:1:11' currentSig = uint32(0); */
    /* '<S1580>:1:11' state = single(1 * ones(1,channelCount)); */
    Model_Target_PreAmpPart1_DW.state[0] = 1.0F;
    Model_Target_PreAmpPart1_DW.state[1] = 1.0F;
}

/* Outputs for atomic system: '<S4>/PreAmpPart1' */
void Model_Target_PreAmpPart1(void)
{
    int32_T i;
    int32_T s;
    real32_T rtb_y_l[64];
    real32_T rtb_out_h[32];
    real32_T rtb_thresh[32];
    real32_T musicVolumeLimited;
    real32_T musicVolumeLimited_tmp_0;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1527>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1527>/NTF Trigger' */
    for (i = 0; i < 64; i++)
    {
        /* Product: '<S1564>/Product' incorporates:
         *  S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function'
         */
        Model_Target_PreAmpPart1_B.AttenuatedOutput[i] =
            Model_Target_B.SFunction_g[i] * Model_Target_PreAmp_p0_b0.A;
    }

    /* MATLAB Function: '<S1566>/MaxAnnVolume' */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/MaxAnnVolume': '<S1573>:1' */
    /* '<S1573>:1:3' out = single(ones(1,32)); */
    for (i = 0; i < 32; i++)
    {
        rtb_out_h[i] = 1.0F;
    }

    /* '<S1573>:1:4' for idx = 1:size(in, 2) */
    /* '<S1573>:1:5' out(idx) = max(in(:, idx)); */
    rtb_out_h[0] = Model_Target_B.Mean[0];

    /* '<S1573>:1:5' out(idx) = max(in(:, idx)); */
    rtb_out_h[1] = Model_Target_B.Mean[1];

    /* End of MATLAB Function: '<S1566>/MaxAnnVolume' */
    /* MATLAB Function: '<S1566>/Threshold Logic' incorporates:
     *  Constant: '<S1566>/MaxGain'
     *  Constant: '<S1566>/MinGain'
     *  Delay: '<S26>/Delay'
     *  MATLAB Function: '<S1576>/CalcThreshold'
     *  S-Function (TOP_MEX): '<S1576>/attack'
     */
    /*  Keep the music limited to the minimum of the specifed music threshold or */
    /*  the current level of the phone minus a tuned offset */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/Threshold Logic': '<S1574>:1' */
    /* '<S1574>:1:5' thresh = single(annVolume); */
    /*  Limit announcement and entertainment volumes to 1 or less */
    /* '<S1574>:1:8' annVolumeLimited = min(1.0, annVolume); */
    /* '<S1574>:1:9' musicVolumeLimited = min(1.0, musicVolume); */
    musicVolumeLimited = fminf(1.0F, Model_Target_PreAmpPart1_DW.Delay_DSTATE);

    /*  Calculate target threshold */
    /* '<S1574>:1:12' annTargetLevel = predAnn * annVolumeLimited / (phoneOffsetLinear + eps); */
    /* '<S1574>:1:13' targetLevel = min(musicThreshLinear, annTargetLevel); */
    /* '<S1574>:1:14' musicVolumeSamp = musicVolumeLimited(floor((0:(numel(targetLevel)-1)) / frameSize) + 1); */
    /* '<S1574>:1:15' thresh = targetLevel ./ (musicVolumeSamp + eps); */
    /*  Check limits */
    /* '<S1574>:1:18' thresh = thresh / musicThreshLinear; */
    /* '<S1574>:1:19' thresh = min(maxGain, thresh); */
    /* '<S1574>:1:20' thresh = max(minGain, thresh); */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/limiter/CalcThreshold': '<S1579>:1' */
    /* '<S1579>:1:3' thresholdOut = attack ./ single(thresholdIn); */
    for (i = 0; i < 32; i++)
    {
        rtb_thresh[i] = qhmath_div_f(Model_Target_PreAmp_p0_b0.Limiterattack[i],
            fmaxf(9.99999902E-5F, fminf(1.0F, qhmath_div_f(qhmath_div_f(fminf
            (Model_Target_PreAmp_p0_b0.UpperThreshold, qhmath_div_f
             (Model_Target_PreAmp_p0_b0.AnnPred * fminf(1.0F, rtb_out_h[i]),
              Model_Target_PreAmp_p0_b0.Offset + 2.22044605E-16F)),
            musicVolumeLimited + 2.22044605E-16F),
            Model_Target_PreAmp_p0_b0.UpperThreshold))));
    }

    /* End of MATLAB Function: '<S1566>/Threshold Logic' */
    /* MATLAB Function: '<S1576>/MATLAB Function' incorporates:
     *  Product: '<S1564>/Product'
     *  S-Function (TOP_MEX): '<S1576>/attack'
     *  S-Function (TOP_MEX): '<S1576>/decay'
     *  S-Function (TOP_MEX): '<S1576>/maxAttack'
     */
    /*  Grab data from input */
    /* MATLAB Function 'ModelPreAmp/PreAmpPart1/NEARPreAmp/MusicLimiter/limiter/MATLAB Function': '<S1580>:1' */
    /* '<S1580>:1:4' y = coder.nullcopy(u); */
    /* '<S1580>:1:5' [frameSize, channelCount] = size(u); */
    /* '<S1580>:1:7' maxGain = single(1); */
    /* '<S1580>:1:10' if isempty(state) */
    /*  Process the audio */
    /* '<S1580>:1:15' for i = 1:channelCount */
    for (i = 0; i < 2; i++)
    {
        /* '<S1580>:1:16' k0 = 1 + attack(i); */
        /* '<S1580>:1:17' g1 = state(i); */
        musicVolumeLimited = Model_Target_PreAmpPart1_DW.state[i];

        /* '<S1580>:1:19' for s = 1:frameSize */
        for (s = 0; s < 32; s++)
        {
            int32_T musicVolumeLimited_tmp;

            /*  Compute the gain for this sample. Implementation copied from BDSP */
            /* '<S1580>:1:21' p1 = k1(i) * g1; */
            /* '<S1580>:1:22' p2 = u(s, i); */
            /* '<S1580>:1:23' p2 = abs(p2); */
            /* '<S1580>:1:24' g1 = g1 * decay(i); */
            /* '<S1580>:1:25' p2 = p2 * p1; */
            /* '<S1580>:1:26' p2 = max(p2, attack(i)); */
            /* '<S1580>:1:27' p2 = k0 - p2; */
            /* '<S1580>:1:28' p2 = max(p2, maxAttack(i)); */
            /* '<S1580>:1:29' g1 = g1 * p2; */
            /* '<S1580>:1:30' g1 = min(g1, maxGain); */
            musicVolumeLimited_tmp = (i << 5) + s;
            musicVolumeLimited_tmp_0 =
                Model_Target_PreAmpPart1_B.AttenuatedOutput[musicVolumeLimited_tmp];
            musicVolumeLimited = fminf(fmaxf
                ((Model_Target_PreAmp_p0_b0.Limiterattack[i] + 1.0F) - fmaxf
                 (rtb_thresh[i] * musicVolumeLimited * qhmath_abs_f
                  (musicVolumeLimited_tmp_0),
                  Model_Target_PreAmp_p0_b0.Limiterattack[i]),
                 Model_Target_PreAmp_p0_b0.LimitermaxAttack[i]) *
                (musicVolumeLimited * Model_Target_PreAmp_p0_b0.Limiterdecay[i]),
                1.0F);

            /*  Apply the gain */
            /* '<S1580>:1:33' y(s, i) = u(s, i) * g1; */
            rtb_y_l[musicVolumeLimited_tmp] = musicVolumeLimited_tmp_0 *
                musicVolumeLimited;
        }

        /* '<S1580>:1:36' state(i) = g1; */
        Model_Target_PreAmpPart1_DW.state[i] = musicVolumeLimited;
    }

    /* End of MATLAB Function: '<S1576>/MATLAB Function' */

    /* Product: '<S1571>/Divide' incorporates:
     *  Constant: '<S1571>/Constant3'
     *  Selector: '<S1571>/Selector1'
     *  Selector: '<S1571>/Selector6'
     *  Sum: '<S1571>/Add'
     */
    for (i = 0; i < 32; i++)
    {
        rtb_out_h[i] = qhmath_div_f(rtb_y_l[i + 32] + rtb_y_l[i], 2.0F);
    }

    /* End of Product: '<S1571>/Divide' */
    for (i = 0; i < 32; i++)
    {
        /* Product: '<S1571>/Multiply' incorporates:
         *  Constant: '<S1571>/Constant4'
         *  Constant: '<S1571>/Constant5'
         *  Product: '<S1571>/Divide1'
         *  Selector: '<S1571>/Selector1'
         *  Selector: '<S1571>/Selector6'
         *  Sum: '<S1571>/Subtract'
         *  Sum: '<S1571>/Subtract1'
         */
        musicVolumeLimited = qhmath_div_f(rtb_y_l[i] - rtb_y_l[i + 32], 2.0F) *
            (1.0F - Model_Target_PreAmp_p0_b0.G);

        /* Sum: '<S1571>/Add1' incorporates:
         *  Product: '<S1571>/Divide'
         */
        musicVolumeLimited_tmp_0 = rtb_out_h[i];
        rtb_y_l[i] = musicVolumeLimited_tmp_0 + musicVolumeLimited;

        /* Sum: '<S1571>/Subtract2' incorporates:
         *  Product: '<S1571>/Divide'
         */
        rtb_y_l[i + 32] = musicVolumeLimited_tmp_0 - musicVolumeLimited;
    }

    /* MATLAB Function: '<S1563>/Crossfade ' incorporates:
     *  Concatenate: '<S1571>/Matrix Concatenate'
     *  S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function'
     */
    /*  fadetime in ms */
    /*  sigSelect = 0 passes normalEnt, sigSelect = 1 passes monoEnt */
    /* MATLAB Function 'CrossFader/Crossfade ': '<S1567>:1' */
    /*  first run init */
    /* '<S1567>:1:9' if (isempty(currentFadeInd)) */
    /*  Selection changed */
    /* '<S1567>:1:15' startFade = 0; */
    i = 0;

    /* '<S1567>:1:16' if (currentSig ~= sigSelect) */
    if (Model_Target_PreAmpPart1_DW.currentSig != Model_Target_B.y)
    {
        /*     currentSig = sigSelect; */
        /* '<S1567>:1:18' currentSig = uint32(sigSelect); */
        Model_Target_PreAmpPart1_DW.currentSig = Model_Target_B.y;

        /* '<S1567>:1:19' currentFadeInd = 0; */
        Model_Target_PreAmpPart1_DW.currentFadeInd = 0.0;

        /* '<S1567>:1:20' startFade = 1; */
        i = 1;
    }

    /* '<S1567>:1:23' crossfadedOutput = single(zeros(size(normalEnt))); */
    /* '<S1567>:1:24' normalEntOutput = single(zeros(size(normalEnt))); */
    /* '<S1567>:1:25' monoEntOutput = single(zeros(size(normalEnt))); */
    /*  Process the audio */
    /* '<S1567>:1:28' if ((currentFadeInd ~= 0)||(startFade)) */
    if ((Model_Target_PreAmpPart1_DW.currentFadeInd != 0.0) || (i != 0))
    {
        /*  Apply the cross fade gains, either because we're mid-ramp or we're */
        /*  starting over */
        /* '<S1567>:1:31' for (samp = 1:size(normalEnt, 1) */
        for (i = 0; i < 32; i++)
        {
            real_T monoEntGain;
            real_T normalEntGain;

            /* '<S1567>:1:32' currentFadeInd = currentFadeInd + 1; */
            Model_Target_PreAmpPart1_DW.currentFadeInd++;

            /*  lookup gains for this sample */
            /* '<S1567>:1:34' if (currentFadeInd > fadeSamples) */
            if (Model_Target_PreAmpPart1_DW.currentFadeInd >
                    Model_Target_PreAmpPart1_ConstB.Product)
            {
                /*  we hit the end of the ramp, but we're still working */
                /*  a frame that was ramping */
                /* '<S1567>:1:37' if (currentSig) */
                if (Model_Target_PreAmpPart1_DW.currentSig != 0U)
                {
                    /* '<S1567>:1:38' normalEntGain = 0; */
                    normalEntGain = 0.0;

                    /* '<S1567>:1:39' monoEntGain = 1; */
                    monoEntGain = 1.0;
                }
                else
                {
                    /* '<S1567>:1:40' else */
                    /* '<S1567>:1:41' normalEntGain = 1; */
                    normalEntGain = 1.0;

                    /* '<S1567>:1:42' monoEntGain = 0; */
                    monoEntGain = 0.0;
                }

                /* '<S1567>:1:44' else */
                /*  actively ramping */
                /* '<S1567>:1:46' if (currentSig) */
            }
            else if (Model_Target_PreAmpPart1_DW.currentSig != 0U)
            {
                /*                  sig1Gain = fadeDownGain(currentFadeInd); */
                /* '<S1567>:1:48' normalEntGain = 1-(currentFadeInd/fadeSamples); */
                monoEntGain = Model_Target_PreAmpPart1_DW.currentFadeInd /
                    Model_Target_PreAmpPart1_ConstB.Product;
                normalEntGain = 1.0 - monoEntGain;

                /*                  sig2Gain = fadeUpGain(currentFadeInd); */
                /* '<S1567>:1:50' monoEntGain = (currentFadeInd/fadeSamples); */
            }
            else
            {
                /* '<S1567>:1:51' else */
                /*                  sig1Gain = fadeUpGain(currentFadeInd); */
                /* '<S1567>:1:53' normalEntGain = (currentFadeInd/fadeSamples); */
                normalEntGain = Model_Target_PreAmpPart1_DW.currentFadeInd /
                    Model_Target_PreAmpPart1_ConstB.Product;

                /*                  sig2Gain = fadeDownGain(currentFadeInd); */
                /* '<S1567>:1:55' monoEntGain = 1-(currentFadeInd/fadeSamples); */
                monoEntGain = 1.0 - Model_Target_PreAmpPart1_DW.currentFadeInd /
                    Model_Target_PreAmpPart1_ConstB.Product;
            }

            /*  apply gains */
            /* '<S1567>:1:59' normalEntOutput(samp,:) = (normalEnt(samp,:)*normalEntGain); */
            /* '<S1567>:1:60' monoEntOutput(samp,:) = (monoEnt(samp,:)*monoEntGain); */
            /* '<S1567>:1:61' crossfadedOutput(samp,:) = single(normalEnt(samp,:)*normalEntGain + monoEnt(samp,:)*monoEntGain); */
            Model_Target_PreAmpPart1_B.crossfadedOutput[i] =
                Model_Target_B.SFunction_g[i] * (real32_T)normalEntGain +
                rtb_y_l[i] * (real32_T)monoEntGain;
            Model_Target_PreAmpPart1_B.crossfadedOutput[i + 32] =
                Model_Target_B.SFunction_g[i + 32] * (real32_T)normalEntGain +
                rtb_y_l[i + 32] * (real32_T)monoEntGain;
        }

        /*  reset fade if finished */
        /* '<S1567>:1:64' if (currentFadeInd > fadeSamples) */
        if (Model_Target_PreAmpPart1_DW.currentFadeInd >
                Model_Target_PreAmpPart1_ConstB.Product)
        {
            /* '<S1567>:1:65' currentFadeInd = 0; */
            Model_Target_PreAmpPart1_DW.currentFadeInd = 0.0;
        }

        /* '<S1567>:1:67' else */
        /*  Just pass selected signal */
        /* '<S1567>:1:69' if (currentSig) */
    }
    else if (Model_Target_PreAmpPart1_DW.currentSig != 0U)
    {
        /* '<S1567>:1:70' crossfadedOutput = single(monoEnt(1:size(normalEnt,1),1:size(normalEnt,2))); */
        memcpy(&Model_Target_PreAmpPart1_B.crossfadedOutput[0], &rtb_y_l[0],
               sizeof(real32_T) << 6U);
    }
    else
    {
        /* '<S1567>:1:71' else */
        /* '<S1567>:1:72' crossfadedOutput = single(normalEnt); */
        memcpy(&Model_Target_PreAmpPart1_B.crossfadedOutput[0],
               &Model_Target_B.SFunction_g[0], sizeof(real32_T) << 6U);
    }

    /* End of MATLAB Function: '<S1563>/Crossfade ' */

    /* MATLAB Function: '<S1523>/tone' */
    Model_Target_tone(&(Model_Target_PreAmp_p0_b0.BassBoostCoeffs[0]),
                      &(Model_Target_PreAmp_p0_b0.BassCutCoeffs[0]),
                      Model_Target_PreAmpPart1_B.crossfadedOutput,
                      &Model_Target_PreAmpPart1_B.sf_tone,
                      &Model_Target_PreAmpPart1_DW.sf_tone);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1545>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1545>/NTF Trigger' */
    /* MATLAB Function: '<S1526>/tone' */
    Model_Target_tone_j(&(Model_Target_PreAmp_p0_b0.TrebleBoostCoeffs[0]),
                        &(Model_Target_PreAmp_p0_b0.TrebleCutCoeffs[0]),
                        Model_Target_PreAmpPart1_B.sf_tone.audioOut,
                        &Model_Target_PreAmpPart1_B.sf_tone_j,
                        &Model_Target_PreAmpPart1_DW.sf_tone_j);

    /* MATLAB Function: '<S1524>/tone' */
    Model_Target_tone_k(&(Model_Target_PreAmp_p0_b0.MidrangeBoostCoeffs[0]),
                        &(Model_Target_PreAmp_p0_b0.MidrangeCutCoeffs[0]),
                        Model_Target_PreAmpPart1_B.sf_tone_j.audioOut,
                        &Model_Target_PreAmpPart1_B.sf_tone_k,
                        &Model_Target_PreAmpPart1_DW.sf_tone_k);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1581>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1581>/NTF Trigger' */
}

/* Update for atomic system: '<S4>/PreAmpPart1' */
void Model_Target_PreAmpPart1_Update(void)
{
    /* Update for Delay: '<S26>/Delay' */
    Model_Target_PreAmpPart1_DW.Delay_DSTATE = Model_Target_B.gainSingleChannel;
}

/* System initialize for atomic system: '<S4>/SrcDownEnt' */
void Model_Target_SrcDownEnt_Init(void)
{
    int32_T i;

    /* Start for Constant: '<S1599>/coeffs' */
    memcpy(&Model_Target_B.coeffs_m[0], &Model_Target_ConstP.pooled94[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Start for Constant: '<S1599>/advance' */
        Model_Target_B.advance_a[i] = Model_Target_ConstP.pooled41[i];
    }

    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function' */

    // S-Function Block: <S1599>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 2;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(&Model_Target_B.coeffs_m[0]);
        pFilterEnd = pFilter + (240);
        pFilterCurr = pFilter;
        pAdvance = (int*)(&Model_Target_B.advance_a[0]);
        pAdvanceEnd = pAdvance + (12);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (13) / (12)) + (20);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer<2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer_p[0];
        pInputBufferEnd = (float**)
            &Model_Target_DW.SFunction_pInputBufferEnd_km[0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite_j[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead_e[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)
                &Model_Target_DW.SFunction_InputBuffer_im[0] + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer>>1) - 1;
        }

        // Save pointers
        Model_Target_DW.SFunction_PWORK_fg[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK_fg[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK_fg[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK_fg[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK_fg[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK_fg[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK_fg[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK_fg[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK_fg[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK_fg[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK_h = nBuffer;
    }
}

/* Output and update for atomic system: '<S4>/SrcDownEnt' */
void Model_Target_SrcDownEntTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function' */
    /* Because the Outputs function of multirate block
       <S1599>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S1599>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_g[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_fg
                [0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_fg[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_fg[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_fg[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_fg[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_fg[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_fg[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_fg[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_fg[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_fg[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_h;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_h * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_h;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_h;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_h *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_h *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_h;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_h * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_h;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_h * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_fg[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_fg[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function' */
    /* Because the Update function of multirate block
       <S1599>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S1599>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector1[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_fg
                [0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_fg[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_fg[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_h) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S4>/SrcDownEnt' */
void Model_Target_SrcDownEntTID2(void)
{
    int_T tid = 2;
    int32_T i;

    /* Constant: '<S1599>/coeffs' */
    memcpy(&Model_Target_B.coeffs_m[0], &Model_Target_ConstP.pooled94[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Constant: '<S1599>/advance' */
        Model_Target_B.advance_a[i] = Model_Target_ConstP.pooled41[i];
    }

    /* S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function' */
    /* Because the Outputs function of multirate block
       <S1599>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S1599>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_g[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_fg
                [0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_fg[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_fg[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_fg[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_fg[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_fg[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_fg[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_fg[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_fg[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_fg[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_h;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_h * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_h;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_h;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_h *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_h *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_h;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_h * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_h;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_h * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_fg[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_fg[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function' */
    /* Because the Update function of multirate block
       <S1599>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S1599>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector1[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_fg
                [0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_fg[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_fg[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_h) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S4>/SrcDownEnt' */
void Model_Target_SrcDownEnt_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S1599>/S-Function' */

    /* S-Function Block: <S1599>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/* System initialize for atomic system: '<S4>/SrcDownMic' */
void Model_Target_SrcDownMic_Init(void)
{
    int32_T i;

    /* Start for Constant: '<S1600>/coeffs' */
    memcpy(&Model_Target_B.coeffs_n[0], &Model_Target_ConstP.pooled94[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Start for Constant: '<S1600>/advance' */
        Model_Target_B.advance_l[i] = Model_Target_ConstP.pooled41[i];
    }

    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function' */

    // S-Function Block: <S1600>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 1;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(&Model_Target_B.coeffs_n[0]);
        pFilterEnd = pFilter + (240);
        pFilterCurr = pFilter;
        pAdvance = (int*)(&Model_Target_B.advance_l[0]);
        pAdvanceEnd = pAdvance + (12);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (13) / (12)) + (20);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer<2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer_d[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd_j
            [0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite_f[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead_dq[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)
                &Model_Target_DW.SFunction_InputBuffer_i[0] + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer>>1) - 1;
        }

        // Save pointers
        Model_Target_DW.SFunction_PWORK_d[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK_d[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK_d[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK_d[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK_d[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK_d[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK_d[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK_d[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK_d[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK_d[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK_l = nBuffer;
    }
}

/* Output and update for atomic system: '<S4>/SrcDownMic' */
void Model_Target_SrcDownMicTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function' */
    /* Because the Outputs function of multirate block
       <S1600>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S1600>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 1;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_l[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_d[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_d[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_d[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_d[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_d[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_d[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_d[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_d[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_d[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_d[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_l;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_l * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_l;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_l;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_l *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_l *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_l;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_l * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_l;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_l * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_d[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_d[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function' */
    /* Because the Update function of multirate block
       <S1600>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S1600>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 1;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector3[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_d[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_d[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_d[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_l) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S4>/SrcDownMic' */
void Model_Target_SrcDownMicTID2(void)
{
    int_T tid = 2;
    int32_T i;

    /* Constant: '<S1600>/coeffs' */
    memcpy(&Model_Target_B.coeffs_n[0], &Model_Target_ConstP.pooled94[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Constant: '<S1600>/advance' */
        Model_Target_B.advance_l[i] = Model_Target_ConstP.pooled41[i];
    }

    /* S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function' */
    /* Because the Outputs function of multirate block
       <S1600>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S1600>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 1;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction_l[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_d[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_d[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_d[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_d[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_d[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_d[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_d[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_d[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_d[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_d[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_l;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_l * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_l;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_l;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_l *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_l *
                                       sizeof(float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_l;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_l * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_l;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_l * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_d[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_d[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function' */
    /* Because the Update function of multirate block
       <S1600>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S1600>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 1;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector3[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_d[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_d[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_d[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_l) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S4>/SrcDownMic' */
void Model_Target_SrcDownMic_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function' */

    /* S-Function Block: <S1600>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/* System initialize for atomic system: '<S4>/SrcUp' */
void Model_Target_SrcUp_Init(void)
{
    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S1601>/S-Function' incorporates:
     *  Constant: '<S1601>/advance'
     *  Constant: '<S1601>/coeffs'
     */

    // S-Function Block: <S1601>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 24;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(Model_Target_ConstP.coeffs_Value);
        pFilterEnd = pFilter + (143);
        pFilterCurr = pFilter;
        pAdvance = (int*)(Model_Target_ConstP.advance_Value);
        pAdvanceEnd = pAdvance + (13);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (12) / (13)) + (11);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer<2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer_e[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd_k
            [0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite_l[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead_d[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)
                &Model_Target_DW.SFunction_InputBuffer_o[0] + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer>>1) - 1;
        }

        // Save pointers
        Model_Target_DW.SFunction_PWORK_f[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK_f[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK_f[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK_f[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK_f[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK_f[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK_f[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK_f[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK_f[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK_f[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK_b = nBuffer;
    }
}

/* Output and update for atomic system: '<S4>/SrcUp' */
void Model_Target_SrcUpTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S1601>/S-Function' incorporates:
     *  Constant: '<S1601>/advance'
     *  Constant: '<S1601>/coeffs'
     */
    /* Because the Outputs function of multirate block
       <S1601>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S1601>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 24;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 1)
        {
            float *out = (float*)(&Model_Target_B.MatrixConcatenate[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_f[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_f[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_f[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_f[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_f[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_f[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_f[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_f[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_f[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_f[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_b;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_b * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_b;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_b;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_b *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_b *
                                       sizeof(float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_b;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_b * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_b;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_b * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_f[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_f[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S1601>/S-Function' incorporates:
     *  Constant: '<S1601>/advance'
     *  Constant: '<S1601>/coeffs'
     */
    /* Because the Update function of multirate block
       <S1601>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S1601>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 24;
        int nFrameIn = 32;
        if (tid == 2)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_MedusaPostHoligram_B.Merge[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_f[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_f[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_f[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_b) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S4>/SrcUp' */
void Model_Target_SrcUpTID2(void)
{
    int_T tid = 2;

    /* S-Function (SampleRateConverter_sfunc): '<S1601>/S-Function' incorporates:
     *  Constant: '<S1601>/advance'
     *  Constant: '<S1601>/coeffs'
     */
    /* Because the Outputs function of multirate block
       <S1601>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S1601>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 24;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 1)
        {
            float *out = (float*)(&Model_Target_B.MatrixConcatenate[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_f[0]);
            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_f[1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_f[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK_f[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK_f[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK_f[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK_f[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK_f[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK_f[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK_f[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_b;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_b * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK_b;
                            pIn2 -= Model_Target_DW.SFunction_IWORK_b;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK_b *
                                       sizeof(float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK_b *
                                       sizeof(float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (11); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK_b;
                        }
                    }

#else

                    for (samp = 0; samp < (11); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK_b * sizeof
                                      (float));
                    }

                    pFilterCurr += (11);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK_b;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK_b * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK_f[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK_f[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S1601>/S-Function' incorporates:
     *  Constant: '<S1601>/advance'
     *  Constant: '<S1601>/coeffs'
     */
    /* Because the Update function of multirate block
       <S1601>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S1601>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 24;
        int nFrameIn = 32;
        if (tid == 2)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_MedusaPostHoligram_B.Merge[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK_f[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)
                (Model_Target_DW.SFunction_PWORK_f[1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK_f[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch],
                    (Model_Target_DW.SFunction_IWORK_b) * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S4>/SrcUp' */
void Model_Target_SrcUp_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S1601>/S-Function' incorporates:
     *  Constant: '<S1601>/advance'
     *  Constant: '<S1601>/coeffs'
     */

    /* S-Function Block: <S1601>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/* Output and update for function-call system: '<S1624>/init' */
void InitTrigger_Model_771_172_156(void)
{
    /* MATLAB Function: '<S1623>/PoolIirInit' */
    /* MATLAB Function: '<S1623>/PoolIirInit' incorporates:
     *  Gain: '<S1617>/Gain'
     *  S-Function (TOP_MEX): '<S1620>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1629>:1' */
    /* '<S1629>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1626>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1626>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1626>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1626>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1626>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1626>:1:28' else */
    /* '<S1626>:1:29' switch(VariantStr) */
    /* '<S1626>:1:30' case{"Hexagon"} */
    /* '<S1626>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1626>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1626>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearFsDrEq33283states[0], &NearFsDrEq17368PoolIirAudioIn[0],
                 8U, 7U, &(Model_Target_Near_p0_b0.Dr_PooliirPooliirNumStages[0]),
                 &NearFsDrEq5274PoolIirCoeffs[0], &NearFsDrEq33283states[0],
                 1417U, 1U, 400U);

    /* '<S1626>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1632>/init' */
void InitTrigger_Model_771_172_192(void)
{
    /* MATLAB Function: '<S1631>/SignalBreakFcn' */
    /* MATLAB Function: '<S1631>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1620>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1634>:1' */
    /* '<S1634>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1633>:1' */
    /* '<S1633>:1:3' y = u; */
    memcpy(&NearFsDrEq5274PoolIirCoeffs[0],
           &(Model_Target_Near_p0_b0.Dr_PooliirpooliirCoeffs[0]), 407U * sizeof
           (real32_T));
}

/* Output and update for function-call system: '<S1643>/init' */
void InitTrigger_Model_889_172_156(void)
{
    /* MATLAB Function: '<S1642>/PoolIirInit' */
    /* MATLAB Function: '<S1642>/PoolIirInit' incorporates:
     *  Gain: '<S1636>/Gain'
     *  S-Function (TOP_MEX): '<S1639>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1648>:1' */
    /* '<S1648>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1645>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1645>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1645>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1645>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1645>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1645>:1:28' else */
    /* '<S1645>:1:29' switch(VariantStr) */
    /* '<S1645>:1:30' case{"Hexagon"} */
    /* '<S1645>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1645>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1645>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearHrEqDr16726states[0], &NearHrEqDr5320PoolIirAudioIn[0], 8U,
                 4U,
                 &(Model_Target_Near_p0_b0.Dr_PoolIirTunablePooliirNumStages[0]),
                 &NearHrEqDr45488PoolIirCoeffs[0], &NearHrEqDr16726states[0],
                 817U, 1U, 400U);

    /* '<S1645>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1651>/init' */
void InitTrigger_Model_889_172_192(void)
{
    /* MATLAB Function: '<S1650>/SignalBreakFcn' */
    /* MATLAB Function: '<S1650>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1639>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1653>:1' */
    /* '<S1653>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1652>:1' */
    /* '<S1652>:1:3' y = u; */
    memcpy(&NearHrEqDr45488PoolIirCoeffs[0],
           &(Model_Target_Near_p0_b0.Dr_PoolIirTunablepooliirCoeffs[0]), 404U *
           sizeof(real32_T));
}

/*
 * Output and update for atomic system:
 *    '<S1654>/MATLAB Function'
 *    '<S1712>/MATLAB Function'
 */
void Model_Target_MATLABFunction_m(const int32_T rtu_tuneTopMap[18], const
    int32_T rtu_rtcMap[18], B_MATLABFunction_Model_Target_h_T *localB)
{
    int32_T ind;

    /*  tuneTopMap is provided via a tune variable. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages. */
    /* MATLAB Function 'NEAR/Near1p1/DrProc/RouterDr/InnerLink/MATLAB Function': '<S1655>:1' */
    /* '<S1655>:1:7' Numiters=size(rtcMap,1); */
    /* '<S1655>:1:8' routerMapOut = int32(tuneTopMap); */
    /* '<S1655>:1:9' for ind=1:Numiters */
    for (ind = 0; ind < 18; ind++)
    {
        localB->routerMapOut[ind] = rtu_tuneTopMap[ind];

        /* '<S1655>:1:10' if (rtcMap(ind)) */
        if (rtu_rtcMap[ind] != 0)
        {
            /* '<S1655>:1:11' routerMapOut(ind) = rtcMap(ind); */
            localB->routerMapOut[ind] = rtu_rtcMap[ind];
        }
    }
}

/* Output and update for function-call system: '<S1682>/init' */
void InitTrigger_Model_1040_172_156(void)
{
    /* MATLAB Function: '<S1681>/PoolIirInit' */
    /* MATLAB Function: '<S1681>/PoolIirInit' incorporates:
     *  Gain: '<S1675>/Gain'
     *  S-Function (TOP_MEX): '<S1678>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1687>:1' */
    /* '<S1687>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1684>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1684>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1684>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1684>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1684>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1684>:1:28' else */
    /* '<S1684>:1:29' switch(VariantStr) */
    /* '<S1684>:1:30' case{"Hexagon"} */
    /* '<S1684>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1684>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1684>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearFsFrEq11505states[0], &NearFsFrEq50753PoolIirAudioIn[0],
                 32U, 5U, &(Model_Target_Near_p0_b0.Fr_PooliirPooliirNumStages[0]),
                 &NearFsFrEq5572PoolIirCoeffs[0], &NearFsFrEq11505states[0],
                 1017U, 1U, 400U);

    /* '<S1684>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1690>/init' */
void InitTrigger_Model_1040_172_192(void)
{
    /* MATLAB Function: '<S1689>/SignalBreakFcn' */
    /* MATLAB Function: '<S1689>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1678>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1692>:1' */
    /* '<S1692>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1691>:1' */
    /* '<S1691>:1:3' y = u; */
    memcpy(&NearFsFrEq5572PoolIirCoeffs[0],
           &(Model_Target_Near_p0_b0.Fr_PooliirpooliirCoeffs[0]), 405U * sizeof
           (real32_T));
}

/* Output and update for function-call system: '<S1701>/init' */
void InitTrigger_Model_1078_172_156(void)
{
    /* MATLAB Function: '<S1700>/PoolIirInit' */
    /* MATLAB Function: '<S1700>/PoolIirInit' incorporates:
     *  Gain: '<S1694>/Gain'
     *  S-Function (TOP_MEX): '<S1697>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1706>:1' */
    /* '<S1706>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1703>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1703>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1703>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1703>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1703>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1703>:1:28' else */
    /* '<S1703>:1:29' switch(VariantStr) */
    /* '<S1703>:1:30' case{"Hexagon"} */
    /* '<S1703>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1703>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1703>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearHrEqFr30301states[0], &NearHrEqFr38294PoolIirAudioIn[0],
                 32U, 4U,
                 &(Model_Target_Near_p0_b0.Fr_PoolIirTunablePooliirNumStages[0]),
                 &NearHrEqFr62159PoolIirCoeffs[0], &NearHrEqFr30301states[0],
                 817U, 1U, 400U);

    /* '<S1703>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1709>/init' */
void InitTrigger_Model_1078_172_192(void)
{
    /* MATLAB Function: '<S1708>/SignalBreakFcn' */
    /* MATLAB Function: '<S1708>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1697>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1711>:1' */
    /* '<S1711>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1710>:1' */
    /* '<S1710>:1:3' y = u; */
    memcpy(&NearHrEqFr62159PoolIirCoeffs[0],
           &(Model_Target_Near_p0_b0.Fr_PoolIirTunablepooliirCoeffs[0]), 404U *
           sizeof(real32_T));
}

/*
 * System initialize for atomic system:
 *    '<S1608>/MATLAB Function'
 *    '<S1608>/MATLAB Function1'
 *    '<S1608>/MATLAB Function2'
 *    '<S1608>/MATLAB Function3'
 *    '<S1608>/MATLAB Function4'
 *    '<S1608>/MATLAB Function5'
 *    '<S1608>/MATLAB Function6'
 *    '<S1608>/MATLAB Function7'
 */
void Model_Target_MATLABFunction_m_Init(DW_MATLABFunction_Model_Target_i_T
    *localDW)
{
    /* '<S1726>:1:7' , */
    /* '<S1726>:1:7' lastG = cast(0, class(tgain)); */
    /* '<S1726>:1:10' , */
    /* '<S1726>:1:10' upCoeff = cast(0, class(tgain)); */
    /* '<S1726>:1:12' , */
    /* '<S1726>:1:12' upCoeffN = cast(0, class(tgain)); */
    /* '<S1726>:1:14' , */
    /* '<S1726>:1:14' downCoeff = cast(0, class(tgain)); */
    /* '<S1726>:1:16' , */
    /* '<S1726>:1:16' downCoeffN = cast(0, class(tgain)); */
    /* '<S1726>:1:22' , */
    /* '<S1726>:1:22' lpfCoeff = cast(exp(-1 / FRAME_SIZE), class(tgain)); */
    localDW->lpfCoeff = 0.969233215F;
}

/*
 * Output and update for atomic system:
 *    '<S1608>/MATLAB Function'
 *    '<S1608>/MATLAB Function1'
 *    '<S1608>/MATLAB Function2'
 *    '<S1608>/MATLAB Function3'
 *    '<S1608>/MATLAB Function4'
 *    '<S1608>/MATLAB Function5'
 *    '<S1608>/MATLAB Function6'
 *    '<S1608>/MATLAB Function7'
 */
void Model_Target_MATLABFunction_j(real32_T rtu_tgain, real32_T
    rtu_ramp_db_per_samp, real_T rtu_minGain, real32_T *rty_gval,
    DW_MATLABFunction_Model_Target_i_T *localDW)
{
    int32_T i;
    real32_T gVec[32];
    real32_T gdiff;
    real32_T gp;
    real32_T nextDownCoeff;
    real32_T nextUpCoeff;
    boolean_T chtgain;

    /*  FRAME_SIZE = 32; */
    /*  Ramp coefficients */
    /* MATLAB Function 'NEAR/Near1p1/LocRamper/MATLAB Function': '<S1726>:1' */
    /* '<S1726>:1:5' if (isempty(lastTGain)) */
    if (!localDW->lastTGain_not_empty)
    {
        /* '<S1726>:1:5' , */
        /* '<S1726>:1:5' lastTGain = cast(tgain + 1, class(tgain)); */
        localDW->lastTGain = rtu_tgain + 1.0F;
        localDW->lastTGain_not_empty = true;
    }

    /* '<S1726>:1:7' if (isempty(lastG)) */
    /*  Ramp coefficients */
    /* '<S1726>:1:10' if (isempty(upCoeff)) */
    /* '<S1726>:1:12' if (isempty(upCoeffN)) */
    /* '<S1726>:1:14' if (isempty(downCoeff)) */
    /* '<S1726>:1:16' if (isempty(downCoeffN)) */
    /* '<S1726>:1:22' if (isempty(lpfCoeff)) */
    /*  Update the next set of ramp coefficients to use */
    /* '<S1726>:1:24' nextUpCoeff = cast(10 ^ abs(ramp_db_per_samp / 20), class(tgain)); */
    nextUpCoeff = qhmath_pow_f(10.0F, qhmath_abs_f(qhmath_div_f
        (rtu_ramp_db_per_samp, 20.0F)));

    /* '<S1726>:1:25' nextUpCoeffN = cast(nextUpCoeff ^ FRAME_SIZE, class(tgain)); */
    /* '<S1726>:1:26' nextDownCoeff = cast(10 ^ (-abs(ramp_db_per_samp) / 20), class(tgain)); */
    nextDownCoeff = qhmath_pow_f(10.0F, qhmath_div_f(-qhmath_abs_f
        (rtu_ramp_db_per_samp), 20.0F));

    /* '<S1726>:1:27' nextDownCoeffN = cast(nextDownCoeff ^ FRAME_SIZE, class(tgain)); */
    /*  Switch to the next set of ramp coefficients if the target gain changed */
    /* '<S1726>:1:29' chtgain = (tgain ~= lastTGain); */
    chtgain = (rtu_tgain != localDW->lastTGain);

    /* '<S1726>:1:30' lastTGain = tgain; */
    localDW->lastTGain = rtu_tgain;

    /* '<S1726>:1:31' if (chtgain) */
    if (chtgain)
    {
        /* '<S1726>:1:32' upCoeff = nextUpCoeff; */
        localDW->upCoeff = nextUpCoeff;

        /* '<S1726>:1:33' upCoeffN = nextUpCoeffN; */
        localDW->upCoeffN = qhmath_pow_f(nextUpCoeff, 32.0F);

        /* '<S1726>:1:34' downCoeff = nextDownCoeff; */
        localDW->downCoeff = nextDownCoeff;

        /* '<S1726>:1:35' downCoeffN = nextDownCoeffN; */
        localDW->downCoeffN = qhmath_pow_f(nextDownCoeff, 32.0F);
    }

    /*  Initialize output */
    /* '<S1726>:1:38' gp = lastG; */
    gp = localDW->lastG;

    /* '<S1726>:1:39' gdiff = tgain - gp; */
    gdiff = rtu_tgain - localDW->lastG;

    /*  By default, use the lpf filter */
    /* '<S1726>:1:41' a = lpfCoeff; */
    nextUpCoeff = localDW->lpfCoeff;

    /* '<S1726>:1:42' b0 = 1-a; */
    nextDownCoeff = 1.0F - localDW->lpfCoeff;

    /* '<S1726>:1:44' if (abs(gdiff) < minGain) */
    if (qhmath_abs_f(gdiff) < rtu_minGain)
    {
        /*  Snap to target gain if it's close enough */
        /* '<S1726>:1:46' gVec = tgain * ones(FRAME_SIZE, 1, class(tgain)); */
        for (i = 0; i < 32; i++)
        {
            gVec[i] = rtu_tgain;
        }
    }
    else
    {
        /* '<S1726>:1:47' else */
        /* '<S1726>:1:48' if (gdiff > 0) */
        if (gdiff > 0.0F)
        {
            /*  previous gain cannot be zero for exponential ramp */
            /* '<S1726>:1:50' temp = max(gp, minGain); */
            gdiff = fmaxf(localDW->lastG, (real32_T)rtu_minGain);

            /* '<S1726>:1:51' if (temp * upCoeffN < tgain) */
            if (gdiff * localDW->upCoeffN < rtu_tgain)
            {
                /*  Ramp not done, so do zero-input exponential ramp */
                /* '<S1726>:1:53' a = upCoeff; */
                nextUpCoeff = localDW->upCoeff;

                /* '<S1726>:1:54' b0 = cast(0, class(tgain)); */
                nextDownCoeff = 0.0F;

                /* '<S1726>:1:55' gp = temp; */
                gp = gdiff;
            }

            /* '<S1726>:1:57' else */
            /* '<S1726>:1:58' if (gp * downCoeffN > tgain) */
        }
        else if (localDW->lastG * localDW->downCoeffN > rtu_tgain)
        {
            /*  Ramp not done, so do zero-input exponential ramp */
            /* '<S1726>:1:60' a = downCoeff; */
            nextUpCoeff = localDW->downCoeff;

            /* '<S1726>:1:61' b0 = cast(0, class(tgain)); */
            nextDownCoeff = 0.0F;
        }

        /*  Calculate gain */
        /* '<S1726>:1:65' zi = a * gp; */
        gp *= nextUpCoeff;

        /* '<S1726>:1:66' gVec = zeros(FRAME_SIZE, 1, class(tgain)); */
        /* '<S1726>:1:67' for samp = 1:FRAME_SIZE */
        for (i = 0; i < 32; i++)
        {
            /* '<S1726>:1:68' g = b0 * tgain + zi; */
            gdiff = nextDownCoeff * rtu_tgain + gp;

            /* '<S1726>:1:69' zi = a * g; */
            gp = nextUpCoeff * gdiff;

            /* '<S1726>:1:70' gVec(samp) = g; */
            gVec[i] = gdiff;
        }
    }

    /* '<S1726>:1:73' lastG = gVec(end); */
    localDW->lastG = gVec[31];

    /* '<S1726>:1:74' gval = lastG; */
    *rty_gval = localDW->lastG;
}

/* Output and update for function-call system: '<S1771>/init' */
void InitTrigger_Model_1221_143_65(void)
{
    /* MATLAB Function: '<S1768>/FirEvenInit' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1774>:1' */
    /* '<S1774>:1:3' init(); */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenInit': '<S1769>:1' */
    /* '<S1769>:1:4' [FilterLength, NumFilters] = size(FlippedCoefficients); */
    /* '<S1769>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Simulation  */
    /* '<S1769>:1:10' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1769>:1:12' else */
    /* '<S1769>:1:13' y = fireven_hexagon_init(uint32(FrameSize), uint32(NumChannels), uint32(NumFilters), uint32(FilterLength), single(FlippedCoefficients), uint32(CodeWorkMemory), uint32(MaxNumOfThreds)); */
    fireven_init(&NearBandSplit22278CodeWorkMemory[0], 32U, 2U, 1U, 22U,
                 &NearBandSplit44375FirEvenCoeffs[0],
                 &NearBandSplit22278CodeWorkMemory[0], 1U);

    /*  NOTE: The CRL mechanism requires an output for the function call, */
    /*  and appears to be optimized out if that return value isn't used.  */
    /*  This is a dummy operation to make sure CRL ends up in generated code */
    /* '<S1769>:1:17' CodeWorkMemory(1) = y; */
}

/* Output and update for function-call system: '<S1772>/init' */
void InitTrigger_Model_1221_143_84(void)
{
    /* MATLAB Function: '<S1768>/SignalBreak' */
    /* MATLAB Function: '<S1768>/SignalBreak' incorporates:
     *  Constant: '<S1763>/Image Rejection Filter Coeffs'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1775>:1' */
    /* '<S1775>:1:3' init(); */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/SignalBreak': '<S1773>:1' */
    /* '<S1773>:1:3' y = u; */
    memcpy(&NearBandSplit44375FirEvenCoeffs[0],
           &Model_Target_ConstP.ImageRejectionFilterCoeffs_Value_j[0], 22U *
           sizeof(real32_T));
}

/* Output and update for function-call system: '<S1803>/init' */
void InitTrigger_Model_1259_172_156(void)
{
    /* MATLAB Function: '<S1802>/PoolIirInit' */
    /* MATLAB Function: '<S1802>/PoolIirInit' incorporates:
     *  Gain: '<S1796>/Gain'
     *  S-Function (TOP_MEX): '<S1799>/TOP'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1808>:1' */
    /* '<S1808>:1:3' init(); */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:                  input channels [frame size x number of inputs] */
    /*    NumStages:          array of filter lengths [NumChannels x 1] */
    /*    CoeffsTarget:       coefficient sets [total filter lengths x 1] */
    /*  */
    /*  Global parameters: */
    /*    states:             working memory set up during roommode reset/init CRL */
    /*                        function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirInit': '<S1805>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1805>:1:15' [FrameSize, NumChannels] = size(x); */
    /*  Initialize variables */
    /*  Get the work memory size */
    /* '<S1805>:1:21' StatesSize = numel(states); */
    /*  Output */
    /* '<S1805>:1:24' VariantStr = char(VariantUint8); */
    /* '<S1805>:1:26' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1805>:1:28' else */
    /* '<S1805>:1:29' switch(VariantStr) */
    /* '<S1805>:1:30' case{"Hexagon"} */
    /* '<S1805>:1:31' NumCoeffPerSosStage = 4; */
    /* '<S1805>:1:32' y = pooliir_hexagon_init(single(x), uint32(FrameSize), uint32(NumChannels), uint32(NumStages), single(CoeffsTarget), ... */
    /* '<S1805>:1:33'                                      single(states), uint32(StatesSize),uint32(MaxNumOfThreads), uint32(MaxNumSosStages*NumCoeffPerSosStage)); */
    pooliir_init(&NearPreEmphasisShelfFilter28252states[0],
                 &NearPreEmphasisShelfFilter15569PoolIirAudioIn[0], 32U, 2U,
                 &(Model_Target_Near_p0_b0.LevelDetectPreEmphasisShelfFilterPooliirNumStages
                   [0]), &NearPreEmphasisShelfFilter26026PoolIirCoeffs[0],
                 &NearPreEmphasisShelfFilter28252states[0], 25U, 1U, 8U);

    /* '<S1805>:1:34' states(1) = y; */
}

/* Output and update for function-call system: '<S1811>/init' */
void InitTrigger_Model_1259_172_192(void)
{
    int32_T i;

    /* MATLAB Function: '<S1810>/SignalBreakFcn' */
    /* MATLAB Function: '<S1810>/SignalBreakFcn' incorporates:
     *  S-Function (TOP_MEX): '<S1799>/TOP1'
     */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'ITC/init': '<S1813>:1' */
    /* '<S1813>:1:3' init(); */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/SignalBreak/SignalBreak/SignalBreakFcn': '<S1812>:1' */
    /* '<S1812>:1:3' y = u; */
    for (i = 0; i < 10; i++)
    {
        NearPreEmphasisShelfFilter26026PoolIirCoeffs[i] =
            Model_Target_Near_p0_b0.LevelDetectPreEmphasisShelfFilterpooliirCoeffs
            [i];
    }

    /* End of MATLAB Function: '<S1810>/SignalBreakFcn' */
}

/*
 * System initialize for atomic system:
 *    '<S1814>/InnerLink'
 *    '<S1822>/InnerLink'
 *    '<S1830>/InnerLink'
 *    '<S1838>/InnerLink'
 */
void Model_Target_InnerLink_g_Init(DW_InnerLink_Model_Target_o_T *localDW)
{
    localDW->holdFlag = 1.0;
}

/*
 * Output and update for atomic system:
 *    '<S1814>/InnerLink'
 *    '<S1822>/InnerLink'
 *    '<S1830>/InnerLink'
 *    '<S1838>/InnerLink'
 */
void Model_Target_InnerLink_n(real32_T rtu_rmsInput, real32_T rtu_peakInput,
    real32_T rtu_slowDecayDbPerSample, real32_T rtu_holdMarginDb, real32_T
    rtu_holdTimeSamples, real32_T rtu_fastDecayDbPerSample, real32_T
    rtu_minVolumeDb, real32_T rtu_maxVolumeDb, real_T rtu_AnnTrigger, real32_T
    rtu_mode1, DW_InnerLink_Model_Target_o_T *localDW)
{
    real32_T input1;
    input1 = rtu_rmsInput;

    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'LevelDetector': '<S1821>:1' */
    /*  States */
    /* '<S1821>:1:11' if (isempty(holdFlag)) */
    if (!localDW->holdFlag_not_empty)
    {
        /* '<S1821>:1:12' holdFlag = 1; */
        localDW->holdFlag_not_empty = true;

        /* '<S1821>:1:13' holdState = 0; */
        /* '<S1821>:1:14' envelope1 = -abs(minVolumeDb); */
        localDW->envelope1 = -qhmath_abs_f(rtu_minVolumeDb);
    }

    /*  By default we use the RMS input */
    /* '<S1821>:1:18' input1 = rmsInput; */
    /* '<S1821>:1:19' level = single(0.0); */
    /* '<S1821>:1:21' if mode1 >= 0.0 */
    if (rtu_mode1 >= 0.0F)
    {
        real32_T delta;

        /*  Choose input1 based on mode1 */
        /* '<S1821>:1:23' if (mode1 > 0.0) */
        if (rtu_mode1 > 0.0F)
        {
            /* '<S1821>:1:24' input1 = peakInput; */
            input1 = rtu_peakInput;
        }

        /* '<S1821>:1:26' delta = single( envelope1 - input1 ); */
        delta = localDW->envelope1 - input1;

        /* '<S1821>:1:27' if ( delta <= single(0) ) */
        if (delta <= 0.0F)
        {
            /*  Attack phase */
            /* '<S1821>:1:29' envelope1 = input1; */
            localDW->envelope1 = input1;

            /* '<S1821>:1:30' holdState = 0; */
            localDW->holdState = 0.0;

            /* '<S1821>:1:31' holdFlag = 1; */
            localDW->holdFlag = 1.0;
        }
        else
        {
            /* '<S1821>:1:32' else */
            /*  Slow Decay phase */
            /* '<S1821>:1:34' coef = slowDecayDbPerSample; */
            input1 = rtu_slowDecayDbPerSample;

            /*  Hold phase */
            /* '<S1821>:1:37' if ( delta >= holdMarginDb ) */
            if (delta >= rtu_holdMarginDb)
            {
                /* '<S1821>:1:38' holdState = holdState + 1; */
                localDW->holdState++;

                /* '<S1821>:1:39' if ( holdState > holdTimeSamples ) */
                if (localDW->holdState > rtu_holdTimeSamples)
                {
                    /* '<S1821>:1:40' holdFlag = 0; */
                    localDW->holdFlag = 0.0;
                }
            }
            else
            {
                /* '<S1821>:1:42' else */
                /* '<S1821>:1:43' holdState = 0; */
                localDW->holdState = 0.0;
            }

            /*  Fast decay phase */
            /* '<S1821>:1:47' if holdFlag == 0 */
            if (localDW->holdFlag == 0.0)
            {
                /* '<S1821>:1:48' coef = fastDecayDbPerSample; */
                input1 = rtu_fastDecayDbPerSample;
            }

            /*  Super fast decay phase */
            /* '<S1821>:1:52' if ( AnnTrigger > AnnTriggerThreshold ) */
            if (rtu_AnnTrigger > 0.5)
            {
                /* '<S1821>:1:53' coef = SuperFastDecayMultiplier * fastDecayDbPerSample; */
                input1 = Model_Target_SuperFastDecayMultiplier_m *
                    rtu_fastDecayDbPerSample;
            }

            /*  Update the envelope1 */
            /* '<S1821>:1:57' envelope1 = envelope1 + coef; */
            localDW->envelope1 += input1;
        }

        /*  Boundary Check */
        /* '<S1821>:1:60' envelope1 = max(minVolumeDb, envelope1); */
        localDW->envelope1 = fmaxf(rtu_minVolumeDb, localDW->envelope1);

        /* '<S1821>:1:61' envelope1 = min(maxVolumeDb, envelope1); */
        localDW->envelope1 = fminf(rtu_maxVolumeDb, localDW->envelope1);

        /*  dBSPL Conversion */
        /* '<S1821>:1:64' level = max(0, envelope1 + predictionDbspl + volumeDb); */
    }
}

/*
 * Output and update for function-call system:
 *    '<S1852>/MATLAB Function'
 *    '<S1932>/MATLAB Function'
 *    '<S2012>/MATLAB Function'
 *    '<S2092>/MATLAB Function'
 */
void Model_Target_MATLABFunction_m0(uint32_T rtu_vncEnableIn,
    B_MATLABFunction_Model_Target_k_T *localB)
{
    localB->vncEnableOut = rtu_vncEnableIn;

    /*  */
    /* Trivial translation */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Ann1NonEntGainCalc/MATLAB Function': '<S1856>:1' */
    /* '<S1856>:1:5' vncEnableOut = vncEnableIn; */
}

/* Output and update for function-call system: '<S1857>/REQ' */
void HandleReqNearAnn1Ann1NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S1852>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1873>:1' */
    /* '<S1873>:1:3' go(); */
    Model_Target_MATLABFunction_m0
        (Model_TargetNearAnn1Ann1NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_m0);
}

/* Output and update for function-call system: '<S1886>/REQ' */
void HandleReqNearAnn1Ann1MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S1884>/calculate_ramp_rate' */
    /* MATLAB Function: '<S1884>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1893>:1' */
    /* '<S1893>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near_p0_b0.Ann1Ann1MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_hu);

    /* MATLAB Function: '<S1885>/get_ramp_coeffs' */
    /* MATLAB Function: '<S1885>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S1885>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S1885>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_hu.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S1898>:1' */
    /* '<S1898>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn1MuteTargetLinearGain = 1.0F;

    /* '<S1898>:1:7' if muteSwitch */
    if (Model_TargetNearAnn1Ann1MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S1898>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn1MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S1898>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_hu.rampRate != 0.0F)
    {
        /* '<S1898>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S1898>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S1898>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1898>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn1MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn1MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_hu.rampRate) *
            1000.0F;
    }

    /* '<S1898>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S1898>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S1898>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn1MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S1898>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1898>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_b = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn1MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn1MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn1MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_b = qhmath_exp_f(Model_Target_B.ramping_coeff_b);

    /* End of MATLAB Function: '<S1885>/get_ramp_coeffs' */
}

/*
 * Output and update for iterator system:
 *    '<S1900>/For Each Subsystem'
 *    '<S1980>/For Each Subsystem'
 *    '<S2060>/For Each Subsystem'
 *    '<S2140>/For Each Subsystem'
 */
void Model_Target_ForEachSubsystem(int32_T NumIters, const real32_T rtu_In1[32],
    const real32_T rtu_In2[32], real32_T rty_Out1[32])
{
    /* local scratch DWork variables */
    int32_T ForEach_itr;

    /* Outputs for Iterator SubSystem: '<S1900>/For Each Subsystem' incorporates:
     *  ForEach: '<S1907>/For Each'
     */
    for (ForEach_itr = 0; ForEach_itr < NumIters; ForEach_itr++)
    {
        /* ForEachSliceAssignment generated from: '<S1907>/Out1' incorporates:
         *  ForEachSliceSelector generated from: '<S1907>/In1'
         *  ForEachSliceSelector generated from: '<S1907>/In2'
         *  Product: '<S1907>/Multiply'
         */
        rty_Out1[ForEach_itr] = rtu_In1[ForEach_itr] * rtu_In2[ForEach_itr];
    }

    /* End of Outputs for SubSystem: '<S1900>/For Each Subsystem' */
}

/*
 * Output and update for function-call system:
 *    '<S1855>/rtcscalartovector'
 *    '<S1935>/rtcscalartovector'
 *    '<S2015>/rtcscalartovector'
 *    '<S2095>/rtcscalartovector'
 */
void Model_Target_rtcscalartovector(uint32_T rtu_Inp,
    B_rtcscalartovector_Model_Target_T *localB)
{
    /*  */
    /*  Convert input vector into a matrix */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/rtcscalartovector': '<S1915>:1' */
    /* '<S1915>:1:6' Inpsize=size(Inp,1); */
    /* '<S1915>:1:8' Outp=(Inp').*uint32(ones(1,Inpsize)); */
    localB->Outp = rtu_Inp;
}

/*
 * Output and update for function-call system:
 *    '<S1855>/calculate_vol_gain'
 *    '<S1935>/calculate_vol_gain'
 *    '<S2015>/calculate_vol_gain'
 *    '<S2095>/calculate_vol_gain'
 */
void Model_Target_calculate_vol_gain(uint32_T rtu_idx, const uint32_T
    rtu_volTableIdx[16], const real32_T rtu_volTabledB[16],
    B_calculate_vol_gain_Model_Target_T *localB)
{
    uint32_T idx;
    uint8_T j;
    boolean_T exitg1;
    idx = rtu_idx;

    /*  Calculate a gain_value from VolumeTable, table index, and index table */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/calculate_vol_gain': '<S1913>:1' */
    /* '<S1913>:1:5' iter=size(idx,2); */
    /* gain_value = single(0.0); */
    /* '<S1913>:1:7' gain_value=single(zeros(1,iter)); */
    localB->gain_value = 0.0F;

    /* '<S1913>:1:8' percent =zeros(1,iter); */
    /* '<S1913>:1:9' lastIdx =zeros(1,iter); */
    /* '<S1913>:1:11' for chind=1:iter */
    /* '<S1913>:1:12' j = uint8(1); */
    j = 1U;

    /*  workaround to type problem */
    /* '<S1913>:1:14' idx(chind) = cast(idx(chind), class(volTableIdx(end))); */
    /*   bounds checking for vol - clip to max idx */
    /* '<S1913>:1:17' if (idx(chind) > volTableIdx(end)) */
    if (rtu_idx > rtu_volTableIdx[15])
    {
        /* '<S1913>:1:18' idx(chind) = volTableIdx(end); */
        idx = rtu_volTableIdx[15];
    }

    /*  search through volume table to find index closest to vol */
    /* '<S1913>:1:22' while (j <= numel(volTableIdx)) */
    exitg1 = false;
    while ((!exitg1) && (j <= 16))
    {
        uint32_T tmp_0;

        /* '<S1913>:1:23' if (idx(chind) <= volTableIdx(j)) */
        tmp_0 = rtu_volTableIdx[j - 1];
        if (idx <= tmp_0)
        {
            /* '<S1913>:1:24' if (j <= 1) */
            if (j <= 1)
            {
                real_T a;

                /*  first indexed value is linearly interpolated to zero */
                /* '<S1913>:1:25' if (volTableIdx(j)) */
                if (rtu_volTableIdx[0] != 0U)
                {
                    /* '<S1913>:1:26' percent(chind) = single(idx(chind)) / single(volTableIdx(j)); */
                    a = qhmath_div_f((real32_T)idx, (real32_T)rtu_volTableIdx[0]);
                }
                else
                {
                    /* '<S1913>:1:27' else */
                    /* '<S1913>:1:28' percent(chind) = single(1); */
                    a = 1.0;
                }

                /* '<S1913>:1:30' gain_value(chind) = percent(chind) * 10 ^ (volTabledB(j) / 20); */
                localB->gain_value = (real32_T)a * qhmath_pow_f(10.0F,
                    qhmath_div_f(rtu_volTabledB[0], 20.0F));
            }
            else
            {
                real_T a;
                real_T tmp;
                real32_T gain_value_tmp;

                /* '<S1913>:1:31' else */
                /*  other values are interpolated in db space */
                /* '<S1913>:1:32' lastIdx(chind) = volTableIdx(j-1); */
                /* '<S1913>:1:33' percent(chind) = single(idx(chind) - lastIdx(chind)) / single(volTableIdx(j) - lastIdx(chind)); */
                /* '<S1913>:1:34' gain_value(chind) = 10 ^ (((percent(chind) * (volTabledB(j) - volTabledB(j-1))) + volTabledB(j-1)) / 20); */
                a = rtu_volTableIdx[j - 2];
                tmp = (real_T)idx - a;
                a = (real_T)tmp_0 - a;
                if (tmp >= 0.0)
                {
                    tmp_0 = (uint32_T)tmp;
                }
                else
                {
                    tmp_0 = 0U;
                }

                if (a >= 0.0)
                {
                    idx = (uint32_T)a;
                }
                else
                {
                    idx = 0U;
                }

                gain_value_tmp = rtu_volTabledB[j - 2];
                localB->gain_value = qhmath_pow_f(10.0F, qhmath_div_f
                    ((rtu_volTabledB[j - 1] - gain_value_tmp) * qhmath_div_f
                     ((real32_T)tmp_0, (real32_T)idx) + gain_value_tmp, 20.0F));
            }

            exitg1 = true;
        }
        else
        {
            /* '<S1913>:1:37' else */
            /* '<S1913>:1:38' j = j + 1; */
            j++;
        }
    }
}

/*
 * Output and update for function-call system:
 *    '<S1855>/rtcscalartovector2'
 *    '<S1935>/rtcscalartovector2'
 *    '<S2015>/rtcscalartovector2'
 *    '<S2095>/rtcscalartovector2'
 */
void Model_Target_rtcscalartovector2(uint32_T rtu_Inp,
    B_rtcscalartovector2_Model_Target_T *localB)
{
    /*  */
    /*  Convert input vector into a matrix */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/rtcscalartovector2': '<S1916>:1' */
    /* '<S1916>:1:5' Inpsize=size(Inp,1); */
    /* '<S1916>:1:7' Outp=(Inp').*uint32(ones(1,Inpsize)); */
    localB->Outp = rtu_Inp;
}

/*
 * Output and update for function-call system:
 *    '<S1855>/rtcscalartovector3'
 *    '<S1935>/rtcscalartovector3'
 *    '<S2015>/rtcscalartovector3'
 *    '<S2095>/rtcscalartovector3'
 */
void Model_Target_rtcscalartovector3(uint32_T rtu_Inp,
    B_rtcscalartovector3_Model_Target_T *localB)
{
    /*  */
    /*  Convert input vector into a matrix */
    /*  */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/rtcscalartovector3': '<S1917>:1' */
    /* '<S1917>:1:5' Inpsize=size(Inp,1); */
    /* '<S1917>:1:7' Outp=(Inp').*uint32(ones(1,Inpsize)); */
    localB->Outp = rtu_Inp;
}

/*
 * Output and update for function-call system:
 *    '<S1855>/get_ramp_parameters'
 *    '<S1935>/get_ramp_parameters'
 *    '<S2015>/get_ramp_parameters'
 *    '<S2095>/get_ramp_parameters'
 */
void Model_Target_get_ramp_parameters(uint32_T rtu_rampTimeRTC, uint32_T
    rtu_rampRateRTC, real32_T rtu_rampTimeTune,
    B_get_ramp_parameters_Model_Target_T *localB)
{
    /*  % RTC message parameters */
    /*  Tune parameters */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/VolMuteCh1/Volume/get_ramp_parameters': '<S1914>:1' */
    /*  Ramp time and rate are provided to the block through RTC messages. However  */
    /*  in case neither of them are provided, the block will use the default ramp  */
    /*  time given in the tune variables. */
    /*  NOTE: Tune variable for ramp rate is provided as an option, but not used */
    /*  in the current version. */
    /* '<S1914>:1:10' Numiters=size(rampTimeRTC,2); */
    /* '<S1914>:1:11' ramp_ms=zeros(1,Numiters); */
    /* '<S1914>:1:12' ramp_rate=zeros(1,Numiters); */
    /* '<S1914>:1:14' ramp_ms(1:Numiters) = single(rampTimeTune); */
    localB->ramp_ms = rtu_rampTimeTune;

    /* '<S1914>:1:15' ramp_rate(1:Numiters) = single(0.0); */
    localB->ramp_rate = 0.0;

    /*  Set to rampRateTune if a default is to be set */
    /* '<S1914>:1:16' for rampind=1:Numiters */
    /* '<S1914>:1:17' if (rampTimeRTC(rampind)) */
    if (rtu_rampTimeRTC != 0U)
    {
        /* '<S1914>:1:18' ramp_ms(rampind) = single(rampTimeRTC(rampind)); */
        /* '<S1914>:1:19' ramp_ms(rampind) = min(100000, ramp_ms(rampind)); */
        /* '<S1914>:1:20' ramp_ms(rampind) = max(1, ramp_ms(rampind)); */
        localB->ramp_ms = fmin(100000.0, (real32_T)rtu_rampTimeRTC);
    }

    /* '<S1914>:1:22' if (rampRateRTC(rampind)) */
    if (rtu_rampRateRTC != 0U)
    {
        /* '<S1914>:1:23' ramp_rate(rampind) = single(rampRateRTC(rampind)); */
        /* '<S1914>:1:24' ramp_rate(rampind) = min(50000, ramp_rate(rampind)); */
        /* '<S1914>:1:25' ramp_rate(rampind) = max(5, ramp_rate(rampind)); */
        localB->ramp_rate = fmax(5.0, fmin(50000.0, (real32_T)rtu_rampRateRTC));
    }
}

/*
 * Output and update for function-call system:
 *    '<S1925>/SetDsm'
 *    '<S1925>/SetDsm1'
 */
void Model_Target_SetDsm_i1(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S1928>/Data Store Write' incorporates:
     *  Constant: '<S1928>/Constant'
     */
    Model_TargetControlDsms.NearAnn1Ann1VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S1925>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_n(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S1930>:1' */
    /* '<S1930>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S1930>:1:23' numGains = numel(target_gains_linear); */
    /* '<S1930>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S1930>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S1930>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S1930>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S1930>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S1930>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S1930>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S1930>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S1930>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S1930>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S1930>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S1930>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S1930>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S1930>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S1930>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S1930>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S1930>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S1930>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S1930>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S1930>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S1930>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S1930>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S1930>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S1908>/REQ' */
void HandleReqNearAnn1Ann1VolumeSet(void)
{
    /* MATLAB Function: '<S1855>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1921>:1' */
    /* '<S1921>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector);

    /* MATLAB Function: '<S1855>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector.Outp,
        &(Model_Target_Near_p0_b0.Ann1Ann1VolumeTable_Idx[0]),
        &(Model_Target_Near_p0_b0.Ann1Ann1VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain);

    /* MATLAB Function: '<S1855>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2);

    /* MATLAB Function: '<S1855>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn1Ann1VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3);

    /* MATLAB Function: '<S1855>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters(Model_Target_B.sf_rtcscalartovector3.Outp,
        Model_Target_B.sf_rtcscalartovector2.Outp,
        Model_Target_Near_p0_b0.Ann1Ann1VolumeRampTime,
        &Model_Target_B.sf_get_ramp_parameters);

    /* Outputs for Function Call SubSystem: '<S1925>/SetDsm' */
    Model_Target_SetDsm_i1(1U);

    /* End of Outputs for SubSystem: '<S1925>/SetDsm' */

    /* MATLAB Function: '<S1925>/rgainy ramper control' */
    /* MATLAB Function: '<S1925>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S1925>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_n
        (Model_Target_B.sf_calculate_vol_gain.gain_value,
         Model_Target_B.sf_get_ramp_parameters.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters.ramp_ms, 44307.692307692312, 32.0);

    /* Outputs for Function Call SubSystem: '<S1925>/SetDsm1' */
    Model_Target_SetDsm_i1(0U);

    /* End of Outputs for SubSystem: '<S1925>/SetDsm1' */
}

/* Output and update for atomic system: '<S1924>/rgainy process' */
void Model_Target_rgainyprocess_l(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_b_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S1927>:1' */
    /*  set the size of the output buffer */
    /* '<S1927>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S1927>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S1927>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S1927>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S1927>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S1927>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S1927>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain;

    /* '<S1927>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn1Ann1VolumeFreeze == 0U)
    {
        /* '<S1927>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S1927>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.targetGain;
        }
        else
        {
            /* '<S1927>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S1927>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.rampCoeff;

            /* '<S1927>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S1927>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S1927>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S1927>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S1927>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S1927>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S1927>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S1927>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn1Ann1VolumeRampers.currentGain = gain;

    /* '<S1927>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S1927>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S1927>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* Output and update for function-call system: '<S1937>/REQ' */
void HandleReqNearAnn2Ann2NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S1932>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1953>:1' */
    /* '<S1953>:1:3' go(); */
    Model_Target_MATLABFunction_m0
        (Model_TargetNearAnn2Ann2NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_jcg);
}

/* Output and update for function-call system: '<S1966>/REQ' */
void HandleReqNearAnn2Ann2MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S1964>/calculate_ramp_rate' */
    /* MATLAB Function: '<S1964>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S1973>:1' */
    /* '<S1973>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near_p0_b0.Ann2Ann2MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_eh);

    /* MATLAB Function: '<S1965>/get_ramp_coeffs' */
    /* MATLAB Function: '<S1965>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S1965>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S1965>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_eh.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S1978>:1' */
    /* '<S1978>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn2MuteTargetLinearGain = 1.0F;

    /* '<S1978>:1:7' if muteSwitch */
    if (Model_TargetNearAnn2Ann2MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S1978>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn2MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S1978>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_eh.rampRate != 0.0F)
    {
        /* '<S1978>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S1978>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S1978>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S1978>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn2MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn2MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_eh.rampRate) *
            1000.0F;
    }

    /* '<S1978>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S1978>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S1978>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn2MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S1978>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S1978>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_h = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn2MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn2MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn2MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_h = qhmath_exp_f(Model_Target_B.ramping_coeff_h);

    /* End of MATLAB Function: '<S1965>/get_ramp_coeffs' */
}

/*
 * Output and update for function-call system:
 *    '<S2005>/SetDsm'
 *    '<S2005>/SetDsm1'
 */
void Model_Target_SetDsm_mp(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S2008>/Data Store Write' incorporates:
     *  Constant: '<S2008>/Constant'
     */
    Model_TargetControlDsms.NearAnn2Ann2VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S2005>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_d(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S2010>:1' */
    /* '<S2010>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S2010>:1:23' numGains = numel(target_gains_linear); */
    /* '<S2010>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S2010>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S2010>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S2010>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S2010>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S2010>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S2010>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S2010>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S2010>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S2010>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S2010>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S2010>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S2010>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S2010>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S2010>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S2010>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S2010>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S2010>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S2010>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S2010>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S2010>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S2010>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S2010>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S1988>/REQ' */
void HandleReqNearAnn2Ann2VolumeSet(void)
{
    /* MATLAB Function: '<S1935>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2001>:1' */
    /* '<S2001>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector_gg);

    /* MATLAB Function: '<S1935>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector_gg.Outp,
        &(Model_Target_Near_p0_b0.Ann2Ann2VolumeTable_Idx[0]),
        &(Model_Target_Near_p0_b0.Ann2Ann2VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain_cg);

    /* MATLAB Function: '<S1935>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2_ib);

    /* MATLAB Function: '<S1935>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn2Ann2VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3_dk);

    /* MATLAB Function: '<S1935>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters
        (Model_Target_B.sf_rtcscalartovector3_dk.Outp,
         Model_Target_B.sf_rtcscalartovector2_ib.Outp,
         Model_Target_Near_p0_b0.Ann2Ann2VolumeRampTime,
         &Model_Target_B.sf_get_ramp_parameters_oq);

    /* Outputs for Function Call SubSystem: '<S2005>/SetDsm' */
    Model_Target_SetDsm_mp(1U);

    /* End of Outputs for SubSystem: '<S2005>/SetDsm' */

    /* MATLAB Function: '<S2005>/rgainy ramper control' */
    /* MATLAB Function: '<S2005>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S2005>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_d
        (Model_Target_B.sf_calculate_vol_gain_cg.gain_value,
         Model_Target_B.sf_get_ramp_parameters_oq.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters_oq.ramp_ms, 44307.692307692312,
         32.0);

    /* Outputs for Function Call SubSystem: '<S2005>/SetDsm1' */
    Model_Target_SetDsm_mp(0U);

    /* End of Outputs for SubSystem: '<S2005>/SetDsm1' */
}

/* Output and update for atomic system: '<S2004>/rgainy process' */
void Model_Target_rgainyprocess_j(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_e_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S2007>:1' */
    /*  set the size of the output buffer */
    /* '<S2007>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S2007>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S2007>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S2007>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S2007>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S2007>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S2007>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain;

    /* '<S2007>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn2Ann2VolumeFreeze == 0U)
    {
        /* '<S2007>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S2007>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.targetGain;
        }
        else
        {
            /* '<S2007>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S2007>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.rampCoeff;

            /* '<S2007>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S2007>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S2007>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S2007>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S2007>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S2007>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S2007>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S2007>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn2Ann2VolumeRampers.currentGain = gain;

    /* '<S2007>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S2007>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S2007>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* Output and update for function-call system: '<S2017>/REQ' */
void HandleReqNearAnn3Ann3NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S2012>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2033>:1' */
    /* '<S2033>:1:3' go(); */
    Model_Target_MATLABFunction_m0
        (Model_TargetNearAnn3Ann3NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_f10);
}

/* Output and update for function-call system: '<S2046>/REQ' */
void HandleReqNearAnn3Ann3MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S2044>/calculate_ramp_rate' */
    /* MATLAB Function: '<S2044>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2053>:1' */
    /* '<S2053>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near_p0_b0.Ann3Ann3MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_mf);

    /* MATLAB Function: '<S2045>/get_ramp_coeffs' */
    /* MATLAB Function: '<S2045>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S2045>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S2045>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_mf.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S2058>:1' */
    /* '<S2058>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn3MuteTargetLinearGain = 1.0F;

    /* '<S2058>:1:7' if muteSwitch */
    if (Model_TargetNearAnn3Ann3MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S2058>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn3MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S2058>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_mf.rampRate != 0.0F)
    {
        /* '<S2058>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S2058>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S2058>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S2058>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn3MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn3MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_mf.rampRate) *
            1000.0F;
    }

    /* '<S2058>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S2058>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S2058>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn3MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S2058>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S2058>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff_i = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn3MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn3MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn3MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff_i = qhmath_exp_f(Model_Target_B.ramping_coeff_i);

    /* End of MATLAB Function: '<S2045>/get_ramp_coeffs' */
}

/*
 * Output and update for function-call system:
 *    '<S2085>/SetDsm'
 *    '<S2085>/SetDsm1'
 */
void Model_Target_SetDsm_b(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S2088>/Data Store Write' incorporates:
     *  Constant: '<S2088>/Constant'
     */
    Model_TargetControlDsms.NearAnn3Ann3VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S2085>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_o(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S2090>:1' */
    /* '<S2090>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S2090>:1:23' numGains = numel(target_gains_linear); */
    /* '<S2090>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S2090>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S2090>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S2090>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S2090>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S2090>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S2090>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S2090>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S2090>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S2090>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S2090>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S2090>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S2090>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S2090>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S2090>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S2090>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S2090>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S2090>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S2090>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S2090>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S2090>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S2090>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S2090>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S2068>/REQ' */
void HandleReqNearAnn3Ann3VolumeSet(void)
{
    /* MATLAB Function: '<S2015>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2081>:1' */
    /* '<S2081>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector_fe);

    /* MATLAB Function: '<S2015>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector_fe.Outp,
        &(Model_Target_Near_p0_b0.Ann3Ann3VolumeTable_Idx[0]),
        &(Model_Target_Near_p0_b0.Ann3Ann3VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain_clo);

    /* MATLAB Function: '<S2015>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2_a3);

    /* MATLAB Function: '<S2015>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn3Ann3VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3_pj);

    /* MATLAB Function: '<S2015>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters
        (Model_Target_B.sf_rtcscalartovector3_pj.Outp,
         Model_Target_B.sf_rtcscalartovector2_a3.Outp,
         Model_Target_Near_p0_b0.Ann3Ann3VolumeRampTime,
         &Model_Target_B.sf_get_ramp_parameters_my);

    /* Outputs for Function Call SubSystem: '<S2085>/SetDsm' */
    Model_Target_SetDsm_b(1U);

    /* End of Outputs for SubSystem: '<S2085>/SetDsm' */

    /* MATLAB Function: '<S2085>/rgainy ramper control' */
    /* MATLAB Function: '<S2085>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S2085>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_o
        (Model_Target_B.sf_calculate_vol_gain_clo.gain_value,
         Model_Target_B.sf_get_ramp_parameters_my.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters_my.ramp_ms, 44307.692307692312,
         32.0);

    /* Outputs for Function Call SubSystem: '<S2085>/SetDsm1' */
    Model_Target_SetDsm_b(0U);

    /* End of Outputs for SubSystem: '<S2085>/SetDsm1' */
}

/* Output and update for atomic system: '<S2084>/rgainy process' */
void Model_Target_rgainyprocess_n(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_k_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S2087>:1' */
    /*  set the size of the output buffer */
    /* '<S2087>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S2087>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S2087>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S2087>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S2087>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S2087>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S2087>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain;

    /* '<S2087>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn3Ann3VolumeFreeze == 0U)
    {
        /* '<S2087>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S2087>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.targetGain;
        }
        else
        {
            /* '<S2087>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S2087>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.rampCoeff;

            /* '<S2087>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S2087>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S2087>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S2087>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S2087>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S2087>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S2087>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S2087>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn3Ann3VolumeRampers.currentGain = gain;

    /* '<S2087>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S2087>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S2087>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* Output and update for function-call system: '<S2097>/REQ' */
void HandleReqNearAnn4Ann4NonEntGainCalcvncEnableRTC(void)
{
    /* MATLAB Function: '<S2092>/MATLAB Function' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2113>:1' */
    /* '<S2113>:1:3' go(); */
    Model_Target_MATLABFunction_m0
        (Model_TargetNearAnn4Ann4NonEntGainCalcvncEnableRTCRtcOut.REQ_vncEnable,
         &Model_Target_B.sf_MATLABFunction_k2g);
}

/* Output and update for function-call system: '<S2126>/REQ' */
void HandleReqNearAnn4Ann4MuteSet(void)
{
    real32_T quantum_ms;
    real32_T x;

    /* MATLAB Function: '<S2124>/calculate_ramp_rate' */
    /* MATLAB Function: '<S2124>/calculate_ramp_rate' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2133>:1' */
    /* '<S2133>:1:3' go(); */
    Model_Target_calculate_ramp_rate
        (Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_db_per_second,
         Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_ramp_milliseconds,
         Model_Target_Near_p0_b0.Ann4Ann4MuteRampTime,
         &Model_Target_B.sf_calculate_ramp_rate_bo);

    /* MATLAB Function: '<S2125>/get_ramp_coeffs' */
    /* MATLAB Function: '<S2125>/get_ramp_coeffs' incorporates:
     *  DataStoreRead: '<S2125>/Data Store Read'
     *  S-Function (AudioStats_MEX): '<S2125>/Audio Stats'
     */
    x = Model_Target_B.sf_calculate_ramp_rate_bo.ramptime;

    /* MATLAB Function 'MuteRamper/get_ramp_coeffs': '<S2138>:1' */
    /* '<S2138>:1:5' targetLinearGain = single(1.0); */
    Model_TargetControlDsms.NearAnn4MuteTargetLinearGain = 1.0F;

    /* '<S2138>:1:7' if muteSwitch */
    if (Model_TargetNearAnn4Ann4MuteSetRtcOut.REQ_mute_switch != 0U)
    {
        /* '<S2138>:1:8' targetLinearGain = single(max(0, silentGainLinear)); */
        Model_TargetControlDsms.NearAnn4MuteTargetLinearGain = 4.7315126E-7F;
    }

    /*  % Nudge the gain values a bit if they are sitting at zero. */
    /*  % If current gain is zero, replace with a value very close to zero. What we */
    /*  % really want is a value which is on the edge of perception - not too small */
    /*  % or large. If the value is too small, we'll waste some of our ramp time */
    /*  % in perceived silence. If the value is too large, the audio will lurch */
    /*  % into perceptability at the start of the ramp. */
    /*  % So, 'max(currentGainValue, silentGainLinear)' & 'max(TargetGain, silentGainLinear)' are */
    /*  % used in equations */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain difference between target and current value. */
    /*  Equivalent ramp rate is therefore calculated as follows: */
    /* '<S2138>:1:24' if (rampingRate_dBPerSec) */
    if (Model_Target_B.sf_calculate_ramp_rate_bo.rampRate != 0.0F)
    {
        /* '<S2138>:1:25' currentGain_db = 20*log10(max(currentGainValue, silentGainLinear)); */
        /* '<S2138>:1:26' targetGain_db = 20*log10( targetLinearGain); */
        /* '<S2138>:1:27' diff = abs(currentGain_db - targetGain_db); */
        /* '<S2138>:1:28' rampingTime_ms = diff / single(rampingRate_dBPerSec) * 1000; */
        x = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f(fmaxf
                           (Model_TargetControlDsms.NearAnn4MuteCurrentGain,
                            4.7315126E-7F)) - 20.0F * qhmath_log10_f
                          (Model_TargetControlDsms.NearAnn4MuteTargetLinearGain)),
                         Model_Target_B.sf_calculate_ramp_rate_bo.rampRate) *
            1000.0F;
    }

    /* '<S2138>:1:31' quantum_ms = 1000 * frameSize / Fs_Hz; */
    quantum_ms = qhmath_div_f(32000.0F, 44307.692307692312);

    /* '<S2138>:1:32' numFrames = rampingTime_ms / quantum_ms; */
    /*  Do a ceil rather than a round to insure that we create enough */
    /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
    /* '<S2138>:1:35' nFrames = max (1, ceil(numFrames)); */
    Model_TargetControlDsms.NearAnn4MuteNframes = fmaxf(1.0F, qhmath_ceil_f
        (qhmath_div_f(x, quantum_ms)));

    /* '<S2138>:1:36' quantized_rampTime_ms = nFrames * quantum_ms; */
    /*  In order to have the desired ramp time, the slope must vary dependent */
    /*  on the gain differencebetween target and current value. */
    /*  Ramper's coefficient is therefore calculated as follows: */
    /*  */
    /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
    /*  */
    /*  therefore... */
    /*  */
    /*                      log(TargetGain/CurrentGain) */
    /*    log(RampCoef) = ------------------------------ */
    /*                         Fs*(RampTime_ms/1000) */
    /*  */
    /* '<S2138>:1:50' ramping_coeff= exp(log( targetLinearGain /max(currentGainValue, silentGainLinear) ) / (Fs_Hz * quantized_rampTime_ms / 1000)); */
    Model_Target_B.ramping_coeff = qhmath_div_f(qhmath_log_f(qhmath_div_f
        (Model_TargetControlDsms.NearAnn4MuteTargetLinearGain, fmaxf
         (Model_TargetControlDsms.NearAnn4MuteCurrentGain, 4.7315126E-7F))),
        qhmath_div_f(Model_TargetControlDsms.NearAnn4MuteNframes * quantum_ms *
                     44307.692307692312, 1000.0F));
    Model_Target_B.ramping_coeff = qhmath_exp_f(Model_Target_B.ramping_coeff);

    /* End of MATLAB Function: '<S2125>/get_ramp_coeffs' */
}

/*
 * Output and update for function-call system:
 *    '<S2165>/SetDsm'
 *    '<S2165>/SetDsm1'
 */
void Model_Target_SetDsm_bb(uint32_T rtp_Value)
{
    /* DataStoreWrite: '<S2168>/Data Store Write' incorporates:
     *  Constant: '<S2168>/Constant'
     */
    Model_TargetControlDsms.NearAnn4Ann4VolumeFreeze = rtp_Value;
}

/* Output and update for function-call system: '<S2165>/rgainy ramper control' */
void Model_Target_rgainyrampercontrol_a(real32_T rtu_target_gains_linear, real_T
    rtu_db_per_sec, real_T rtu_ramp_times_ms, real32_T rtu_sample_rate_in_hertz,
    real32_T rtu_frame_size)
{
    int32_T ramper;
    real32_T quantum_ms;
    real32_T targetGain;

    /*  Dimensions of target_gains_linear must match the number of rampers.  */
    /*  */
    /*  db_per_sec takes precidence: */
    /*  If db_per_sec has a non-zero value then any ramp_times_ms values are */
    /*  ignored and the db_per_sec is used to determine ramper timing. */
    /*  */
    /*  The dimension of ramp_times_ms is flexible and does not need to match the */
    /*  ramper count. Its values are assigned to rampers in rotating order. If */
    /*  there are 5 rampers and only two times provided, then rampers 1,3, and 5 */
    /*  get the first ramp time and rampers 2 and 4 receive the second ramp time. */
    /*  Any extra ramp times (beyond the number of rampers) are silently ignored. */
    /* MATLAB Function 'Rgainy/ControlSubsystem/rgainy ramper control': '<S2170>:1' */
    /* '<S2170>:1:20' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
    /*  Get the sizes of the provided target and time specifications */
    /* '<S2170>:1:23' numGains = numel(target_gains_linear); */
    /* '<S2170>:1:24' numTimes = numel(ramp_times_ms); */
    /* '<S2170>:1:25' numdbpersecs=numel(db_per_sec); */
    /*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
    /*  on the current gain value. (This step is done outside on canvas now) */
    /* '<S2170>:1:30' for ramper=1:MaskNumRampers */
    targetGain = fmaxf(rtu_target_gains_linear, 5.0118723E-7F);
    quantum_ms = qhmath_div_f(1000.0F * rtu_frame_size, rtu_sample_rate_in_hertz);
    Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.targetGain =
        rtu_target_gains_linear;
    for (ramper = 0; ramper < 1; ramper++)
    {
        real32_T currentGain;
        real32_T numFrames;

        /*  assign gains and ramp times */
        /* '<S2170>:1:33' targetGain = single(target_gains_linear(mod(ramper-1,numGains)+1)); */
        /* '<S2170>:1:34' ramp_ms    = single(ramp_times_ms      (mod(ramper-1,numTimes)+1)); */
        numFrames = (real32_T)rtu_ramp_times_ms;

        /* '<S2170>:1:35' ramp_dbPerSec= single(db_per_sec      (mod(ramper-1,numdbpersecs)+1)); */
        /*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
        /*  When this control set goes live, ensure that the current gain will move. */
        /*  If current gain is zero, replace with a value very close to zero. What we */
        /*  really want is a value which is on the edge of perception - not too small */
        /*  or large. If the value is too small, we'll waste some of our ramp time */
        /*  in perceived silence. If the value is too large, the audio will lurch */
        /*  into perceptability at the start of the ramp. */
        /* '<S2170>:1:44' currentGain = max(Rampers(ramper).currentGain, rgain_SILENT_GAIN); */
        currentGain = fmaxf
            (Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain,
             5.0118723E-7F);

        /* '<S2170>:1:45' targetGain  = max(targetGain, rgain_SILENT_GAIN); */
        /*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
        /*  and instead calculate a new ramp time that matches the slope. */
        /* '<S2170>:1:49' if (ramp_dbPerSec) */
        if ((real32_T)rtu_db_per_sec != 0.0F)
        {
            /* '<S2170>:1:50' currentGain_db = 20*log10(currentGain); */
            /* '<S2170>:1:51' targetGain_db = 20*log10(targetGain); */
            /* '<S2170>:1:52' diff = abs(currentGain_db - targetGain_db); */
            /* '<S2170>:1:53' ramp_ms = diff / single(ramp_dbPerSec) * 1000; */
            numFrames = qhmath_div_f(qhmath_abs_f(20.0F * qhmath_log10_f
                (currentGain) - 20.0F * qhmath_log10_f(targetGain)), (real32_T)
                rtu_db_per_sec) * 1000.0F;
        }

        /*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
        /*  the whole number of frames required to best match requested ramp time. */
        /*  Ensure that at least one frame is used. The frame size will therefore */
        /*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
        /* '<S2170>:1:60' quantum_ms = 1000 * frame_size / sample_rate_in_hertz; */
        /* '<S2170>:1:61' numFrames = ramp_ms / quantum_ms; */
        /*  Do a ceil rather than a round to insure that we create enough */
        /*  frames. i.e. a fraction of a frame is promoted to an addition frame */
        /*  numFrames = max (1, round(numFrames)); */
        /* '<S2170>:1:65' numFrames = max (1, ceil(numFrames)); */
        numFrames = fmaxf(1.0F, qhmath_ceil_f(qhmath_div_f(numFrames, quantum_ms)));

        /* '<S2170>:1:66' quantized_rampTime_ms = numFrames * quantum_ms; */
        /*  In order to have the desired ramp time, the slope must vary dependent */
        /*  on the gain differencebetween target and current value. */
        /*  Ramper's coefficient is therefore calculated as follows: */
        /*  */
        /*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
        /*  */
        /*  therefore... */
        /*  */
        /*                      log(TargetGain/CurrentGain) */
        /*    log(RampCoef) = ------------------------------ */
        /*                         Fs*(RampTime_ms/1000) */
        /*  */
        /* '<S2170>:1:80' factor = log( targetGain / currentGain ); */
        /* '<S2170>:1:81' RampCoef = exp(factor / (sample_rate_in_hertz * quantized_rampTime_ms / 1000)); */
        Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.rampCoeff =
            qhmath_exp_f(qhmath_div_f(qhmath_log_f(qhmath_div_f(targetGain,
                            currentGain)), qhmath_div_f(numFrames * quantum_ms *
                           rtu_sample_rate_in_hertz, 1000.0F)));

        /*  Output control signals */
        /* '<S2170>:1:84' Rampers(ramper).frameCount  = int32(numFrames); */
        Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount = (int32_T)
            numFrames;

        /* '<S2170>:1:85' Rampers(ramper).rampCoeff   = single(RampCoef); */
        /* '<S2170>:1:86' Rampers(ramper).targetGain  = target_gains_linear(ramper); */
        /* '<S2170>:1:87' Rampers(ramper).currentGain = currentGain; */
        Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain =
            currentGain;
    }

    /*  Step 4: UNFREEZE the gain ramper (performed outside on canvas now) */
}

/* Output and update for function-call system: '<S2148>/REQ' */
void HandleReqNearAnn4Ann4VolumeSet(void)
{
    /* MATLAB Function: '<S2095>/rtcscalartovector' */
    /*  Invoke the function trigger output */
    /* MATLAB Function 'RTC/REQ': '<S2161>:1' */
    /* '<S2161>:1:3' go(); */
    Model_Target_rtcscalartovector
        (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_volume_index,
         &Model_Target_B.sf_rtcscalartovector_j0);

    /* MATLAB Function: '<S2095>/calculate_vol_gain' */
    Model_Target_calculate_vol_gain(Model_Target_B.sf_rtcscalartovector_j0.Outp,
        &(Model_Target_Near_p0_b0.Ann4Ann4VolumeTable_Idx[0]),
        &(Model_Target_Near_p0_b0.Ann4Ann4VolumeTable_dB[0]),
        &Model_Target_B.sf_calculate_vol_gain_ik);

    /* MATLAB Function: '<S2095>/rtcscalartovector2' */
    Model_Target_rtcscalartovector2
        (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_db_per_second,
         &Model_Target_B.sf_rtcscalartovector2_gu);

    /* MATLAB Function: '<S2095>/rtcscalartovector3' */
    Model_Target_rtcscalartovector3
        (Model_TargetNearAnn4Ann4VolumeSetRtcOut.REQ_ramp_milliseconds,
         &Model_Target_B.sf_rtcscalartovector3_gp);

    /* MATLAB Function: '<S2095>/get_ramp_parameters' */
    Model_Target_get_ramp_parameters
        (Model_Target_B.sf_rtcscalartovector3_gp.Outp,
         Model_Target_B.sf_rtcscalartovector2_gu.Outp,
         Model_Target_Near_p0_b0.Ann4Ann4VolumeRampTime,
         &Model_Target_B.sf_get_ramp_parameters_kf);

    /* Outputs for Function Call SubSystem: '<S2165>/SetDsm' */
    Model_Target_SetDsm_bb(1U);

    /* End of Outputs for SubSystem: '<S2165>/SetDsm' */

    /* MATLAB Function: '<S2165>/rgainy ramper control' */
    /* MATLAB Function: '<S2165>/rgainy ramper control' incorporates:
     *  S-Function (AudioStats_MEX): '<S2165>/Audio Stats'
     */
    Model_Target_rgainyrampercontrol_a
        (Model_Target_B.sf_calculate_vol_gain_ik.gain_value,
         Model_Target_B.sf_get_ramp_parameters_kf.ramp_rate,
         Model_Target_B.sf_get_ramp_parameters_kf.ramp_ms, 44307.692307692312,
         32.0);

    /* Outputs for Function Call SubSystem: '<S2165>/SetDsm1' */
    Model_Target_SetDsm_bb(0U);

    /* End of Outputs for SubSystem: '<S2165>/SetDsm1' */
}

/* Output and update for atomic system: '<S2164>/rgainy process' */
void Model_Target_rgainyprocess_h(const uint8_T rtu_rampToChanMap[2], const
    real32_T rtu_audioIn[32], B_rgainyprocess_Model_Target_m_T *localB)
{
    int32_T b_tmp;
    int32_T n;
    real32_T gain;
    real32_T k;

    /* MATLAB Function 'Rgainy/AudioRateSubsystem/rgainy process': '<S2167>:1' */
    /*  set the size of the output buffer */
    /* '<S2167>:1:8' audioOut = coder.nullcopy(audioIn); */
    /* '<S2167>:1:10' [frame_size,channel_count] = size(audioIn); */
    /* '<S2167>:1:11' gainOut = single(ones(1,channel_count)); */
    localB->gainOut = 1.0F;

    /*  Channel indexes start in the map just after the ramper channel counts. */
    /*  Create an iterator to walk the channel indexes in rampToChanMap */
    /*  (set its value to "point" just *before* the first channel index, since */
    /*  we'll add a channel count to it during use below) */
    /* '<S2167>:1:17' chanIterator = cast(MaskNumRampers,'like',rampToChanMap); */
    /*  Loop through rampers and apply their gain coefficients */
    /* '<S2167>:1:20' for ramper = 1:MaskNumRampers */
    /* '<S2167>:1:21' k = single(1); */
    k = 1.0F;

    /* '<S2167>:1:22' gain = Rampers(ramper).currentGain; */
    gain = Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain;

    /* '<S2167>:1:23' if (Freeze(1) == false) */
    if (Model_TargetControlDsms.NearAnn4Ann4VolumeFreeze == 0U)
    {
        /* '<S2167>:1:24' if (Rampers(ramper).frameCount == 0) */
        if (Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount == 0)
        {
            /*  The ramp is finished. Stop ramping and SNAP to the target */
            /* '<S2167>:1:26' gain = Rampers(ramper).targetGain; */
            gain = Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.targetGain;
        }
        else
        {
            /* '<S2167>:1:27' else */
            /*  The ramp is *NOT* frozen or done: gain is moving */
            /* '<S2167>:1:29' k = Rampers(ramper).rampCoeff; */
            k = Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.rampCoeff;

            /* '<S2167>:1:30' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
            Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount =
                Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.frameCount - 1;
        }
    }

    /*  Loop through samples, adjusting gain and applying to channels */
    /* '<S2167>:1:34' for n=1:frame_size */
    b_tmp = rtu_rampToChanMap[0];
    for (n = 0; n < 32; n++)
    {
        /* '<S2167>:1:35' gain = gain * k; */
        gain *= k;

        /*  Loop through channels associated with this ramper */
        /* '<S2167>:1:37' for chanCount = 1:rampToChanMap(ramper) */
        if (b_tmp - 1 >= 0)
        {
            localB->audioOut[n] = rtu_audioIn[n] * gain;
        }
    }

    /* '<S2167>:1:42' for chanCount = 1:rampToChanMap(ramper) */
    for (n = 0; n < b_tmp; n++)
    {
        /* '<S2167>:1:43' chanIdx = rampToChanMap(chanIterator + chanCount); */
        /* '<S2167>:1:44' gainOut(chanIdx) = gain; */
        localB->gainOut = gain;
    }

    /* '<S2167>:1:46' Rampers(ramper).currentGain = gain; */
    Model_TargetControlDsms.NearAnn4Ann4VolumeRampers.currentGain = gain;

    /* '<S2167>:1:47' chanIterator = chanIterator + rampToChanMap(ramper); */
    /*  handle any channels that are not assigned to a ramper (i.e. no gain) */
    /* '<S2167>:1:50' for noRampChannel=(chanIterator+1):(channel_count+MaskNumRampers) */
    if ((uint8_T)(rtu_rampToChanMap[0] + 2U) <= 2)
    {
        /* '<S2167>:1:53' audioOut(n,chanIdx) = audioIn(n,chanIdx); */
        memcpy(&localB->audioOut[0], &rtu_audioIn[0], sizeof(real32_T) << 5U);
    }
}

/* System initialize for atomic system: '<S5>/SrcDownAnn' */
void Model_Target_SrcDownAnn_Init(void)
{
    int32_T i;

    /* Start for Constant: '<S2178>/coeffs' */
    memcpy(&Model_Target_B.coeffs[0], &Model_Target_ConstP.pooled94[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Start for Constant: '<S2178>/advance' */
        Model_Target_B.advance[i] = Model_Target_ConstP.pooled41[i];
    }

    /* InitializeConditions for S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function' */

    // S-Function Block: <S2178>/S-Function (SampleRateConverter_sfunc)
    {
        // Temporary values/pointers
        int idx;
        int nCh = 2;
        int nFrameIn = 32;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = nFrameIn;
        else
            nFrameOut = (-1);

        // Pointer to filter coefficient blocks
        float *pFilter, *pFilterEnd, *pFilterCurr;
        int *pAdvance, *pAdvanceEnd, *pAdvanceCurr;
        int nBuffer;                   // Number of input samples

        // Pointer to input circular buffers and read/write pointers
        float **pInputBuffer, **pInputBufferEnd, **pInputWrite, **pInputRead;

        /*
         * Save filter and advance sample pointers
         */
        pFilter = (float*)(&Model_Target_B.coeffs[0]);
        pFilterEnd = pFilter + (240);
        pFilterCurr = pFilter;
        pAdvance = (int*)(&Model_Target_B.advance[0]);
        pAdvanceEnd = pAdvance + (12);
        pAdvanceCurr = pAdvance;

        /*
         * Allocate input buffers and pointers
         */

        // Calculate the number of input samples needed to produce output per input frame
        nBuffer = 2 * ceil(nFrameOut * (13) / (12)) + (20);

        // Quantize to input frame size
        nBuffer = (int)(ceil((float)nBuffer / (float)nFrameIn));//Number of frames
        if (nBuffer<2)
            nBuffer = 2;               //Min num of frames = 2
        nBuffer = nBuffer * nFrameIn;

        // Allocate the circular buffers along with end/read/write pointers
        pInputBuffer = (float**)&Model_Target_DW.SFunction_pInputBuffer[0];
        pInputBufferEnd = (float**)&Model_Target_DW.SFunction_pInputBufferEnd[0];
        pInputWrite = (float**)&Model_Target_DW.SFunction_pInputWrite[0];
        pInputRead = (float**)&Model_Target_DW.SFunction_pInputRead[0];
        for (idx = 0; idx < nCh; idx++)
        {
            // Allocate twice what is needed ("double buffer")
            pInputBuffer[idx] = (float*)&Model_Target_DW.SFunction_InputBuffer[0]
                + (idx * nBuffer);
            pInputBufferEnd[idx] = pInputBuffer[idx] + nBuffer;
            pInputWrite[idx] = pInputBuffer[idx] ;
            pInputRead[idx] = pInputBuffer[idx] + (nBuffer>>1) - 1;
        }

        // Save pointers
        Model_Target_DW.SFunction_PWORK[0] = (void*)pInputBuffer;
        Model_Target_DW.SFunction_PWORK[1] = (void*)pInputBufferEnd;
        Model_Target_DW.SFunction_PWORK[2] = (void*)pInputWrite;
        Model_Target_DW.SFunction_PWORK[3] = (void*)pInputRead;
        Model_Target_DW.SFunction_PWORK[4] = (void*)pFilter;
        Model_Target_DW.SFunction_PWORK[5] = (void*)pFilterEnd;
        Model_Target_DW.SFunction_PWORK[6] = (void*)pFilterCurr;
        Model_Target_DW.SFunction_PWORK[7] = (void*)pAdvance;
        Model_Target_DW.SFunction_PWORK[8] = (void*)pAdvanceEnd;
        Model_Target_DW.SFunction_PWORK[9] = (void*)pAdvanceCurr;
        Model_Target_DW.SFunction_IWORK = nBuffer;
    }
}

/* Output and update for atomic system: '<S5>/SrcDownAnn' */
void Model_Target_SrcDownAnnTID1(void)
{
    int_T tid = 1;

    /* S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function' */
    /* Because the Outputs function of multirate block
       <S2178>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2178>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);
            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK;
                            pIn2 -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function' */
    /* Because the Update function of multirate block
       <S2178>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2178>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector2[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch], (Model_Target_DW.SFunction_IWORK)
                    * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Output and update for atomic system: '<S5>/SrcDownAnn' */
void Model_Target_SrcDownAnnTID2(void)
{
    int_T tid = 2;
    int32_T i;

    /* Constant: '<S2178>/coeffs' */
    memcpy(&Model_Target_B.coeffs[0], &Model_Target_ConstP.pooled94[0], 240U *
           sizeof(real32_T));
    for (i = 0; i < 12; i++)
    {
        /* Constant: '<S2178>/advance' */
        Model_Target_B.advance[i] = Model_Target_ConstP.pooled41[i];
    }

    /* S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function' */
    /* Because the Outputs function of multirate block
       <S2178>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */
    /* S-Function Block: <S2178>/S-Function (SampleRateConverter_sfunc) */
    {
        int nCh = 2;
        int ch, idx, samp;
        int nFrameOut;
        if ((-1) == -1)
            nFrameOut = 32;
        else
            nFrameOut = (-1);
        if (tid == 2)
        {
            float *out = (float*)(&Model_Target_B.SFunction[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);
            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);
            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            float **pInputRead = (float**)(Model_Target_DW.SFunction_PWORK[3]);
            float *pFilter = (float*)(Model_Target_DW.SFunction_PWORK[4]);
            float *pFilterEnd = (float*)(Model_Target_DW.SFunction_PWORK[5]);
            float *pFilterCurr = (float*)(Model_Target_DW.SFunction_PWORK[6]);
            int *pAdvance = (int*)(Model_Target_DW.SFunction_PWORK[7]);
            int *pAdvanceEnd = (int*)(Model_Target_DW.SFunction_PWORK[8]);
            int *pAdvanceCurr = (int*)(Model_Target_DW.SFunction_PWORK[9]);
            for (idx = 0; idx < nFrameOut; idx++)
            {
                float *pOut = out + idx;
                float *pFiltBase = pFilterCurr;

                // Do the polyphase convolution for each channel
#define CHAN_2_CHANGE
#ifdef CHAN_2_CHANGE

                ch = 0;
                if (nCh - ((nCh>>1)<<1))
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                    ch++;
                }

                for (; ch < nCh; ch += 2)
                {
                    float *pIn1 = pInputRead[ch];
                    float *pIn2 = pInputRead[ch+1];
                    float outval1 = 0.0;
                    float outval2 = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval1 += *(pFilterCurr) * *(pIn1++);
                        outval2 += *(pFilterCurr++) * *(pIn2++);
                        if (pIn1 > pInputBufferEnd[ch] - 1)
                        {
                            pIn1 -= Model_Target_DW.SFunction_IWORK;
                            pIn2 -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval1 += pFilterCurr[samp] * *(pIn1);
                        outval2 += pFilterCurr[samp] * *(pIn2);
                        pIn1 = circptr(pIn1, sizeof(float), pInputBuffer[ch],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                        pIn2 = circptr(pIn2, sizeof(float), pInputBuffer[ch+1],
                                       Model_Target_DW.SFunction_IWORK * sizeof
                                       (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval1;
                    pOut += nFrameOut;
                    *pOut = outval2;
                    pOut += nFrameOut;
                }

#else                                  //#ifdef CHAN_2_CHANGE

                for (ch = 0; ch < nCh; ch++)
                {
                    float *pIn = pInputRead[ch];
                    float outval = 0.0;
                    pFilterCurr = pFiltBase;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    for (samp = 0; samp < (20); samp++)
                    {
                        outval += *(pFilterCurr++) * *(pIn++);
                        if (pIn > pInputBufferEnd[ch] - 1)
                        {
                            pIn -= Model_Target_DW.SFunction_IWORK;
                        }
                    }

#else

                    for (samp = 0; samp < (20); samp += 1)
                    {
                        outval += pFilterCurr[samp] * *(pIn);
                        pIn = circptr(pIn, sizeof(float), pInputBuffer[ch],
                                      Model_Target_DW.SFunction_IWORK * sizeof
                                      (float));
                    }

                    pFilterCurr += (20);

#endif

                    *pOut = outval;
                    pOut += nFrameOut;
                }

#endif

                // Move back to the first filter block if we're at the end
                if (pFilterCurr >= pFilterEnd)
                {
                    pFilterCurr = pFilter;
                }

                // Increment input read as needed
                for (ch = 0; ch < nCh; ch++)
                {

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                    pInputRead[ch] += *pAdvanceCurr;
                    if (pInputRead[ch] >= pInputBufferEnd[ch])
                    {
                        pInputRead[ch] -= Model_Target_DW.SFunction_IWORK;
                    }

#else

                    pInputRead[ch] = circptr(pInputRead[ch], sizeof(float) *
                        (*pAdvanceCurr), pInputBuffer[ch],
                        Model_Target_DW.SFunction_IWORK * sizeof(float));

#endif

                }

                pAdvanceCurr++;
                if (pAdvanceCurr >= pAdvanceEnd)
                {
                    pAdvanceCurr = pAdvance;
                }
            }

            Model_Target_DW.SFunction_PWORK[6] = (void*)pFilterCurr;
            Model_Target_DW.SFunction_PWORK[9] = (void*)pAdvanceCurr;
        }
    }

    /* Update for S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function' */
    /* Because the Update function of multirate block
       <S2178>/S-Function is not rate grouped,
       the following code might contain unreachable blocks of code.
       To avoid this, you must update your block TLC file. */

    /* S-Function Block: <S2178>/S-Function (SampleRateConverter_sfunc) */
    {
        int ch;
        int nCh = 2;
        int nFrameIn = 32;
        if (tid == 1)
        {
            // Copy input samples into the circular buffer
            float *in = (float*)(&Model_Target_B.VariableSelector2[0]);
            float **pInputBuffer = (float**)(Model_Target_DW.SFunction_PWORK[0]);

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

            float **pInputBufferEnd = (float**)(Model_Target_DW.SFunction_PWORK
                [1]);

#endif

            float **pInputWrite = (float**)(Model_Target_DW.SFunction_PWORK[2]);
            for (ch = 0; ch < nCh; ch++)
            {

#if !defined (PCPREQ4) && !defined (__HEXAGON_ARCH__)

                aligned(pInputWrite[ch], 2 * sizeof(float));

#endif

                memcpy(pInputWrite[ch], in, nFrameIn * sizeof(float));
                in += nFrameIn;

#if defined (PCPREQ4) || defined (__HEXAGON_ARCH__)

                pInputWrite[ch] += nFrameIn;
                if (pInputWrite[ch] >= pInputBufferEnd[ch])
                {
                    pInputWrite[ch] = pInputBuffer[ch];
                }

#else

                pInputWrite[ch] = circptr(pInputWrite[ch], nFrameIn * sizeof
                    (float), pInputBuffer[ch], (Model_Target_DW.SFunction_IWORK)
                    * sizeof(float));

#endif

            }
        }
    }

    /* If subsystem generates rate grouping Output functions,
     * when tid is used in Output function for one rate,
     * all Output functions include tid as a local variable.
     * As result, some Output functions may have unused tid.
     */
    UNUSED_PARAMETER(tid);
}

/* Termination for atomic system: '<S5>/SrcDownAnn' */
void Model_Target_SrcDownAnn_Term(void)
{
    /* Terminate for S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function' */

    /* S-Function Block: <S2178>/S-Function (SampleRateConverter_sfunc) */
    {
    }
}

/*
 * Function for MATLAB Function: '<S1615>/MATLAB Function'
 * function mixOut = Mixer(audioIn, loc, gainMatrix, interp)
 */
static void Model_Target_Mixer(const real32_T audioIn[8], const real32_T loc[2],
    const real32_T gainMatrix[25], real_T interp, real32_T mixOut[8])
{
    int32_T x1;
    real32_T x;
    real32_T y;

    /*   */
    /* '<S1666>:1:29' s = size(gainMatrix); */
    /* '<S1666>:1:30' x = min(s(1), max(1, loc(1)*(s(1)-1)+1)); */
    x = fminf(5.0F, fmaxf(1.0F, loc[0] * 4.0F + 1.0F));

    /* '<S1666>:1:31' y = min(s(2), max(1, loc(2)*(s(2)-1)+1)); */
    y = fminf(5.0F, fmaxf(1.0F, loc[1] * 4.0F + 1.0F));

    /* '<S1666>:1:33' if interp == 1 */
    if (interp == 1.0)
    {
        int32_T b_y1;
        int8_T c_idx_0;
        int8_T d_idx_0;
        int8_T e_idx_0;
        int8_T f_idx_0;

        /* '<S1666>:1:34' x1 =  floor(x); */
        x1 = (int32_T)qhmath_floor_f(x);

        /* '<S1666>:1:35' x2 = x1 + 1; */
        /* '<S1666>:1:36' y1 =  floor(y); */
        b_y1 = (int32_T)qhmath_floor_f(y);

        /* '<S1666>:1:37' y2 = y1+1; */
        /* '<S1666>:1:38' overIdx = (x2 > s(1)); */
        /* '<S1666>:1:39' x1(overIdx) = x1(overIdx) - 1; */
        c_idx_0 = (int8_T)x1;

        /* '<S1666>:1:40' x2(overIdx) = x2(overIdx) - 1; */
        d_idx_0 = (int8_T)(x1 + 1);
        if (x1 + 1 > 5)
        {
            c_idx_0 = (int8_T)(x1 - 1);
            d_idx_0 = (int8_T)x1;
        }

        /* '<S1666>:1:41' overIdy = (y2 > s(2)); */
        /* '<S1666>:1:42' y1(overIdy) = y1(overIdy) - 1; */
        e_idx_0 = (int8_T)b_y1;

        /* '<S1666>:1:43' y2(overIdy) = y2(overIdy) - 1; */
        f_idx_0 = (int8_T)(b_y1 + 1);
        if (b_y1 + 1 > 5)
        {
            e_idx_0 = (int8_T)(b_y1 - 1);
            f_idx_0 = (int8_T)b_y1;
        }

        /* '<S1666>:1:44' a = x-x1; */
        x -= (real32_T)c_idx_0;

        /* '<S1666>:1:45' b = y-y1; */
        y -= (real32_T)e_idx_0;

        /* '<S1666>:1:46' gmp = gainMatrix; */
        /* '<S1666>:1:47' g00 = gmp(x1,y1); */
        /* '<S1666>:1:48' g01 = gmp(x1,y2); */
        /* '<S1666>:1:49' g10 = gmp(x2,y1); */
        /* '<S1666>:1:50' g11 = gmp(x2,y2); */
        /* '<S1666>:1:52' g = g00*(1-a)*(1-b) + g01*(1-a)*(b) + g10*(1-b)*(a) + g11*(a)*(b); */
        x1 = (e_idx_0 - 1) * 5;
        b_y1 = (f_idx_0 - 1) * 5;
        y = ((gainMatrix[(x1 + c_idx_0) - 1] * (1.0F - x) * (1.0F - y) +
              gainMatrix[(b_y1 + c_idx_0) - 1] * (1.0F - x) * y) + gainMatrix
             [(x1 + d_idx_0) - 1] * (1.0F - y) * x) + gainMatrix[(b_y1 + d_idx_0)
            - 1] * x * y;
    }
    else
    {
        /* '<S1666>:1:53' else */
        /* '<S1666>:1:54' g = gainMatrix(floor(x),floor(y)); */
        y = gainMatrix[(int32_T)((qhmath_floor_f(y) - 1.0F) * 5.0F +
            qhmath_floor_f(x)) - 1];
    }

    /* '<S1666>:1:57' mixOut = g*audioIn; */
    for (x1 = 0; x1 < 8; x1++)
    {
        mixOut[x1] = y * audioIn[x1];
    }
}

/*
 * Function for MATLAB Function: '<S1673>/MATLAB Function'
 * function mixOut = Mixer(audioIn, loc, gainMatrix, interp)
 */
static void Model_Target_Mixer_k(const real32_T audioIn[32], const real32_T loc
    [2], const real32_T gainMatrix[25], real_T interp, real32_T mixOut[32])
{
    int32_T x1;
    real32_T x;
    real32_T y;

    /*   */
    /* '<S1724>:1:29' s = size(gainMatrix); */
    /* '<S1724>:1:30' x = min(s(1), max(1, loc(1)*(s(1)-1)+1)); */
    x = fminf(5.0F, fmaxf(1.0F, loc[0] * 4.0F + 1.0F));

    /* '<S1724>:1:31' y = min(s(2), max(1, loc(2)*(s(2)-1)+1)); */
    y = fminf(5.0F, fmaxf(1.0F, loc[1] * 4.0F + 1.0F));

    /* '<S1724>:1:33' if interp == 1 */
    if (interp == 1.0)
    {
        int32_T b_y1;
        int8_T c_idx_0;
        int8_T d_idx_0;
        int8_T e_idx_0;
        int8_T f_idx_0;

        /* '<S1724>:1:34' x1 =  floor(x); */
        x1 = (int32_T)qhmath_floor_f(x);

        /* '<S1724>:1:35' x2 = x1 + 1; */
        /* '<S1724>:1:36' y1 =  floor(y); */
        b_y1 = (int32_T)qhmath_floor_f(y);

        /* '<S1724>:1:37' y2 = y1+1; */
        /* '<S1724>:1:38' overIdx = (x2 > s(1)); */
        /* '<S1724>:1:39' x1(overIdx) = x1(overIdx) - 1; */
        c_idx_0 = (int8_T)x1;

        /* '<S1724>:1:40' x2(overIdx) = x2(overIdx) - 1; */
        d_idx_0 = (int8_T)(x1 + 1);
        if (x1 + 1 > 5)
        {
            c_idx_0 = (int8_T)(x1 - 1);
            d_idx_0 = (int8_T)x1;
        }

        /* '<S1724>:1:41' overIdy = (y2 > s(2)); */
        /* '<S1724>:1:42' y1(overIdy) = y1(overIdy) - 1; */
        e_idx_0 = (int8_T)b_y1;

        /* '<S1724>:1:43' y2(overIdy) = y2(overIdy) - 1; */
        f_idx_0 = (int8_T)(b_y1 + 1);
        if (b_y1 + 1 > 5)
        {
            e_idx_0 = (int8_T)(b_y1 - 1);
            f_idx_0 = (int8_T)b_y1;
        }

        /* '<S1724>:1:44' a = x-x1; */
        x -= (real32_T)c_idx_0;

        /* '<S1724>:1:45' b = y-y1; */
        y -= (real32_T)e_idx_0;

        /* '<S1724>:1:46' gmp = gainMatrix; */
        /* '<S1724>:1:47' g00 = gmp(x1,y1); */
        /* '<S1724>:1:48' g01 = gmp(x1,y2); */
        /* '<S1724>:1:49' g10 = gmp(x2,y1); */
        /* '<S1724>:1:50' g11 = gmp(x2,y2); */
        /* '<S1724>:1:52' g = g00*(1-a)*(1-b) + g01*(1-a)*(b) + g10*(1-b)*(a) + g11*(a)*(b); */
        x1 = (e_idx_0 - 1) * 5;
        b_y1 = (f_idx_0 - 1) * 5;
        y = ((gainMatrix[(x1 + c_idx_0) - 1] * (1.0F - x) * (1.0F - y) +
              gainMatrix[(b_y1 + c_idx_0) - 1] * (1.0F - x) * y) + gainMatrix
             [(x1 + d_idx_0) - 1] * (1.0F - y) * x) + gainMatrix[(b_y1 + d_idx_0)
            - 1] * x * y;
    }
    else
    {
        /* '<S1724>:1:53' else */
        /* '<S1724>:1:54' g = gainMatrix(floor(x),floor(y)); */
        y = gainMatrix[(int32_T)((qhmath_floor_f(y) - 1.0F) * 5.0F +
            qhmath_floor_f(x)) - 1];
    }

    /* '<S1724>:1:57' mixOut = g*audioIn; */
    for (x1 = 0; x1 < 32; x1++)
    {
        mixOut[x1] = y * audioIn[x1];
    }
}

/* Function for MATLAB Function: '<S105>/BoostMapAdjustments' */
static real32_T Model_Target_interp1(const real32_T varargin_1[2], const
    real32_T varargin_2[2], real32_T varargin_3)
{
    real32_T Vq;
    real32_T r;
    real32_T x_idx_1;
    real32_T y_idx_0;
    real32_T y_idx_1;
    y_idx_0 = varargin_2[0];
    r = varargin_1[0];
    y_idx_1 = varargin_2[1];
    x_idx_1 = varargin_1[1];
    if (varargin_1[1] < varargin_1[0])
    {
        r = varargin_1[1];
        x_idx_1 = varargin_1[0];
        y_idx_0 = varargin_2[1];
        y_idx_1 = varargin_2[0];
    }

    Vq = 0.0F;
    if ((varargin_3 <= x_idx_1) && (varargin_3 >= r))
    {
        r = qhmath_div_f(varargin_3 - r, x_idx_1 - r);
        if (r == 0.0F)
        {
            Vq = y_idx_0;
        }
        else if (r == 1.0F)
        {
            Vq = y_idx_1;
        }
        else if (y_idx_0 == y_idx_1)
        {
            Vq = y_idx_0;
        }
        else
        {
            Vq = (1.0F - r) * y_idx_0 + r * y_idx_1;
        }
    }

    return Vq;
}

/* Function for MATLAB Function: '<S563>/balanceProcess' */
static void Model_Target_eml_find_a(const boolean_T x[2], int32_T i_data[],
    int32_T i_size[2])
{
    int32_T idx;
    int32_T ii;
    boolean_T exitg1;
    idx = 0;
    i_size[0] = 1;
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii < 2))
    {
        if (x[ii])
        {
            idx++;
            i_data[idx - 1] = ii + 1;
            if (idx >= 2)
            {
                exitg1 = true;
            }
            else
            {
                ii++;
            }
        }
        else
        {
            ii++;
        }
    }

    if (idx < 1)
    {
        i_size[1] = 0;
    }
    else
    {
        i_size[1] = idx;
    }
}

/* Function for MATLAB Function: '<S291>/ComputePmin' */
static real32_T Model_Target_mod(real32_T x, real32_T y)
{
    real32_T r;
    r = x;
    if (y == 0.0F)
    {
        if (x == 0.0F)
        {
            r = y;
        }
    }
    else if (x == 0.0F)
    {
        r = qhmath_div_f(0.0F, y);
    }
    else
    {
        boolean_T rEQ0;
        r = fmodf(x, y);
        rEQ0 = (r == 0.0F);
        if ((!rEQ0) && (y > qhmath_floor_f(y)))
        {
            real32_T q;
            q = qhmath_abs_f(qhmath_div_f(x, y));
            rEQ0 = (qhmath_abs_f(q - qhmath_floor_f(q + 0.5F)) <= 1.1920929E-7F *
                    q);
        }

        if (rEQ0)
        {
            r = 0.0F;
        }
        else if ((x < 0.0F) != (y < 0.0F))
        {
            r += y;
        }
    }

    return r;
}

/* Function for MATLAB Function: '<S434>/SpeedBounds' */
static real32_T Model_Target_interp1_m(const real32_T varargin_1[128], const
    real32_T varargin_2[128], real32_T varargin_3)
{
    int32_T i;
    real32_T x[128];
    real32_T y[128];
    real32_T Vq;
    real32_T xtmp;
    memcpy(&y[0], &varargin_2[0], sizeof(real32_T) << 7U);
    memcpy(&x[0], &varargin_1[0], sizeof(real32_T) << 7U);
    if (varargin_1[1] < varargin_1[0])
    {
        for (i = 0; i < 64; i++)
        {
            xtmp = x[i];
            x[i] = x[127 - i];
            x[127 - i] = xtmp;
            xtmp = y[i];
            y[i] = y[127 - i];
            y[127 - i] = xtmp;
        }
    }

    Vq = 0.0F;
    if ((varargin_3 <= x[127]) && (varargin_3 >= x[0]))
    {
        int32_T low_i;
        int32_T low_ip1;
        i = 128;
        low_i = 1;
        low_ip1 = 2;
        while (i > low_ip1)
        {
            int32_T mid_i;
            mid_i = (low_i + i) >> 1;
            if (varargin_3 >= x[mid_i - 1])
            {
                low_i = mid_i;
                low_ip1 = mid_i + 1;
            }
            else
            {
                i = mid_i;
            }
        }

        xtmp = x[low_i - 1];
        xtmp = qhmath_div_f(varargin_3 - xtmp, x[low_i] - xtmp);
        if (xtmp == 0.0F)
        {
            Vq = y[low_i - 1];
        }
        else if (xtmp == 1.0F)
        {
            Vq = y[low_i];
        }
        else
        {
            Vq = y[low_i - 1];
            if (Vq != y[low_i])
            {
                Vq = (1.0F - xtmp) * Vq + xtmp * y[low_i];
            }
        }
    }

    return Vq;
}

/* Model step function for TID0 */
void Model_Target_step0(void)  /* Sample time: [5.5555555555555551E-5s, 0.0s] */
{
    {                          /* Sample time: [5.5555555555555551E-5s, 0.0s] */
        rate_monotonic_scheduler();
    }
}

/* Model step function for TID1 */
void Model_Target_step1(void) /* Sample time: [0.00066666666666666664s, 0.0s] */
{
    /* local scratch DWork variables */
    int32_T ForEach_itr;
    int32_T mainSelect[24];
    int32_T i;
    int32_T i_0;
    int32_T rtb_enableAuxFlag;
    real32_T tmp;

    /* Outputs for Atomic SubSystem: '<S4>/SrcUp' */
    Model_Target_SrcUpTID1();

    /* End of Outputs for SubSystem: '<S4>/SrcUp' */

    /* Outputs for Atomic SubSystem: '<Root>/TestRouter' */
    /* SignalConversion generated from: '<S9>/Matrix Concatenate' */
    memset(&Model_Target_B.MatrixConcatenate[768], 0, 768U * sizeof(real32_T));

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2279>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S2277>/get_mainCh_parameters' incorporates:
     *  S-Function (TOP_MEX): '<S2302>/TOP'
     */
    /*  % RTC message parameter */
    /*  Tune parameter */
    /* MATLAB Function 'TestRouter/ASDRouter/InnerLink/MainChannelSystem/get_mainCh_parameters': '<S2303>:1' */
    /*  Main Select is provided to the block through Tune variables. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages.     */
    /* '<S2303>:1:7' mainSelect = int32(mainSelectTune); */
    /* '<S2303>:1:8' for ind=1:size(mainSelectRTC,1) */
    for (i = 0; i < 24; i++)
    {
        mainSelect[i] = Model_Target_TestRouter_p0_b0.ASDRouterMainSelect[i];

        /*  If MSB of mainSelectRTC is set to '1', it means Tune values are to be used and not RTC value */
        /* '<S2303>:1:10' if (~bitget(mainSelectRTC(ind),32)) */
        if ((Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_mainSelect[i] &
             MIN_int32_T) == 0)
        {
            /* '<S2303>:1:11' mainSelect(ind) = mainSelectRTC(ind); */
            mainSelect[i] =
                Model_TargetTestRouterASDRouterMainSelectRtcOut.REQ_mainSelect[i];
        }
    }

    /* End of MATLAB Function: '<S2277>/get_mainCh_parameters' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2278>/RTC Request Response Trigger' */

    /* Outputs for Iterator SubSystem: '<S2277>/MainChannelSubSystem' incorporates:
     *  ForEach: '<S2301>/For Each'
     */
    for (ForEach_itr = 0; ForEach_itr < 24; ForEach_itr++)
    {
        /* Outputs for IfAction SubSystem: '<S2304>/If Action Subsystem' incorporates:
         *  ActionPort: '<S2305>/Action Port'
         */
        /* If: '<S2304>/If1' incorporates:
         *  ForEachSliceSelector generated from: '<S2301>/pMainSelect_in'
         *  S-Function (sdspperm2): '<S2305>/Variable Selector1'
         */
        i = mainSelect[ForEach_itr] - 1;

        /* End of Outputs for SubSystem: '<S2304>/If Action Subsystem' */
        if (mainSelect[ForEach_itr] > 0)
        {
            /* Outputs for IfAction SubSystem: '<S2304>/If Action Subsystem' incorporates:
             *  ActionPort: '<S2305>/Action Port'
             */
            if (i < 0)
            {
                i = 0;
            }
            else if (i >= 48)
            {
                i = 47;
            }

            /* End of Outputs for SubSystem: '<S2304>/If Action Subsystem' */

            /* ForEachSliceSelector generated from: '<S2301>/pMainGain_in' */
            tmp =
                Model_TargetTestRouterASDRouterMainGainRtcOut.REQ_mainGain[ForEach_itr];

            /* Outputs for IfAction SubSystem: '<S2304>/If Action Subsystem' incorporates:
             *  ActionPort: '<S2305>/Action Port'
             */
            for (rtb_enableAuxFlag = 0; rtb_enableAuxFlag < 32;
                    rtb_enableAuxFlag++)
            {
                /* ForEachSliceAssignment generated from: '<S2301>/Out1' incorporates:
                 *  Concatenate: '<S9>/Matrix Concatenate'
                 *  Product: '<S2305>/Multiply'
                 */
                Model_Target_B.ImpAsg_InsertedFor_Out1_at_inport_0_m[rtb_enableAuxFlag
                    + (ForEach_itr << 5)] = Model_Target_B.MatrixConcatenate[(i <<
                    5) + rtb_enableAuxFlag] * tmp;
            }

            /* End of Outputs for SubSystem: '<S2304>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2304>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S2306>/Action Port'
             */
            for (i_0 = 0; i_0 < 32; i_0++)
            {
                /* ForEachSliceAssignment generated from: '<S2301>/Out1' incorporates:
                 *  Constant: '<S2306>/Constant'
                 *  SignalConversion generated from: '<S2306>/Out1'
                 */
                Model_Target_B.ImpAsg_InsertedFor_Out1_at_inport_0_m[i_0 +
                    (ForEach_itr << 5)] = 0.0F;
            }

            /* End of Outputs for SubSystem: '<S2304>/If Action Subsystem1' */
        }

        /* End of If: '<S2304>/If1' */
    }

    /* End of Outputs for SubSystem: '<S2277>/MainChannelSubSystem' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2274>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2276>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S2273>/get_auxCh_parameters' incorporates:
     *  S-Function (TOP_MEX): '<S2271>/TOP'
     */
    rtb_enableAuxFlag = Model_Target_TestRouter_p0_b0.ASDRouterEnableAux;

    /*  % RTC message parameters */
    /*  Tune parameters */
    /* MATLAB Function 'TestRouter/ASDRouter/InnerLink/AuxChannel_with_MATLAB_function/get_auxCh_parameters': '<S2282>:1' */
    /*  Aux Select and Enable Aux are provided to the block through Tune variables. However  */
    /*  if parameters are provided through RTC, the block will use the values  */
    /*  given in the RTC messages.     */
    /* '<S2282>:1:8' enableAuxFlag = int32(enableAuxFlagTune); */
    /* '<S2282>:1:9' auxSelect = int32(auxSelectTune); */
    /*  If MSB of auxSelectRTC/enableAuxFlagRTC is set to '1', it means Tune */
    /*  values are to be used and not RTC values */
    /* '<S2282>:1:13' for ind=1:size(auxSelectRTC,1) */
    for (i = 0; i < 24; i++)
    {
        mainSelect[i] = Model_Target_TestRouter_p0_b0.AuxSelect[i];

        /* '<S2282>:1:14' if (~bitget(auxSelectRTC(ind),32)) */
        if ((Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_AuxSelect[i] &
                MIN_int32_T) == 0)
        {
            /* '<S2282>:1:15' auxSelect(ind) = auxSelectRTC(ind); */
            mainSelect[i] =
                Model_TargetTestRouterASDRouterAuxSelectRtcOut.REQ_AuxSelect[i];
        }
    }

    /* '<S2282>:1:19' for ind=1:length(enableAuxFlagRTC) */
    /* '<S2282>:1:20' if(~bitget(enableAuxFlagRTC(ind),32)) */
    if ((Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_EnableAuxFlag &
            MIN_int32_T) == 0)
    {
        /* '<S2282>:1:21' enableAuxFlag(ind) = enableAuxFlagRTC(ind); */
        rtb_enableAuxFlag =
            Model_TargetTestRouterASDRouterAuxEnableRtcOut.REQ_EnableAuxFlag;
    }

    /* End of MATLAB Function: '<S2273>/get_auxCh_parameters' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2275>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S2273>/AuxChannelSubSystem' incorporates:
     *  Concatenate: '<S9>/Matrix Concatenate'
     *  Constant: '<S2273>/inputOffset'
     *  Constant: '<S2273>/numAux'
     *  ForEachSliceAssignment generated from: '<S2301>/Out1'
     */
    memcpy(&Model_Target_B.out[0],
           &Model_Target_B.ImpAsg_InsertedFor_Out1_at_inport_0_m[0], 768U *
           sizeof(real32_T));

    /*  initial inputOffset is the number of ENT inputs */
    /* MATLAB Function 'TestRouter/ASDRouter/InnerLink/AuxChannel_with_MATLAB_function/AuxChannelSubSystem': '<S2280>:1' */
    /* '<S2280>:1:4' for i=1:length(numAux) */
    /* '<S2280>:1:5' if(enableAux(i)) */
    if (rtb_enableAuxFlag != 0)
    {
        /* '<S2280>:1:6' tempSelect = inputOffset + pAuxSelect((i-1)*nChanOut+1:i*nChanOut); */
        /*  Account for Matlab 1 index */
        /* '<S2280>:1:7' tempGain = pAuxGain((i-1)*nChanOut+1:i*nChanOut); */
        /*  Account for Matlab 1 index */
        /* '<S2280>:1:8' for ch = 1:1:nChanOut */
        for (i = 0; i < 24; i++)
        {
            rtb_enableAuxFlag = mainSelect[i];
            if (rtb_enableAuxFlag > 2147483623)
            {
                rtb_enableAuxFlag = MAX_int32_T;
            }
            else
            {
                rtb_enableAuxFlag += 24;
            }

            /* '<S2280>:1:9' if (tempSelect(ch) > inputOffset) */
            if ((rtb_enableAuxFlag > 24) && (rtb_enableAuxFlag <= 56))
            {
                /*  This channel is part of AUX, not MAIN */
                /* '<S2280>:1:11' if(tempSelect(ch) > (numAux(i)+inputOffset)) */
                /* '<S2280>:1:14' else */
                /* '<S2280>:1:15' y(:,ch)=y(:,ch) + x(:, tempSelect(ch)) * tempGain(ch); */
                tmp = Model_TargetTestRouterASDRouterAuxGainRtcOut.REQ_AuxGain[i];
                for (i_0 = 0; i_0 < 32; i_0++)
                {
                    int32_T out_tmp;
                    out_tmp = (i << 5) + i_0;
                    Model_Target_B.out[out_tmp] +=
                        Model_Target_B.MatrixConcatenate[((rtb_enableAuxFlag - 1)
                        << 5) + i_0] * tmp;
                }
            }
            else
            {
                /*  aux select index exceeds number of aux inputs of that bank */
                /* '<S2280>:1:13' y(:,ch)=y(:,ch) + x(:, tempSelect(ch)) * 0; */
            }
        }
    }

    /* End of MATLAB Function: '<S2273>/AuxChannelSubSystem' */

    /* S-Function (RTC_NTF): '<S2274>/NTF Trigger' */
    /* '<S2280>:1:20' inputOffset = inputOffset + numAux(i); */
    /* '<S2280>:1:22' out = y; */
    /* End of Outputs for S-Function (RTC_NTF): '<S2274>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2275>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2276>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2278>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2279>/NTF Trigger' */

    /* Outputs for Atomic SubSystem: '<Root>/PostProcess' */
    /* Outputs for Atomic SubSystem: '<S7>/PostProcess' */
    Model_Target_PostProcess();

    /* End of Outputs for SubSystem: '<S7>/PostProcess' */

    /* Outputs for Atomic SubSystem: '<Root>/SimIn' */
    /* SignalConversion generated from: '<S8>/In' incorporates:
     *  Inport: '<Root>/BoseAudioIn'
     */
    memcpy(&Model_Target_B.In[0], (&(UnitTest_Target_AudioIn[0])), 160U * sizeof
           (real32_T));

    /* End of Outputs for SubSystem: '<Root>/SimIn' */

    /* Outputs for Atomic SubSystem: '<Root>/InputSelect' */
    Model_Target_InputSelect();

    /* End of Outputs for SubSystem: '<Root>/InputSelect' */

    /* Outputs for Atomic SubSystem: '<S4>/SrcDownEnt' */
    Model_Target_SrcDownEntTID1();

    /* End of Outputs for SubSystem: '<S4>/SrcDownEnt' */

    /* Outputs for Atomic SubSystem: '<S4>/SrcDownMic' */
    Model_Target_SrcDownMicTID1();

    /* End of Outputs for SubSystem: '<S4>/SrcDownMic' */

    /* End of Outputs for S-Function (RTC_NTF): '<S1857>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1908>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1908>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1937>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1988>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1988>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2017>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2068>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2068>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2097>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2148>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S2148>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1784>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1656>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1735>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1736>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1737>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1738>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S1604>/NTF Trigger' */

    /* Outputs for Atomic SubSystem: '<S5>/SrcDownAnn' */
    Model_Target_SrcDownAnnTID1();

    /* End of Outputs for SubSystem: '<S5>/SrcDownAnn' */
}

/* Model step function for TID2 */
void Model_Target_step2(void) /* Sample time: [0.00072222222222222219s, 0.0s] */
{
    real32_T rtb_Switch_iy;
    real32_T rtb_TrebleSlope;
    real32_T rtb_alpha;
    int8_T rtPrevAction;
    boolean_T tmp[2];
    boolean_T rtb_Merge;

    /* Outputs for Atomic SubSystem: '<S4>/SrcDownEnt' */
    Model_Target_SrcDownEntTID2();

    /* End of Outputs for SubSystem: '<S4>/SrcDownEnt' */

    /* Delay: '<S30>/Delay3' */
    Model_Target_B.Delay3 = Model_Target_DW.Delay3_DSTATE;

    /* Outputs for Atomic SubSystem: '<S5>/SrcDownAnn' */
    Model_Target_SrcDownAnnTID2();

    /* End of Outputs for SubSystem: '<S5>/SrcDownAnn' */

    /* Selector: '<S1785>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5[0], &Model_Target_B.SFunction[0], sizeof
           (real32_T) << 5U);

    /* MATLAB Function: '<S1924>/rgainy process' */
    Model_Target_rgainyprocess_l(Model_Target_ConstB.AudioStatsFunc,
        Model_Target_B.Selector5, &Model_Target_B.sf_rgainyprocess_l);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1857>/RTC Request Response Trigger' */

    /* Switch: '<S1852>/Switch1' incorporates:
     *  Constant: '<S1852>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_m0.vncEnableOut > 0U)
    {
        Model_Target_B.Switch1 =
            Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.Switch1 = 0.0;
    }

    /* End of Switch: '<S1852>/Switch1' */
    /* DiscreteFilter: '<S1852>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S1852>/Data Type Conversion1'
     *  DataTypeConversion: '<S1852>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S1866>/den'
     *  S-Function (TOP_MEX): '<S1866>/num'
     */
    Model_Target_B.vncBoostGain =
        Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcNum[0] *
        Model_Target_B.Switch1 + Model_Target_DW.DiscreteFilter_states;
    Model_Target_DW.DiscreteFilter_states =
        Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcNum[1] *
        Model_Target_B.Switch1 -
        Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcDen[1] *
        Model_Target_B.vncBoostGain;

    /* Switch: '<S1867>/Switch' incorporates:
     *  Switch: '<S1852>/Switch'
     */
    if (Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S1867>/Switch' */
        Model_Target_B.Switch =
            Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcNoiseOverRideFlag >
                0.0F)
        {
            /* Switch: '<S1852>/Switch' */
            rtb_Switch_iy =
                Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcNoiseOverRide;
        }
        else
        {
            /* Switch: '<S1852>/Switch' */
            rtb_Switch_iy = Model_Target_B.Delay3;
        }

        /* Switch: '<S1867>/Switch' incorporates:
         *  Constant: '<S1867>/Constant2'
         *  Constant: '<S1869>/Constant'
         *  DataTypeConversion: '<S1852>/Cast To Single'
         *  Gain: '<S1869>/Gain'
         *  Math: '<S1869>/Magsq'
         *  Math: '<S1869>/log10'
         *  MinMax: '<S1867>/max'
         *  MinMax: '<S1867>/min'
         *  MinMax: '<S1868>/max'
         *  Product: '<S1867>/Multiply'
         *  Product: '<S1867>/Multiply1'
         *  Sum: '<S1867>/Add1'
         *  Sum: '<S1868>/Add'
         *  Sum: '<S1869>/Sum1'
         *  Switch: '<S1852>/Switch'
         *
         * About '<S1869>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S1869>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch = fminf(fmaxf(((rtb_Switch_iy +
            Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_l.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_l.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcMaxSpl)) *
            Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near_p0_b0.Ann1Ann1NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.vncBoostGain;
    }

    /* End of Switch: '<S1867>/Switch' */

    /* Math: '<S1877>/Math Function' incorporates:
     *  Constant: '<S1877>/Constant3'
     *  Product: '<S1877>/Divide'
     */
    Model_Target_B.max_h = qhmath_pow_f(10.0F, qhmath_div_f
        (Model_Target_B.Switch, 20.0F));

    /* DiscreteFilter: '<S1882>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S1883>/num'
     */
    Model_Target_B.Discrete_Filter =
        Model_Target_Near_p0_b0.Ann1Ann1NonEntVncAppliedNum[0] *
        Model_Target_B.max_h + Model_Target_DW.Discrete_Filter_states;

    /* DiscreteFilter: '<S1882>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S1883>/den'
     *  S-Function (TOP_MEX): '<S1883>/num'
     */
    Model_Target_DW.Discrete_Filter_states =
        Model_Target_Near_p0_b0.Ann1Ann1NonEntVncAppliedNum[1] *
        Model_Target_B.max_h -
        Model_Target_Near_p0_b0.Ann1Ann1NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter;

    /* S-Function (sdspupsamp2): '<S1882>/Repeat' incorporates:
     *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] =
            Model_Target_B.Discrete_Filter;
        Model_Target_B.yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S1882>/Repeat' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        /* Product: '<S1882>/Product' incorporates:
         *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product[Model_Target_B.xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset]
            * Model_Target_B.sf_rgainyprocess_l.audioOut[Model_Target_B.xpageoffset];
    }

    /* DataStoreRead: '<S1885>/Data Store Read1' */
    Model_Target_B.max_h = Model_TargetControlDsms.NearAnn1MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1886>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S1885>/Ramping_Subsystem' */
    /* MinMax: '<S1899>/Max' incorporates:
     *  Constant: '<S1899>/minGain'
     *  DataStoreRead: '<S1885>/Data Store Read'
     */
    Model_Target_B.Max_g = fmaxf(Model_TargetControlDsms.NearAnn1MuteCurrentGain,
        4.7315126E-7F);

    /* If: '<S1899>/If' incorporates:
     *  Abs: '<S1899>/Abs3'
     *  Constant: '<S1885>/snapThresh'
     *  DataStoreRead: '<S1899>/frames'
     *  Sum: '<S1899>/Add'
     */
    if ((qhmath_abs_f(Model_Target_B.max_h - Model_Target_B.Max_g) > 1.0E-9F) &&
        (Model_TargetControlDsms.NearAnn1MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S1899>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S1902>/Action Port'
         */
        /* DataStoreWrite: '<S1902>/Data Store Write' incorporates:
         *  Constant: '<S1902>/Constant1'
         *  Sum: '<S1902>/Add'
         */
        Model_TargetControlDsms.NearAnn1MuteNframes =
            Model_TargetControlDsms.NearAnn1MuteNframes - 1.0F;

        /* If: '<S1904>/If' incorporates:
         *  Delay: '<S1904>/Delay'
         *  Sum: '<S1904>/Add2'
         */
        if (Model_Target_B.max_h - Model_Target_DW.Delay_DSTATE_e == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S1904>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1905>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S1904>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1904>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S1906>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S1904>/If Action Subsystem1' */
        }

        /* End of If: '<S1904>/If' */

        /* DiscreteFilter: '<S1902>/ramping_filter' incorporates:
         *  Merge: '<S1899>/Merge'
         *  Product: '<S1902>/Matrix Multiply'
         *  Product: '<S1903>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_k = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_k != 0)
        {
            Model_Target_DW.ramping_filter_states_p4 =
                Model_Target_B.ramping_coeff_b * Model_Target_B.Max_g;
        }

        Model_Target_B.yIdx = 0;
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Merge_c[Model_Target_B.yIdx] =
                Model_Target_DW.ramping_filter_states_p4;
            Model_Target_DW.ramping_filter_states_p4 = 0.0F -
                -Model_Target_B.ramping_coeff_b *
                Model_Target_B.Merge_c[Model_Target_B.yIdx];
            Model_Target_B.yIdx++;
        }

        /* End of DiscreteFilter: '<S1902>/ramping_filter' */

        /* Update for Delay: '<S1904>/Delay' */
        Model_Target_DW.Delay_DSTATE_e = Model_Target_B.max_h;

        /* Update for DiscreteFilter: '<S1902>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_k = 0U;

        /* End of Outputs for SubSystem: '<S1899>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1899>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S1901>/Action Port'
         */
        Model_Target_elseActionSubsystem(Model_Target_B.max_h,
            Model_Target_B.Merge_c);

        /* End of Outputs for SubSystem: '<S1899>/elseActionSubsystem' */
    }

    /* End of If: '<S1899>/If' */

    /* S-Function (sdspperm2): '<S1896>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S1885>/Data Store Write'
     *  Merge: '<S1899>/Merge'
     */
    Model_TargetControlDsms.NearAnn1MuteCurrentGain = Model_Target_B.Merge_c[31];

    /* Outputs for Iterator SubSystem: '<S1900>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_c,
        Model_Target_B.Product, &Model_Target_B.VectorConcatenate1[0]);

    /* End of Outputs for SubSystem: '<S1900>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S1885>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S1886>/NTF Trigger' */
    /* Selector: '<S1786>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5_k[0], &Model_Target_B.SFunction[32], sizeof
           (real32_T) << 5U);

    /* MATLAB Function: '<S2004>/rgainy process' */
    Model_Target_rgainyprocess_j(Model_Target_ConstB.AudioStatsFunc_l,
        Model_Target_B.Selector5_k, &Model_Target_B.sf_rgainyprocess_j);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1937>/RTC Request Response Trigger' */

    /* Switch: '<S1932>/Switch1' incorporates:
     *  Constant: '<S1932>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_jcg.vncEnableOut > 0U)
    {
        Model_Target_B.Switch1 =
            Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.Switch1 = 0.0;
    }

    /* End of Switch: '<S1932>/Switch1' */
    /* DiscreteFilter: '<S1932>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S1932>/Data Type Conversion1'
     *  DataTypeConversion: '<S1932>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S1946>/den'
     *  S-Function (TOP_MEX): '<S1946>/num'
     */
    Model_Target_B.vncBoostGain =
        Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcNum[0] *
        Model_Target_B.Switch1 + Model_Target_DW.DiscreteFilter_states_e;
    Model_Target_DW.DiscreteFilter_states_e =
        Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcNum[1] *
        Model_Target_B.Switch1 -
        Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcDen[1] *
        Model_Target_B.vncBoostGain;

    /* Switch: '<S1947>/Switch' incorporates:
     *  Switch: '<S1932>/Switch'
     */
    if (Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S1947>/Switch' */
        Model_Target_B.Switch_l =
            Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcNoiseOverRideFlag >
                0.0F)
        {
            /* Switch: '<S1932>/Switch' */
            rtb_Switch_iy =
                Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcNoiseOverRide;
        }
        else
        {
            /* Switch: '<S1932>/Switch' */
            rtb_Switch_iy = Model_Target_B.Delay3;
        }

        /* Switch: '<S1947>/Switch' incorporates:
         *  Constant: '<S1947>/Constant2'
         *  Constant: '<S1949>/Constant'
         *  DataTypeConversion: '<S1932>/Cast To Single'
         *  Gain: '<S1949>/Gain'
         *  Math: '<S1949>/Magsq'
         *  Math: '<S1949>/log10'
         *  MinMax: '<S1947>/max'
         *  MinMax: '<S1947>/min'
         *  MinMax: '<S1948>/max'
         *  Product: '<S1947>/Multiply'
         *  Product: '<S1947>/Multiply1'
         *  Sum: '<S1947>/Add1'
         *  Sum: '<S1948>/Add'
         *  Sum: '<S1949>/Sum1'
         *  Switch: '<S1932>/Switch'
         *
         * About '<S1949>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S1949>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch_l = fminf(fmaxf(((rtb_Switch_iy +
            Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_j.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_j.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcMaxSpl)) *
            Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near_p0_b0.Ann2Ann2NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.vncBoostGain;
    }

    /* End of Switch: '<S1947>/Switch' */

    /* Math: '<S1957>/Math Function' incorporates:
     *  Constant: '<S1957>/Constant3'
     *  Product: '<S1957>/Divide'
     */
    Model_Target_B.max_h = qhmath_pow_f(10.0F, qhmath_div_f
        (Model_Target_B.Switch_l, 20.0F));

    /* DiscreteFilter: '<S1962>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S1963>/num'
     */
    Model_Target_B.Discrete_Filter_h =
        Model_Target_Near_p0_b0.Ann2Ann2NonEntVncAppliedNum[0] *
        Model_Target_B.max_h + Model_Target_DW.Discrete_Filter_states_j;

    /* DiscreteFilter: '<S1962>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S1963>/den'
     *  S-Function (TOP_MEX): '<S1963>/num'
     */
    Model_Target_DW.Discrete_Filter_states_j =
        Model_Target_Near_p0_b0.Ann2Ann2NonEntVncAppliedNum[1] *
        Model_Target_B.max_h -
        Model_Target_Near_p0_b0.Ann2Ann2NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter_h;

    /* S-Function (sdspupsamp2): '<S1962>/Repeat' incorporates:
     *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] =
            Model_Target_B.Discrete_Filter_h;
        Model_Target_B.yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S1962>/Repeat' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        /* Product: '<S1962>/Product' incorporates:
         *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_h[Model_Target_B.xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset]
            * Model_Target_B.sf_rgainyprocess_j.audioOut[Model_Target_B.xpageoffset];
    }

    /* DataStoreRead: '<S1965>/Data Store Read1' */
    Model_Target_B.max_h = Model_TargetControlDsms.NearAnn2MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1966>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S1965>/Ramping_Subsystem' */
    /* MinMax: '<S1979>/Max' incorporates:
     *  Constant: '<S1979>/minGain'
     *  DataStoreRead: '<S1965>/Data Store Read'
     */
    Model_Target_B.Max_g = fmaxf(Model_TargetControlDsms.NearAnn2MuteCurrentGain,
        4.7315126E-7F);

    /* If: '<S1979>/If' incorporates:
     *  Abs: '<S1979>/Abs3'
     *  Constant: '<S1965>/snapThresh'
     *  DataStoreRead: '<S1979>/frames'
     *  Sum: '<S1979>/Add'
     */
    if ((qhmath_abs_f(Model_Target_B.max_h - Model_Target_B.Max_g) > 1.0E-9F) &&
        (Model_TargetControlDsms.NearAnn2MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S1979>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S1982>/Action Port'
         */
        /* DataStoreWrite: '<S1982>/Data Store Write' incorporates:
         *  Constant: '<S1982>/Constant1'
         *  Sum: '<S1982>/Add'
         */
        Model_TargetControlDsms.NearAnn2MuteNframes =
            Model_TargetControlDsms.NearAnn2MuteNframes - 1.0F;

        /* If: '<S1984>/If' incorporates:
         *  Delay: '<S1984>/Delay'
         *  Sum: '<S1984>/Add2'
         */
        if (Model_Target_B.max_h - Model_Target_DW.Delay_DSTATE_b == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S1984>/If Action Subsystem' incorporates:
             *  ActionPort: '<S1985>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S1984>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S1984>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S1986>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S1984>/If Action Subsystem1' */
        }

        /* End of If: '<S1984>/If' */

        /* DiscreteFilter: '<S1982>/ramping_filter' incorporates:
         *  Merge: '<S1979>/Merge'
         *  Product: '<S1982>/Matrix Multiply'
         *  Product: '<S1983>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_m = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_m != 0)
        {
            Model_Target_DW.ramping_filter_states_p =
                Model_Target_B.ramping_coeff_h * Model_Target_B.Max_g;
        }

        Model_Target_B.yIdx = 0;
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Merge_a_k[Model_Target_B.yIdx] =
                Model_Target_DW.ramping_filter_states_p;
            Model_Target_DW.ramping_filter_states_p = 0.0F -
                -Model_Target_B.ramping_coeff_h *
                Model_Target_B.Merge_a_k[Model_Target_B.yIdx];
            Model_Target_B.yIdx++;
        }

        /* End of DiscreteFilter: '<S1982>/ramping_filter' */

        /* Update for Delay: '<S1984>/Delay' */
        Model_Target_DW.Delay_DSTATE_b = Model_Target_B.max_h;

        /* Update for DiscreteFilter: '<S1982>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_m = 0U;

        /* End of Outputs for SubSystem: '<S1979>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S1979>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S1981>/Action Port'
         */
        Model_Target_elseActionSubsystem(Model_Target_B.max_h,
            Model_Target_B.Merge_a_k);

        /* End of Outputs for SubSystem: '<S1979>/elseActionSubsystem' */
    }

    /* End of If: '<S1979>/If' */

    /* S-Function (sdspperm2): '<S1976>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S1965>/Data Store Write'
     *  Merge: '<S1979>/Merge'
     */
    Model_TargetControlDsms.NearAnn2MuteCurrentGain = Model_Target_B.Merge_a_k
        [31];

    /* Outputs for Iterator SubSystem: '<S1980>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_a_k,
        Model_Target_B.Product_h, &Model_Target_B.VectorConcatenate1[32]);

    /* End of Outputs for SubSystem: '<S1980>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S1965>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S1966>/NTF Trigger' */
    /* Selector: '<S1787>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5_a[0], &Model_Target_B.SFunction[32], sizeof
           (real32_T) << 5U);

    /* MATLAB Function: '<S2084>/rgainy process' */
    Model_Target_rgainyprocess_n(Model_Target_ConstB.AudioStatsFunc_h,
        Model_Target_B.Selector5_a, &Model_Target_B.sf_rgainyprocess_n);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2017>/RTC Request Response Trigger' */

    /* Switch: '<S2012>/Switch1' incorporates:
     *  Constant: '<S2012>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_f10.vncEnableOut > 0U)
    {
        Model_Target_B.vncBoostGain =
            Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.vncBoostGain = 0.0;
    }

    /* End of Switch: '<S2012>/Switch1' */
    /* DiscreteFilter: '<S2012>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S2012>/Data Type Conversion1'
     *  DataTypeConversion: '<S2012>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S2026>/den'
     *  S-Function (TOP_MEX): '<S2026>/num'
     */
    Model_Target_B.Switch1 = Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcNum[0]
        * Model_Target_B.vncBoostGain + Model_Target_DW.DiscreteFilter_states_n;
    Model_Target_DW.DiscreteFilter_states_n =
        Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcNum[1] *
        Model_Target_B.vncBoostGain -
        Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcDen[1] *
        Model_Target_B.Switch1;

    /* Switch: '<S2027>/Switch' incorporates:
     *  Switch: '<S2012>/Switch'
     */
    if (Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S2027>/Switch' */
        Model_Target_B.Switch_g =
            Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcNoiseOverRideFlag >
                0.0F)
        {
            /* Switch: '<S2012>/Switch' */
            rtb_Switch_iy =
                Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcNoiseOverRide;
        }
        else
        {
            /* Switch: '<S2012>/Switch' */
            rtb_Switch_iy = Model_Target_B.Delay3;
        }

        /* Switch: '<S2027>/Switch' incorporates:
         *  Constant: '<S2027>/Constant2'
         *  Constant: '<S2029>/Constant'
         *  DataTypeConversion: '<S2012>/Cast To Single'
         *  Gain: '<S2029>/Gain'
         *  Math: '<S2029>/Magsq'
         *  Math: '<S2029>/log10'
         *  MinMax: '<S2027>/max'
         *  MinMax: '<S2027>/min'
         *  MinMax: '<S2028>/max'
         *  Product: '<S2027>/Multiply'
         *  Product: '<S2027>/Multiply1'
         *  Sum: '<S2027>/Add1'
         *  Sum: '<S2028>/Add'
         *  Sum: '<S2029>/Sum1'
         *  Switch: '<S2012>/Switch'
         *
         * About '<S2029>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S2029>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch_g = fminf(fmaxf(((rtb_Switch_iy +
            Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_n.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_n.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcMaxSpl)) *
            Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near_p0_b0.Ann3Ann3NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.Switch1;
    }

    /* End of Switch: '<S2027>/Switch' */

    /* Math: '<S2037>/Math Function' incorporates:
     *  Constant: '<S2037>/Constant3'
     *  Product: '<S2037>/Divide'
     */
    Model_Target_B.max_h = qhmath_pow_f(10.0F, qhmath_div_f
        (Model_Target_B.Switch_g, 20.0F));

    /* DiscreteFilter: '<S2042>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S2043>/num'
     */
    Model_Target_B.Discrete_Filter_o =
        Model_Target_Near_p0_b0.Ann3Ann3NonEntVncAppliedNum[0] *
        Model_Target_B.max_h + Model_Target_DW.Discrete_Filter_states_l;

    /* DiscreteFilter: '<S2042>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S2043>/den'
     *  S-Function (TOP_MEX): '<S2043>/num'
     */
    Model_Target_DW.Discrete_Filter_states_l =
        Model_Target_Near_p0_b0.Ann3Ann3NonEntVncAppliedNum[1] *
        Model_Target_B.max_h -
        Model_Target_Near_p0_b0.Ann3Ann3NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter_o;

    /* S-Function (sdspupsamp2): '<S2042>/Repeat' incorporates:
     *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] =
            Model_Target_B.Discrete_Filter_o;
        Model_Target_B.yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S2042>/Repeat' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        /* Product: '<S2042>/Product' incorporates:
         *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_hi[Model_Target_B.xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset]
            * Model_Target_B.sf_rgainyprocess_n.audioOut[Model_Target_B.xpageoffset];
    }

    /* DataStoreRead: '<S2045>/Data Store Read1' */
    Model_Target_B.max_h = Model_TargetControlDsms.NearAnn3MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2046>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S2045>/Ramping_Subsystem' */
    /* MinMax: '<S2059>/Max' incorporates:
     *  Constant: '<S2059>/minGain'
     *  DataStoreRead: '<S2045>/Data Store Read'
     */
    Model_Target_B.Max_g = fmaxf(Model_TargetControlDsms.NearAnn3MuteCurrentGain,
        4.7315126E-7F);

    /* If: '<S2059>/If' incorporates:
     *  Abs: '<S2059>/Abs3'
     *  Constant: '<S2045>/snapThresh'
     *  DataStoreRead: '<S2059>/frames'
     *  Sum: '<S2059>/Add'
     */
    if ((qhmath_abs_f(Model_Target_B.max_h - Model_Target_B.Max_g) > 1.0E-9F) &&
        (Model_TargetControlDsms.NearAnn3MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S2059>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S2062>/Action Port'
         */
        /* DataStoreWrite: '<S2062>/Data Store Write' incorporates:
         *  Constant: '<S2062>/Constant1'
         *  Sum: '<S2062>/Add'
         */
        Model_TargetControlDsms.NearAnn3MuteNframes =
            Model_TargetControlDsms.NearAnn3MuteNframes - 1.0F;

        /* If: '<S2064>/If' incorporates:
         *  Delay: '<S2064>/Delay'
         *  Sum: '<S2064>/Add2'
         */
        if (Model_Target_B.max_h - Model_Target_DW.Delay_DSTATE_o == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S2064>/If Action Subsystem' incorporates:
             *  ActionPort: '<S2065>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S2064>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2064>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S2066>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S2064>/If Action Subsystem1' */
        }

        /* End of If: '<S2064>/If' */

        /* DiscreteFilter: '<S2062>/ramping_filter' incorporates:
         *  Merge: '<S2059>/Merge'
         *  Product: '<S2062>/Matrix Multiply'
         *  Product: '<S2063>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad_e = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad_e != 0)
        {
            Model_Target_DW.ramping_filter_states_h =
                Model_Target_B.ramping_coeff_i * Model_Target_B.Max_g;
        }

        Model_Target_B.yIdx = 0;
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Merge_h[Model_Target_B.yIdx] =
                Model_Target_DW.ramping_filter_states_h;
            Model_Target_DW.ramping_filter_states_h = 0.0F -
                -Model_Target_B.ramping_coeff_i *
                Model_Target_B.Merge_h[Model_Target_B.yIdx];
            Model_Target_B.yIdx++;
        }

        /* End of DiscreteFilter: '<S2062>/ramping_filter' */

        /* Update for Delay: '<S2064>/Delay' */
        Model_Target_DW.Delay_DSTATE_o = Model_Target_B.max_h;

        /* Update for DiscreteFilter: '<S2062>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_e = 0U;

        /* End of Outputs for SubSystem: '<S2059>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2059>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S2061>/Action Port'
         */
        Model_Target_elseActionSubsystem(Model_Target_B.max_h,
            Model_Target_B.Merge_h);

        /* End of Outputs for SubSystem: '<S2059>/elseActionSubsystem' */
    }

    /* End of If: '<S2059>/If' */

    /* S-Function (sdspperm2): '<S2056>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S2045>/Data Store Write'
     *  Merge: '<S2059>/Merge'
     */
    Model_TargetControlDsms.NearAnn3MuteCurrentGain = Model_Target_B.Merge_h[31];

    /* Outputs for Iterator SubSystem: '<S2060>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_h,
        Model_Target_B.Product_hi, &Model_Target_B.VectorConcatenate1[64]);

    /* End of Outputs for SubSystem: '<S2060>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S2045>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S2046>/NTF Trigger' */
    /* Selector: '<S1788>/Selector5' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function'
     */
    memcpy(&Model_Target_B.Selector5_l[0], &Model_Target_B.SFunction[32], sizeof
           (real32_T) << 5U);

    /* MATLAB Function: '<S2164>/rgainy process' */
    Model_Target_rgainyprocess_h(Model_Target_ConstB.AudioStatsFunc_f,
        Model_Target_B.Selector5_l, &Model_Target_B.sf_rgainyprocess_h);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2097>/RTC Request Response Trigger' */

    /* Switch: '<S2092>/Switch1' incorporates:
     *  Constant: '<S2092>/Constant'
     */
    if (Model_Target_B.sf_MATLABFunction_k2g.vncEnableOut > 0U)
    {
        Model_Target_B.Switch1 =
            Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcVncEnableTuneVar;
    }
    else
    {
        Model_Target_B.Switch1 = 0.0;
    }

    /* End of Switch: '<S2092>/Switch1' */
    /* DiscreteFilter: '<S2092>/DiscreteFilter' incorporates:
     *  DataTypeConversion: '<S2092>/Data Type Conversion1'
     *  DataTypeConversion: '<S2092>/Data Type Conversion2'
     *  S-Function (TOP_MEX): '<S2106>/den'
     *  S-Function (TOP_MEX): '<S2106>/num'
     */
    Model_Target_B.vncBoostGain_d =
        Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcNum[0] *
        Model_Target_B.Switch1 + Model_Target_DW.DiscreteFilter_states_m;
    Model_Target_DW.DiscreteFilter_states_m =
        Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcNum[1] *
        Model_Target_B.Switch1 -
        Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcDen[1] *
        Model_Target_B.vncBoostGain_d;

    /* Switch: '<S2107>/Switch' incorporates:
     *  Switch: '<S2092>/Switch'
     */
    if (Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcBoostOverRideFlag > 0.0F)
    {
        /* Switch: '<S2107>/Switch' */
        Model_Target_B.Switch_b =
            Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcBoostOverRide;
    }
    else
    {
        if (Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcNoiseOverRideFlag >
                0.0F)
        {
            /* Switch: '<S2092>/Switch' */
            Model_Target_B.Delay3 =
                Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcNoiseOverRide;
        }

        /* Switch: '<S2107>/Switch' incorporates:
         *  Constant: '<S2107>/Constant2'
         *  Constant: '<S2109>/Constant'
         *  DataTypeConversion: '<S2092>/Cast To Single'
         *  Gain: '<S2109>/Gain'
         *  Math: '<S2109>/Magsq'
         *  Math: '<S2109>/log10'
         *  MinMax: '<S2107>/max'
         *  MinMax: '<S2107>/min'
         *  MinMax: '<S2108>/max'
         *  Product: '<S2107>/Multiply'
         *  Product: '<S2107>/Multiply1'
         *  Sum: '<S2107>/Add1'
         *  Sum: '<S2108>/Add'
         *  Sum: '<S2109>/Sum1'
         *  Switch: '<S2092>/Switch'
         *
         * About '<S2109>/Magsq':
         *  Operator: magnitude^2
         *
         * About '<S2109>/log10':
         *  Operator: log10
         */
        Model_Target_B.Switch_b = fminf(fmaxf(((Model_Target_B.Delay3 +
            Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcVncThresh) - fmaxf
            (Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcMinVncSignal,
             qhmath_log10_f((Model_Target_B.sf_rgainyprocess_h.gainOut +
                             2.22044605E-16F) *
                            (Model_Target_B.sf_rgainyprocess_h.gainOut +
                             2.22044605E-16F)) * 10.0F +
             Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcMaxSpl)) *
            Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcVncSlope, 0.0F),
            Model_Target_Near_p0_b0.Ann4Ann4NonEntGainCalcMaxBoost) * (real32_T)
            Model_Target_B.vncBoostGain_d;
    }

    /* End of Switch: '<S2107>/Switch' */

    /* Math: '<S2117>/Math Function' incorporates:
     *  Constant: '<S2117>/Constant3'
     *  Product: '<S2117>/Divide'
     */
    Model_Target_B.Delay3 = qhmath_pow_f(10.0F, qhmath_div_f
        (Model_Target_B.Switch_b, 20.0F));

    /* DiscreteFilter: '<S2122>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S2123>/num'
     */
    Model_Target_B.Discrete_Filter_k =
        Model_Target_Near_p0_b0.Ann4Ann4NonEntVncAppliedNum[0] *
        Model_Target_B.Delay3 + Model_Target_DW.Discrete_Filter_states_jm;

    /* DiscreteFilter: '<S2122>/Discrete_Filter' incorporates:
     *  S-Function (TOP_MEX): '<S2123>/den'
     *  S-Function (TOP_MEX): '<S2123>/num'
     */
    Model_Target_DW.Discrete_Filter_states_jm =
        Model_Target_Near_p0_b0.Ann4Ann4NonEntVncAppliedNum[1] *
        Model_Target_B.Delay3 -
        Model_Target_Near_p0_b0.Ann4Ann4NonEntVncAppliedden[1] *
        Model_Target_B.Discrete_Filter_k;

    /* S-Function (sdspupsamp2): '<S2122>/Repeat' incorporates:
     *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] =
            Model_Target_B.Discrete_Filter_k;
        Model_Target_B.yIdx++;
    }

    /* End of S-Function (sdspupsamp2): '<S2122>/Repeat' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        /* Product: '<S2122>/Product' incorporates:
         *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
         */
        Model_Target_B.Product_a[Model_Target_B.xpageoffset] =
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset]
            * Model_Target_B.sf_rgainyprocess_h.audioOut[Model_Target_B.xpageoffset];
    }

    /* DataStoreRead: '<S2125>/Data Store Read1' */
    Model_Target_B.Delay3 = Model_TargetControlDsms.NearAnn4MuteTargetLinearGain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S2126>/RTC Request Response Trigger' */

    /* Outputs for Atomic SubSystem: '<S2125>/Ramping_Subsystem' */
    /* MinMax: '<S2139>/Max' incorporates:
     *  Constant: '<S2139>/minGain'
     *  DataStoreRead: '<S2125>/Data Store Read'
     */
    Model_Target_B.max_h = fmaxf(Model_TargetControlDsms.NearAnn4MuteCurrentGain,
        4.7315126E-7F);

    /* If: '<S2139>/If' incorporates:
     *  Abs: '<S2139>/Abs3'
     *  Constant: '<S2125>/snapThresh'
     *  DataStoreRead: '<S2139>/frames'
     *  Sum: '<S2139>/Add'
     */
    if ((qhmath_abs_f(Model_Target_B.Delay3 - Model_Target_B.max_h) > 1.0E-9F) &&
        (Model_TargetControlDsms.NearAnn4MuteNframes > 0.0F))
    {
        /* Outputs for IfAction SubSystem: '<S2139>/ifActionSubsystem' incorporates:
         *  ActionPort: '<S2142>/Action Port'
         */
        /* DataStoreWrite: '<S2142>/Data Store Write' incorporates:
         *  Constant: '<S2142>/Constant1'
         *  Sum: '<S2142>/Add'
         */
        Model_TargetControlDsms.NearAnn4MuteNframes =
            Model_TargetControlDsms.NearAnn4MuteNframes - 1.0F;

        /* If: '<S2144>/If' incorporates:
         *  Delay: '<S2144>/Delay'
         *  Sum: '<S2144>/Add2'
         */
        if (Model_Target_B.Delay3 - Model_Target_DW.Delay_DSTATE == 0.0F)
        {
            /* Outputs for IfAction SubSystem: '<S2144>/If Action Subsystem' incorporates:
             *  ActionPort: '<S2145>/Action Port'
             */
            Model_Target_IfActionSubsystem(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S2144>/If Action Subsystem' */
        }
        else
        {
            /* Outputs for IfAction SubSystem: '<S2144>/If Action Subsystem1' incorporates:
             *  ActionPort: '<S2146>/Action Port'
             */
            Model_Target_IfActionSubsystem1(&rtb_Merge);

            /* End of Outputs for SubSystem: '<S2144>/If Action Subsystem1' */
        }

        /* End of If: '<S2144>/If' */

        /* DiscreteFilter: '<S2142>/ramping_filter' incorporates:
         *  Merge: '<S2139>/Merge'
         *  Product: '<S2142>/Matrix Multiply'
         *  Product: '<S2143>/Multiply'
         */
        if (rtb_Merge)
        {
            Model_Target_DW.ramping_filter_icLoad = 1U;
        }

        if (Model_Target_DW.ramping_filter_icLoad != 0)
        {
            Model_Target_DW.ramping_filter_states = Model_Target_B.ramping_coeff
                * Model_Target_B.max_h;
        }

        Model_Target_B.yIdx = 0;
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Merge_ib[Model_Target_B.yIdx] =
                Model_Target_DW.ramping_filter_states;
            Model_Target_DW.ramping_filter_states = 0.0F -
                -Model_Target_B.ramping_coeff *
                Model_Target_B.Merge_ib[Model_Target_B.yIdx];
            Model_Target_B.yIdx++;
        }

        /* End of DiscreteFilter: '<S2142>/ramping_filter' */

        /* Update for Delay: '<S2144>/Delay' */
        Model_Target_DW.Delay_DSTATE = Model_Target_B.Delay3;

        /* Update for DiscreteFilter: '<S2142>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad = 0U;

        /* End of Outputs for SubSystem: '<S2139>/ifActionSubsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S2139>/elseActionSubsystem' incorporates:
         *  ActionPort: '<S2141>/Action Port'
         */
        Model_Target_elseActionSubsystem(Model_Target_B.Delay3,
            Model_Target_B.Merge_ib);

        /* End of Outputs for SubSystem: '<S2139>/elseActionSubsystem' */
    }

    /* End of If: '<S2139>/If' */

    /* S-Function (sdspperm2): '<S2136>/Variable Selector' incorporates:
     *  DataStoreWrite: '<S2125>/Data Store Write'
     *  Merge: '<S2139>/Merge'
     */
    Model_TargetControlDsms.NearAnn4MuteCurrentGain = Model_Target_B.Merge_ib[31];

    /* Outputs for Iterator SubSystem: '<S2140>/For Each Subsystem' */
    Model_Target_ForEachSubsystem(32, Model_Target_B.Merge_ib,
        Model_Target_B.Product_a, &Model_Target_B.VectorConcatenate1[96]);

    /* End of Outputs for SubSystem: '<S2140>/For Each Subsystem' */
    /* End of Outputs for SubSystem: '<S2125>/Ramping_Subsystem' */

    /* End of Outputs for S-Function (RTC_NTF): '<S2126>/NTF Trigger' */
    /* Gain: '<S1796>/Gain' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S2178>/S-Function'
     */
    memcpy(&NearPreEmphasisShelfFilter15569PoolIirAudioIn[0],
           &Model_Target_B.SFunction[0], sizeof(real32_T) << 6U);

    /* End of Outputs for S-Function (InitTriggerControl): '<S1811>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1803>/ITC1' */

    /* MATLAB Function: '<S1802>/PoolIirProcess' incorporates:
     *  Gain: '<S1796>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1806>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1806>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1806>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1806>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1806>:1:29' else */
    /* '<S1806>:1:30' switch(VariantStr) */
    /* '<S1806>:1:31' case{"Hexagon"} */
    /* '<S1806>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&NearPreEmphasisShelfFilter5094PoolIirAudioOut[0],
                    &NearPreEmphasisShelfFilter15569PoolIirAudioIn[0],
                    &NearPreEmphasisShelfFilter28252states[0]);

    /* MATLAB Function: '<S1790>/Preprocessing for Level Detector' */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/AnnouncementLevelDetector/PreProcessing/Preprocessing for Level Detector': '<S1797>:1' */
    /* '<S1797>:1:4' curr = 10 * log10(max(mean(signal .* signal, 1)) + eps); */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 64;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.Selector2_n[Model_Target_B.xpageoffset] =
            NearPreEmphasisShelfFilter5094PoolIirAudioOut[Model_Target_B.xpageoffset]
            * NearPreEmphasisShelfFilter5094PoolIirAudioOut[Model_Target_B.xpageoffset];
    }

    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 2;
            Model_Target_B.stateLen++)
    {
        Model_Target_B.xpageoffset = Model_Target_B.stateLen << 5;
        Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen] =
            Model_Target_B.Selector2_n[Model_Target_B.xpageoffset];
        for (Model_Target_B.c = 0; Model_Target_B.c < 31; Model_Target_B.c++)
        {
            Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen] +=
                Model_Target_B.Selector2_n[(Model_Target_B.xpageoffset +
                Model_Target_B.c) + 1];
        }

        Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen] =
            qhmath_div_f
            (Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen], 32.0F);
    }

    if (Model_Target_B.MatrixConcatenate_eh[0] <
            Model_Target_B.MatrixConcatenate_eh[1])
    {
        rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[1];
    }
    else
    {
        rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[0];
    }

    Model_Target_B.Delay3 = qhmath_log10_f(rtb_Switch_iy + 2.22044605E-16F) *
        10.0F;

    /* '<S1797>:1:6' rms_output = max(curr); */
    /* '<S1797>:1:8' if (peak_enable) */
    if (Model_Target_ConstB.Compare)
    {
        /* '<S1797>:1:9' curr = 20 * log10(max(max(abs(signal))) + eps); */
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 64;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Selector2_n[Model_Target_B.stateLen] = qhmath_abs_f
                (NearPreEmphasisShelfFilter5094PoolIirAudioOut[Model_Target_B.stateLen]);
        }

        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 2;
                Model_Target_B.xpageoffset++)
        {
            Model_Target_B.c = Model_Target_B.xpageoffset << 5;
            Model_Target_B.MatrixConcatenate_eh[Model_Target_B.xpageoffset] =
                Model_Target_B.Selector2_n[Model_Target_B.c];
            for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 31;
                    Model_Target_B.stateLen++)
            {
                Model_Target_B.Max_g =
                    Model_Target_B.MatrixConcatenate_eh[Model_Target_B.xpageoffset];
                rtb_Switch_iy = Model_Target_B.Selector2_n[(Model_Target_B.c +
                    Model_Target_B.stateLen) + 1];
                if (Model_Target_B.Max_g < rtb_Switch_iy)
                {
                    Model_Target_B.Max_g = rtb_Switch_iy;
                }

                Model_Target_B.MatrixConcatenate_eh[Model_Target_B.xpageoffset] =
                    Model_Target_B.Max_g;
            }
        }

        if (Model_Target_B.MatrixConcatenate_eh[0] <
                Model_Target_B.MatrixConcatenate_eh[1])
        {
            rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[1];
        }
        else
        {
            rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[0];
        }

        Model_Target_B.max_h = qhmath_log10_f(rtb_Switch_iy + 2.22044605E-16F) *
            20.0F;

        /* '<S1797>:1:10' peak_output = max(curr); */
    }
    else
    {
        /* '<S1797>:1:11' else */
        /* '<S1797>:1:12' peak_output = rms_output; */
        Model_Target_B.max_h = Model_Target_B.Delay3;
    }

    /* Selector: '<S1611>/Selector1' incorporates:
     *  SignalConversion generated from: '<S1611>/Vector Concatenate2'
     * */
    /* MATLAB Function 'NEAR/Near1p1/VolumeMute/AnnouncementLevelDetector/linear2dB': '<S1795>:1' */
    /* '<S1795>:1:3' voldB = single(20 * log10(volume + eps)); */
    Model_Target_B.Mean[0] = Model_Target_B.sf_rgainyprocess_l.gainOut;
    Model_Target_B.Mean[1] = Model_Target_B.sf_rgainyprocess_j.gainOut;

    /* MATLAB Function: '<S1783>/linear2dB' */
    Model_Target_B.Max_g = qhmath_log10_f(Model_Target_B.Mean[1] +
        2.22044605E-16F) * 20.0F;

    /* MATLAB Function: '<S1814>/InnerLink' incorporates:
     *  Constant: '<S1611>/Constant'
     *  Constant: '<S1783>/ch1_mode'
     *  MATLAB Function: '<S1783>/linear2dB'
     *  MATLAB Function: '<S1790>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink_n(Model_Target_B.Delay3, Model_Target_B.max_h,
        Model_Target_Near_p0_b0.Ann1LevelDetectSlowDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann1LevelDetecthold_margin_db,
        Model_Target_Near_p0_b0.Ann1LevelDetectHoldTimeSamples,
        Model_Target_Near_p0_b0.Ann1LevelDetectFastDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann1LevelDetectMinVolumeDb,
        Model_Target_Near_p0_b0.Ann1LevelDetectMaxVolumeDb, 0.0, 0.0F,
        &Model_Target_DW.sf_InnerLink_n);

    /* MATLAB Function: '<S1822>/InnerLink' incorporates:
     *  Constant: '<S1611>/Constant'
     *  Constant: '<S1783>/ch2_mode'
     *  MATLAB Function: '<S1790>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink_n(Model_Target_B.Delay3, Model_Target_B.max_h,
        Model_Target_Near_p0_b0.Ann2LevelDetectSlowDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann2LevelDetectHoldMarginDb,
        Model_Target_Near_p0_b0.Ann2LevelDetectHoldTimeSamples,
        Model_Target_Near_p0_b0.Ann2LevelDetectFastDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann2LevelDetectMinVolumeDb,
        Model_Target_Near_p0_b0.Ann2LevelDetectMaxVolumeDb, 0.0, 0.0F,
        &Model_Target_DW.sf_InnerLink_m);

    /* MATLAB Function: '<S1830>/InnerLink' incorporates:
     *  Constant: '<S1611>/Constant'
     *  Constant: '<S1783>/ch3_mode'
     *  MATLAB Function: '<S1790>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink_n(Model_Target_B.Delay3, Model_Target_B.max_h,
        Model_Target_Near_p0_b0.Ann3LevelDetectSlowDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann3LevelDetectHoldMarginDb,
        Model_Target_Near_p0_b0.Ann3LevelDetectHoldTimeSamples,
        Model_Target_Near_p0_b0.Ann3LevelDetectFastDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann3LevelDetectMinVolumeDb,
        Model_Target_Near_p0_b0.Ann3LevelDetectMaxVolumeDb, 0.0, 0.0F,
        &Model_Target_DW.sf_InnerLink_ny);

    /* MATLAB Function: '<S1838>/InnerLink' incorporates:
     *  Constant: '<S1611>/Constant'
     *  Constant: '<S1783>/ch4_mode'
     *  MATLAB Function: '<S1790>/Preprocessing for Level Detector'
     */
    Model_Target_InnerLink_n(Model_Target_B.Delay3, Model_Target_B.max_h,
        Model_Target_Near_p0_b0.Ann4LevelDetectSlowDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann4LevelDetectHoldMarginDb,
        Model_Target_Near_p0_b0.Ann4LevelDetectHoldTimeSamples,
        Model_Target_Near_p0_b0.Ann4LevelDetectFastDecayDbPerSample,
        Model_Target_Near_p0_b0.Ann4LevelDetectMinVolumeDb,
        Model_Target_Near_p0_b0.Ann4LevelDetectMaxVolumeDb, 0.0, 1.0F,
        &Model_Target_DW.sf_InnerLink_k);

    /* Selector: '<S1611>/Selector2' incorporates:
     *  Concatenate: '<S1611>/Vector Concatenate1'
     */
    memcpy(&Model_Target_B.Selector2_n[0], &Model_Target_B.VectorConcatenate1[0],
           sizeof(real32_T) << 6U);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1784>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S1780>/PoolIirProcess' incorporates:
     *  S-Function (TOP_MEX): '<S1764>/TOP'
     *  S-Function (TOP_MEX): '<S1764>/TOP1'
     *  Selector: '<S1611>/Selector2'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/Generic/PoolIirProcess': '<S1781>:1' */
    /* '<S1781>:1:5' [frame_size, num_channels] = size(x); */
    /*  Initialize variables */
    /*  Typecast the variables */
    /* '<S1781>:1:11' frame_size = uint32(frame_size); */
    /* '<S1781>:1:12' num_channels = uint32(num_channels); */
    /* Compute the filter coefficients */
    /* '<S1781>:1:15' y = pooliir(x, frame_size, num_channels, numStages, coeffs, states); */
    /*  We have to use a different state buffer than the one passed in.  Matlab */
    /*  value objects are passed by value, not by reference, so the saving of */
    /*  states here does not work.  The state buffer is still necessary to pass */
    /*  allocate in the calling function and pass here in order to trigger CRL. */
    /*  This double buffering is annoying, however only happens during */
    /*  simulation, not code generation. */
    /*  num_states = (length(coeffs) - numChannels) / 2; */
    /*  persistent states; */
    /*  if isempty(states) */
    /*      states = single(zeros(1, num_states)); */
    /*  end */
    /* 'pooliir:15' stateIdx = 1; */
    Model_Target_B.vncBoostGain_d = 1.0;

    /* 'pooliir:16' coeffIdx = 1; */
    Model_Target_B.Switch1 = 1.0;

    /* 'pooliir:18' frameMinus1  = frameSize-1; */
    /*  number of samples minus one */
    /* 'pooliir:19' y     = coder.nullcopy(x); */
    /*  output matrix */
    /*  OUTER LOOP over all channels                  */
    /* 'pooliir:22' for cha = 1:numChannels */
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        /*  FIRST STAGE */
        /*  prologue: get coefficients, states and input vector  */
        /*  and perform some computations */
        /* 'pooliir:28' w1 = states(stateIdx); */
        Model_Target_B.Delay3 = Model_Target_DW.states[(int32_T)
            Model_Target_B.vncBoostGain_d - 1];

        /* 'pooliir:28' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain = Model_Target_B.vncBoostGain_d + 1.0;

        /* S-Function (TOP_MEX): '<S1764>/TOP' */
        /* 'pooliir:29' gain = coeffs(coeffIdx); */
        Model_Target_B.max_h = Model_Target_Near_p0_b0.Coefficients[(int32_T)
            Model_Target_B.Switch1 - 1];

        /* 'pooliir:29' coeffIdx = coeffIdx+1; */
        /* 'pooliir:30' w2 = states(stateIdx); */
        Model_Target_B.Max_g = Model_Target_DW.states[(int32_T)
            (Model_Target_B.vncBoostGain_d + 1.0) - 1];

        /* 'pooliir:30' stateIdx = stateIdx-1; */
        Model_Target_B.vncBoostGain_d = (Model_Target_B.vncBoostGain_d + 1.0) -
            1.0;

        /* S-Function (TOP_MEX): '<S1764>/TOP' */
        /* 'pooliir:31' a2   = coeffs(coeffIdx); */
        Model_Target_B.a2 = Model_Target_Near_p0_b0.Coefficients[(int32_T)
            (Model_Target_B.Switch1 + 1.0) - 1];

        /* 'pooliir:31' coeffIdx = coeffIdx+1; */
        /* 'pooliir:32' xx  = x(1,cha); */
        /* 'pooliir:32' a1   = coeffs(coeffIdx); */
        /* 'pooliir:32' coeffIdx = coeffIdx+1; */
        /* 'pooliir:33' xx  = xx*gain; */
        Model_Target_B.xpageoffset = Model_Target_B.c << 5;
        Model_Target_B.xx =
            Model_Target_B.Selector2_n[Model_Target_B.xpageoffset] *
            Model_Target_B.max_h;

        /* 'pooliir:33' b2   = coeffs(coeffIdx); */
        /* 'pooliir:33' coeffIdx = coeffIdx+1; */
        /* 'pooliir:34' yy  = w1+xx; */
        Model_Target_B.yy = Model_Target_B.Delay3 + Model_Target_B.xx;

        /* S-Function (TOP_MEX): '<S1764>/TOP' incorporates:
         *  Selector: '<S1611>/Selector2'
         */
        /* 'pooliir:34' b1   = coeffs(coeffIdx); */
        /* 'pooliir:34' coeffIdx = coeffIdx+1; */
        /* 'pooliir:35' w1  = b1*xx; */
        rtb_Switch_iy = Model_Target_Near_p0_b0.Coefficients[(int32_T)
            ((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) + 1.0) - 1];
        Model_Target_B.Delay3 = rtb_Switch_iy * Model_Target_B.xx;

        /*  main loop: 5 ops/sample */
        /* 'pooliir:38' i = 1; */
        /* 'pooliir:39' while i <= frameMinus1 */
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 31;
                Model_Target_B.stateLen++)
        {
            /* 'pooliir:40' r  = a1*yy; */
            /* 'pooliir:40' w1 = w1+w2; */
            Model_Target_B.Delay3 += Model_Target_B.Max_g;

            /* 'pooliir:40' y(i,cha) = yy; */
            Model_Target_B.yIdx = Model_Target_B.stateLen +
                Model_Target_B.xpageoffset;
            Model_Target_B.y_a[Model_Target_B.yIdx] = Model_Target_B.yy;

            /* 'pooliir:41' q  = b2*xx; */
            Model_Target_B.q = Model_Target_Near_p0_b0.Coefficients[(int32_T)
                (((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] *
                Model_Target_B.xx;

            /* 'pooliir:41' w1 = w1-r; */
            /* 'pooliir:41' xx = x(i+1,cha); */
            /* 'pooliir:42' xx = xx*gain; */
            Model_Target_B.xx = Model_Target_B.Selector2_n[Model_Target_B.yIdx +
                1] * Model_Target_B.max_h;

            /* 'pooliir:43' w2 = a2*yy; */
            Model_Target_B.Max_g = Model_Target_B.a2 * Model_Target_B.yy;

            /* 'pooliir:43' yy = w1+xx; */
            Model_Target_B.yy = (Model_Target_B.Delay3 -
                                 Model_Target_Near_p0_b0.Coefficients[(int32_T)
                                 ((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] *
                                 Model_Target_B.yy) + Model_Target_B.xx;

            /* 'pooliir:44' w1 = b1*xx; */
            Model_Target_B.Delay3 = rtb_Switch_iy * Model_Target_B.xx;

            /* 'pooliir:44' w2 = q-w2; */
            Model_Target_B.Max_g = Model_Target_B.q - Model_Target_B.Max_g;

            /* 'pooliir:44' i = i + 1; */
        }

        /*  epilogue: drain pipe and write states */
        /* 'pooliir:48' r  = a1*yy; */
        /* 'pooliir:48' w1 = w1+w2; */
        /* 'pooliir:48' y(frameMinus1+1,cha) = yy; */
        Model_Target_B.y_a[Model_Target_B.xpageoffset + 31] = Model_Target_B.yy;

        /* 'pooliir:49' q  = b2*xx; */
        /* 'pooliir:49' w1 = w1-r; */
        Model_Target_DW.states[(int32_T)(Model_Target_B.vncBoostGain - 1.0) - 1]
            = (Model_Target_B.Delay3 + Model_Target_B.Max_g) -
            Model_Target_Near_p0_b0.Coefficients[(int32_T)
            ((Model_Target_B.Switch1 + 1.0) + 1.0) - 1] * Model_Target_B.yy;

        /* 'pooliir:50' w2 = a2*yy; */
        /* 'pooliir:50' states(stateIdx) = w1; */
        /* 'pooliir:50' stateIdx = stateIdx+1; */
        /* 'pooliir:51' w2 = q-w2; */
        Model_Target_DW.states[(int32_T)(Model_Target_B.vncBoostGain_d + 1.0) -
            1] = Model_Target_Near_p0_b0.Coefficients[(int32_T)
            (((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0) - 1] *
            Model_Target_B.xx - Model_Target_B.a2 * Model_Target_B.yy;

        /* 'pooliir:51' states(stateIdx) = w2; */
        /* 'pooliir:51' stateIdx = stateIdx+1; */
        Model_Target_B.vncBoostGain_d = (Model_Target_B.vncBoostGain_d + 1.0) +
            1.0;

        /*  NOTE: asm implementation needs to exit here if it's only */
        /*  one stage, NOTE: all subsequent stages work in-place */
        /* 'pooliir:55' for st = 2:numStages(cha) */
        Model_Target_B.b = Model_Target_Near_p0_b0.NumStages[Model_Target_B.c];
        for (Model_Target_B.st = 2U; Model_Target_B.st <= Model_Target_B.b;
                Model_Target_B.st++)
        {
            /*  prologue: get coefficients, states and input vector,  */
            /*  and perform some computations */
            /* 'pooliir:58' w1 = states(stateIdx); */
            Model_Target_B.Delay3 = Model_Target_DW.states[(int32_T)
                Model_Target_B.vncBoostGain_d - 1];

            /* 'pooliir:58' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain = Model_Target_B.vncBoostGain_d + 1.0;

            /* 'pooliir:59' a2 = coeffs(coeffIdx); */
            Model_Target_B.a2_tmp = (((((Model_Target_B.Switch1 + 1.0) + 1.0) +
                1.0) + 1.0) + 1.0) + ((real_T)Model_Target_B.st - 2.0) * 4.0;
            Model_Target_B.a2 = Model_Target_Near_p0_b0.Coefficients[(int32_T)
                Model_Target_B.a2_tmp - 1];

            /* 'pooliir:59' coeffIdx = coeffIdx+1; */
            /* 'pooliir:60' w2 = states(stateIdx); */
            Model_Target_B.Max_g = Model_Target_DW.states[(int32_T)
                (Model_Target_B.vncBoostGain_d + 1.0) - 1];

            /* 'pooliir:60' stateIdx = stateIdx-1; */
            Model_Target_B.vncBoostGain_d = (Model_Target_B.vncBoostGain_d + 1.0)
                - 1.0;

            /* 'pooliir:61' a1 = coeffs(coeffIdx); */
            Model_Target_B.max_h = Model_Target_Near_p0_b0.Coefficients[(int32_T)
                (Model_Target_B.a2_tmp + 1.0) - 1];

            /* 'pooliir:61' coeffIdx = coeffIdx+1; */
            /* 'pooliir:62' xx = y(1,cha); */
            Model_Target_B.xx = Model_Target_B.y_a[Model_Target_B.xpageoffset];

            /* 'pooliir:62' b2 = coeffs(coeffIdx); */
            /* 'pooliir:62' coeffIdx = coeffIdx+1; */
            /* 'pooliir:63' yy = w1+xx; */
            Model_Target_B.yy = Model_Target_B.xx + Model_Target_B.Delay3;

            /* 'pooliir:63' b1 = coeffs(coeffIdx); */
            /* 'pooliir:63' coeffIdx = coeffIdx+1; */
            /* 'pooliir:64' w1 = b1*xx; */
            rtb_Switch_iy = Model_Target_Near_p0_b0.Coefficients[(int32_T)
                (((Model_Target_B.a2_tmp + 1.0) + 1.0) + 1.0) - 1];
            Model_Target_B.Delay3 = rtb_Switch_iy * Model_Target_B.xx;

            /*  main loop: 4 ops/sample */
            /* 'pooliir:67' i = 1; */
            /* 'pooliir:68' while i <= frameMinus1 */
            for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 31;
                    Model_Target_B.stateLen++)
            {
                /* 'pooliir:69' r  = a1*yy; */
                /* 'pooliir:69' w1 = w1+w2; */
                Model_Target_B.Delay3 += Model_Target_B.Max_g;

                /* 'pooliir:69' y(i,cha) = yy; */
                Model_Target_B.y_a[Model_Target_B.stateLen + (Model_Target_B.c <<
                    5)] = Model_Target_B.yy;

                /* 'pooliir:70' q  = b2*xx; */
                Model_Target_B.q = Model_Target_Near_p0_b0.Coefficients[(int32_T)
                    ((Model_Target_B.a2_tmp + 1.0) + 1.0) - 1] *
                    Model_Target_B.xx;

                /* 'pooliir:70' w1 = w1-r ; */
                /* 'pooliir:70' xx = y(i+1,cha); */
                Model_Target_B.xx = Model_Target_B.y_a[((Model_Target_B.c << 5)
                    + Model_Target_B.stateLen) + 1];

                /* 'pooliir:71' w2 = a2*yy; */
                Model_Target_B.Max_g = Model_Target_B.a2 * Model_Target_B.yy;

                /* 'pooliir:71' yy = w1+xx; */
                Model_Target_B.yy = (Model_Target_B.Delay3 -
                                     Model_Target_B.max_h * Model_Target_B.yy) +
                    Model_Target_B.xx;

                /* 'pooliir:72' w1 = b1*xx; */
                Model_Target_B.Delay3 = Model_Target_B.xx * rtb_Switch_iy;

                /* 'pooliir:72' w2 = q-w2; */
                Model_Target_B.Max_g = Model_Target_B.q - Model_Target_B.Max_g;

                /* 'pooliir:72' i = i + 1; */
            }

            /*  epilogue: drain pipe and write states */
            /* 'pooliir:76' r  = a1*yy; */
            /* 'pooliir:76' w1 = w1+w2; */
            /* 'pooliir:76' y(frameMinus1+1,cha) = yy; */
            Model_Target_B.y_a[Model_Target_B.xpageoffset + 31] =
                Model_Target_B.yy;

            /* 'pooliir:77' q  = b2*xx; */
            /* 'pooliir:77' w1 = w1-r; */
            Model_Target_DW.states[(int32_T)(Model_Target_B.vncBoostGain - 1.0)
                - 1] = (Model_Target_B.Delay3 + Model_Target_B.Max_g) -
                Model_Target_B.max_h * Model_Target_B.yy;

            /* 'pooliir:78' w2 = a2*yy; */
            /* 'pooliir:78' states(stateIdx) = w1; */
            /* 'pooliir:78' stateIdx = stateIdx+1; */
            /* 'pooliir:79' w2 = q-w2; */
            Model_Target_DW.states[(int32_T)(Model_Target_B.vncBoostGain_d + 1.0)
                - 1] = Model_Target_Near_p0_b0.Coefficients[(int32_T)
                ((Model_Target_B.a2_tmp + 1.0) + 1.0) - 1] * Model_Target_B.xx -
                Model_Target_B.a2 * Model_Target_B.yy;

            /* 'pooliir:79' states(stateIdx) = w2; */
            /* 'pooliir:79' stateIdx = stateIdx+1; */
            Model_Target_B.vncBoostGain_d = (Model_Target_B.vncBoostGain_d + 1.0)
                + 1.0;
        }

        Model_Target_B.Switch1 = (((((Model_Target_B.Switch1 + 1.0) + 1.0) + 1.0)
            + 1.0) + 1.0) + (((real_T)Model_Target_B.b - 2.0) + 1.0) * 4.0;
    }

    /* End of MATLAB Function: '<S1780>/PoolIirProcess' */

    /* Reshape: '<S1780>/Reshape' */
    memcpy(&Model_Target_B.LoRoLimpRimp[0], &Model_Target_B.y_a[0], sizeof
           (real32_T) << 6U);

    /* Outputs for Atomic SubSystem: '<S1763>/Ifir' */
    Model_Target_Ifir_k();

    /* End of Outputs for SubSystem: '<S1763>/Ifir' */

    /* Gain: '<S1765>/Gain' */
    memcpy(&NearBandSplit61633FirEvenInput[0], &Model_Target_B.FRIn[0], sizeof
           (real32_T) << 6U);

    /* MATLAB Function: '<S1768>/FirEvenProcess' incorporates:
     *  Constant: '<S1763>/Constant'
     *  Gain: '<S1765>/Gain'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenProcess': '<S1770>:1' */
    /* '<S1770>:1:4' [FilterLength, ~] = size(FlippedCoeffs); */
    /* '<S1770>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Initialize variables */
    /*  persistent States; */
    /*  if isempty(States) */
    /*      States = single(zeros(FilterLength + FrameSize*2 + 2, NumChannels)); */
    /*  end */
    /*  Set correct data types */
    /* '<S1770>:1:17' FilterLength = uint32(FilterLength); */
    /* '<S1770>:1:18' FrameSize = uint32(FrameSize); */
    /* '<S1770>:1:19' ActiveCoeffSet = uint32(ActiveCoeffSet); */
    /* '<S1770>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1770>:1:25' else */
    /*  FIR EVEN HEXAGON */
    /* '<S1770>:1:27' if (FilterLength > FrameSize) */
    /* '<S1770>:1:29' else */
    /* '<S1770>:1:30' y = fireven_hexagon_process_lt(single(u), uint32(ActiveCoeffSet), single(States), uint32(CodeWorkMemory)); */
    fireven_process_lt(&Model_Target_B.Selector2_n[0],
                       &NearBandSplit61633FirEvenInput[0],
                       &Model_Target_ConstP.pooled101[0],
                       &NearBandSplit41789States[0],
                       &NearBandSplit22278CodeWorkMemory[0]);
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 16;
            Model_Target_B.stateLen++)
    {
        /* DownSample: '<S1763>/Downsample' */
        Model_Target_B.Delay3 =
            Model_Target_B.Selector2_n[Model_Target_B.stateLen << 2];

        /* SignalConversion generated from: '<S1613>/Headrest Matrix Concatenate' */
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.stateLen] =
            Model_Target_B.Delay3;

        /* SignalConversion generated from: '<S1613>/Headrest Matrix Concatenate' */
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.stateLen + 16]
            = Model_Target_B.Delay3;

        /* DownSample: '<S1763>/Downsample' */
        Model_Target_B.Downsample[Model_Target_B.stateLen] =
            Model_Target_B.Delay3;
    }

    /* MATLAB Function: '<S1635>/MATLAB Function' incorporates:
     *  Concatenate: '<S1613>/Headrest Matrix Concatenate'
     *  S-Function (TOP_MEX): '<S1637>/TOP'
     *  Selector: '<S1613>/HeadrestSelector'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S1638>:1' */
    /*  figure out the frame size and channel count */
    /* '<S1638>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S1638>:1:8' frameSize = int32(frameSize); */
    /* '<S1638>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S1638>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S1638>:1:11' delayTime = int32(delayTime); */
    /* '<S1638>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1638>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1638>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex_i;

    /* '<S1638>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        Model_Target_B.delayTime[Model_Target_B.yIdx] = (int32_T)roundf
            (Model_Target_Near_p0_b0.Dr_eqdelays[Model_Target_B.yIdx]);

        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S1638>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0,
            2080);

        /* '<S1638>:1:32' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 8;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1638>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_p[Model_Target_B.writeIndex] =
                Model_Target_B.HeadrestMatrixConcatenate_a[(Model_Target_B.yIdx <<
                3) + Model_Target_B.sample];

            /*  increment write pointer */
            /* '<S1638>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                2080);
        }

        /*  Advance buffer index for next channel */
        /* '<S1638>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 520,
            2080);
    }

    /*  Reset */
    /* '<S1638>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex_i, 8, 2080);

    /* '<S1638>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_i = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S1638>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S1638>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_B.delayTime[Model_Target_B.yIdx] + 8), 2080);

        /* '<S1638>:1:55' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 8;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1638>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.sample +
                (Model_Target_B.yIdx << 3)] =
                Model_Target_DW.delayBuffer_p[Model_Target_B.writeIndex];

            /*  increment write pointer */
            /* '<S1638>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                2080);
        }

        /*  Advance buffer index for next channel */
        /* '<S1638>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 520,
            2080);
    }

    /* End of MATLAB Function: '<S1635>/MATLAB Function' */

    /* Gain: '<S1636>/Gain' */
    memcpy(&NearHrEqDr5320PoolIirAudioIn[0],
           &Model_Target_B.HeadrestMatrixConcatenate_a[0], sizeof(real32_T) <<
           5U);

    /* MATLAB Function: '<S1642>/PoolIirProcess' incorporates:
     *  Gain: '<S1636>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1646>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1646>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1646>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1646>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1646>:1:29' else */
    /* '<S1646>:1:30' switch(VariantStr) */
    /* '<S1646>:1:31' case{"Hexagon"} */
    /* '<S1646>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&NearHrEqDr38590PoolIirAudioOut[0],
                    &NearHrEqDr5320PoolIirAudioIn[0], &NearHrEqDr16726states[0]);

    /* Selector: '<S1613>/DriverSelector' */
    memcpy(&Model_Target_B.DriverSelector[0], &NearHrEqDr38590PoolIirAudioOut[0],
           sizeof(real32_T) << 4U);

    /* Selector: '<S1613>/PassengerSelector' */
    memcpy(&Model_Target_B.PassengerSelector[0],
           &NearHrEqDr38590PoolIirAudioOut[16], sizeof(real32_T) << 4U);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1736>/RTC Request Response Trigger' */

    /* SignalConversion generated from: '<S1609>/Vector Concatenate2' */
    Model_Target_B.VectorConcatenate2_c[0] =
        Model_TargetNearChannel1_LocationRtcOut.REQ_loc[0];
    Model_Target_B.VectorConcatenate2_c[1] =
        Model_TargetNearChannel1_LocationRtcOut.REQ_loc[1];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1735>/RTC Request Response Trigger' */

    /* SignalConversion generated from: '<S1609>/Vector Concatenate2' */
    Model_Target_B.VectorConcatenate2_c[2] =
        Model_TargetNearChannel2_LocationRtcOut.REQ_loc[0];
    Model_Target_B.VectorConcatenate2_c[3] =
        Model_TargetNearChannel2_LocationRtcOut.REQ_loc[1];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1738>/RTC Request Response Trigger' */

    /* SignalConversion generated from: '<S1609>/Vector Concatenate2' */
    Model_Target_B.VectorConcatenate2_c[4] =
        Model_TargetNearChannel3_LocationRtcOut.REQ_loc[0];
    Model_Target_B.VectorConcatenate2_c[5] =
        Model_TargetNearChannel3_LocationRtcOut.REQ_loc[1];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1737>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S1608>/MATLAB Function' incorporates:
     *  Concatenate: '<S1609>/Vector Concatenate2'
     *  Constant: '<S1608>/Constant'
     *  Selector: '<S1608>/Selector'
     */
    Model_Target_MATLABFunction_j(Model_Target_B.VectorConcatenate2_c[0],
        Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[0],
        &Model_Target_DW.sf_MATLABFunction_j4);

    /* MATLAB Function: '<S1608>/MATLAB Function1' incorporates:
     *  Concatenate: '<S1609>/Vector Concatenate2'
     *  Constant: '<S1608>/Constant'
     *  Selector: '<S1608>/Selector1'
     */
    Model_Target_MATLABFunction_j(Model_Target_B.VectorConcatenate2_c[1],
        Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[1],
        &Model_Target_DW.sf_MATLABFunction1_io);

    /* MATLAB Function: '<S1608>/MATLAB Function3' incorporates:
     *  Concatenate: '<S1609>/Vector Concatenate2'
     *  Constant: '<S1608>/Constant'
     *  Selector: '<S1608>/Selector2'
     */
    Model_Target_MATLABFunction_j(Model_Target_B.VectorConcatenate2_c[2],
        Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[2],
        &Model_Target_DW.sf_MATLABFunction3);

    /* MATLAB Function: '<S1608>/MATLAB Function2' incorporates:
     *  Concatenate: '<S1609>/Vector Concatenate2'
     *  Constant: '<S1608>/Constant'
     *  Selector: '<S1608>/Selector3'
     */
    Model_Target_MATLABFunction_j(Model_Target_B.VectorConcatenate2_c[3],
        Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[3],
        &Model_Target_DW.sf_MATLABFunction2);

    /* MATLAB Function: '<S1608>/MATLAB Function4' incorporates:
     *  Concatenate: '<S1609>/Vector Concatenate2'
     *  Constant: '<S1608>/Constant'
     *  Selector: '<S1608>/Selector4'
     */
    Model_Target_MATLABFunction_j(Model_Target_B.VectorConcatenate2_c[4],
        Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[4],
        &Model_Target_DW.sf_MATLABFunction4);

    /* MATLAB Function: '<S1608>/MATLAB Function5' incorporates:
     *  Concatenate: '<S1609>/Vector Concatenate2'
     *  Constant: '<S1608>/Constant'
     *  Selector: '<S1608>/Selector5'
     */
    Model_Target_MATLABFunction_j(Model_Target_B.VectorConcatenate2_c[5],
        Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
        &Model_Target_B.MatrixConcatenate4[5],
        &Model_Target_DW.sf_MATLABFunction5);

    /* MATLAB Function: '<S1608>/MATLAB Function6' incorporates:
     *  Constant: '<S1608>/Constant'
     *  SignalConversion generated from: '<S1609>/Vector Concatenate2'
     */
    Model_Target_MATLABFunction_j
        (Model_TargetNearChannel4_LocationRtcOut.REQ_loc[0],
         Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
         &Model_Target_B.MatrixConcatenate4[6],
         &Model_Target_DW.sf_MATLABFunction6);

    /* MATLAB Function: '<S1608>/MATLAB Function7' incorporates:
     *  Constant: '<S1608>/Constant'
     *  SignalConversion generated from: '<S1609>/Vector Concatenate2'
     */
    Model_Target_MATLABFunction_j
        (Model_TargetNearChannel4_LocationRtcOut.REQ_loc[1],
         Model_Target_Near_p0_b0.RampDbPerSample, 0.01,
         &Model_Target_B.MatrixConcatenate4[7],
         &Model_Target_DW.sf_MATLABFunction7);

    /* MATLAB Function: '<S1615>/MATLAB Function' incorporates:
     *  Concatenate: '<S1608>/Matrix Concatenate4'
     *  Constant: '<S1615>/Constant'
     *  DownSample: '<S1763>/Downsample'
     *  S-Function (TOP_MEX): '<S1667>/TOP'
     *  Selector: '<S1613>/DriverSelector'
     *  Selector: '<S1613>/PassengerSelector'
     */
    /*  % Inputs % Parameters */
    /* MATLAB Function 'NEAR/Near1p1/DrProc/Upmixer1p1Dr/MATLAB Function': '<S1666>:1' */
    /* '<S1666>:1:4' frameSize   = size(FrontAudioIn, 1); */
    /* '<S1666>:1:5' NonHr       = single(zeros(frameSize, FrontPeripheralChannelCount)); */
    memset(&Model_Target_B.NonHr_j[0], 0, 56U * sizeof(real32_T));

    /* '<S1666>:1:6' Hr          = single(zeros(frameSize, ChannelsPerHeadrest*HeadrestCount)); */
    memset(&Model_Target_B.Hr_p[0], 0, 224U * sizeof(real32_T));

    /* '<S1666>:1:8' for k = 1:AnnChannelCount */
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        /* '<S1666>:1:9' for j = 1:FrontPeripheralChannelCount */
        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 7;
                Model_Target_B.xpageoffset++)
        {
            /*              NonHr(:,j) = FrontAudioIn(:,1); */
            /* '<S1666>:1:11' NonHr(:,j) = NonHr(:,j) + Mixer(FrontAudioIn(:,k), Loc(:,:,k), mix(:,:,j), interp); */
            Model_Target_Mixer(&Model_Target_B.Downsample[Model_Target_B.c << 3],
                               &Model_Target_B.MatrixConcatenate4[Model_Target_B.c
                               << 1], &(Model_Target_Near_p0_b0.Dr_mix[25 *
                                Model_Target_B.xpageoffset]), 1.0,
                               Model_Target_B.VectorConcatenate2_c);
            for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 8;
                    Model_Target_B.yIdx++)
            {
                Model_Target_B.stateLen = (Model_Target_B.xpageoffset << 3) +
                    Model_Target_B.yIdx;
                Model_Target_B.NonHr_j[Model_Target_B.stateLen] +=
                    Model_Target_B.VectorConcatenate2_c[Model_Target_B.yIdx];
            }
        }

        /* '<S1666>:1:14' for j = 1:ChannelsPerHeadrest */
        /* '<S1666>:1:19' if HeadrestCount == 2 */
        /* '<S1666>:1:20' for j = 1:ChannelsPerHeadrest */
        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 14;
                Model_Target_B.xpageoffset++)
        {
            /*              Hr(:,j) = DriverAudioIn(:,1); */
            /* '<S1666>:1:16' Hr(:,j) = Hr(:,j) + Mixer(DriverAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount), interp); */
            Model_Target_B.yIdx = Model_Target_B.c << 3;
            Model_Target_B.stateLen = Model_Target_B.c << 1;
            Model_Target_Mixer
                (&Model_Target_B.DriverSelector[Model_Target_B.yIdx],
                 &Model_Target_B.MatrixConcatenate4[Model_Target_B.stateLen],
                 &(Model_Target_Near_p0_b0.Dr_mix[(Model_Target_B.xpageoffset +
                   7) * 25]), 1.0, Model_Target_B.VectorConcatenate2_c);

            /*                  Hr(:,j+channels_per_headrest) = PassengerAudioIn(:,1); */
            /* '<S1666>:1:22' Hr(:,j+ChannelsPerHeadrest) = Hr(:,j+ChannelsPerHeadrest) + Mixer(PassengerAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount+ChannelsPerHeadrest), interp); */
            Model_Target_Mixer
                (&Model_Target_B.PassengerSelector[Model_Target_B.yIdx],
                 &Model_Target_B.MatrixConcatenate4[Model_Target_B.stateLen],
                 &(Model_Target_Near_p0_b0.Dr_mix[(Model_Target_B.xpageoffset +
                   21) * 25]), 1.0, Model_Target_B.fv);
            for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 8;
                    Model_Target_B.yIdx++)
            {
                Model_Target_B.stateLen = (Model_Target_B.xpageoffset << 3) +
                    Model_Target_B.yIdx;
                Model_Target_B.Hr_p[Model_Target_B.stateLen] +=
                    Model_Target_B.VectorConcatenate2_c[Model_Target_B.yIdx];
                Model_Target_B.stateLen = ((Model_Target_B.xpageoffset + 14) <<
                    3) + Model_Target_B.yIdx;
                Model_Target_B.Hr_p[Model_Target_B.stateLen] +=
                    Model_Target_B.fv[Model_Target_B.yIdx];
            }
        }
    }

    /* End of MATLAB Function: '<S1615>/MATLAB Function' */
    /* MATLAB Function: '<S1616>/MATLAB Function' incorporates:
     *  S-Function (TOP_MEX): '<S1618>/TOP'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S1619>:1' */
    /*  figure out the frame size and channel count */
    /* '<S1619>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S1619>:1:8' frameSize = int32(frameSize); */
    /* '<S1619>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S1619>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S1619>:1:11' delayTime = int32(delayTime); */
    /* '<S1619>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1619>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1619>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex_f;

    /* '<S1619>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 7; Model_Target_B.yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S1619>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0,
            3640);

        /* '<S1619>:1:32' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 8;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1619>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer[Model_Target_B.writeIndex] =
                Model_Target_B.NonHr_j[(Model_Target_B.yIdx << 3) +
                Model_Target_B.sample];

            /*  increment write pointer */
            /* '<S1619>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                3640);
        }

        /*  Advance buffer index for next channel */
        /* '<S1619>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 520,
            3640);
    }

    /*  Reset */
    /* '<S1619>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex_f, 8, 3640);

    /* '<S1619>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_f = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S1619>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 7; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S1619>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_Near_p0_b0.Dr_EqDelays[Model_Target_B.yIdx] + 8),
            3640);

        /* '<S1619>:1:55' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 8;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1619>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.NonHr_j[Model_Target_B.sample + (Model_Target_B.yIdx <<
                3)] = Model_Target_DW.delayBuffer[Model_Target_B.writeIndex];

            /*  increment write pointer */
            /* '<S1619>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                3640);
        }

        /*  Advance buffer index for next channel */
        /* '<S1619>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 520,
            3640);
    }

    /* End of MATLAB Function: '<S1616>/MATLAB Function' */

    /* Gain: '<S1617>/Gain' */
    memcpy(&NearFsDrEq17368PoolIirAudioIn[0], &Model_Target_B.NonHr_j[0], 56U *
           sizeof(real32_T));

    /* End of Outputs for S-Function (InitTriggerControl): '<S1632>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1624>/ITC1' */

    /* MATLAB Function: '<S1623>/PoolIirProcess' incorporates:
     *  Gain: '<S1617>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1627>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1627>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1627>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1627>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1627>:1:29' else */
    /* '<S1627>:1:30' switch(VariantStr) */
    /* '<S1627>:1:31' case{"Hexagon"} */
    /* '<S1627>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&NearFsDrEq7346PoolIirAudioOut[0],
                    &NearFsDrEq17368PoolIirAudioIn[0], &NearFsDrEq33283states[0]);

    /* End of Outputs for S-Function (InitTriggerControl): '<S1651>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1643>/ITC1' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1656>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S1654>/MATLAB Function' */
    Model_Target_MATLABFunction_m(&(Model_Target_Near_p0_b0.Dr_RouterOutMap[0]),
        &(Model_TargetNearDr_RouterSetRtcOut.REQ_routerMap[0]),
        &Model_Target_B.sf_MATLABFunction_ma);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1604>/RTC Request Response Trigger' */

    /* Switch: '<S1606>/Switch1' incorporates:
     *  Constant: '<S1606>/Constant'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 56;
            Model_Target_B.xpageoffset++)
    {
        if (Model_TargetNearEnableRtcOut.REQ_Enable != 0U)
        {
            Model_Target_B.NonHr_j[Model_Target_B.xpageoffset] =
                NearFsDrEq7346PoolIirAudioOut[Model_Target_B.xpageoffset];
        }
        else
        {
            Model_Target_B.NonHr_j[Model_Target_B.xpageoffset] = 0.0F;
        }
    }

    /* End of Switch: '<S1606>/Switch1' */

    /* S-Function (sdspperm2): '<S1657>/Variable Selector' incorporates:
     *  Switch: '<S1606>/Switch1'
     */
    for (Model_Target_B.c = 0; Model_Target_B.c < 18; Model_Target_B.c++)
    {
        Model_Target_B.xpageoffset =
            Model_Target_B.sf_MATLABFunction_ma.routerMapOut[Model_Target_B.c];
        if (Model_Target_B.sf_MATLABFunction_ma.routerMapOut[Model_Target_B.c] -
            1 < 0)
        {
            Model_Target_B.xpageoffset = 1;
        }
        else if (Model_Target_B.sf_MATLABFunction_ma.routerMapOut[Model_Target_B.c]
                 - 1 >= 7)
        {
            Model_Target_B.xpageoffset = 7;
        }

        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.MatrixMultiply_b[(Model_Target_B.c << 3) +
                Model_Target_B.stateLen] = Model_Target_B.NonHr_j
                [((Model_Target_B.xpageoffset - 1) << 3) +
                Model_Target_B.stateLen];
        }
    }

    /* End of S-Function (sdspperm2): '<S1657>/Variable Selector' */

    /* Logic: '<S1657>/OR' incorporates:
     *  Constant: '<S1664>/Constant'
     *  Constant: '<S1665>/Constant'
     *  RelationalOperator: '<S1664>/Compare'
     *  RelationalOperator: '<S1665>/Compare'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 18;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.OR_f[Model_Target_B.xpageoffset] =
            ((Model_Target_B.sf_MATLABFunction_ma.routerMapOut[Model_Target_B.xpageoffset]
              <= 0) ||
             (Model_Target_B.sf_MATLABFunction_ma.routerMapOut[Model_Target_B.xpageoffset]
              > 10));
    }

    /* End of Logic: '<S1657>/OR' */

    /* Find: '<S1657>/Find Nonzero Elements' incorporates:
     *  Logic: '<S1657>/OR'
     */
    Model_Target_B.stateLen = 0;
    Model_Target_B.c = 0;
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 18;
            Model_Target_B.xpageoffset++)
    {
        if (Model_Target_B.OR_f[Model_Target_B.c])
        {
            Model_Target_B.FindNonzeroElements_n[Model_Target_B.stateLen] =
                (int8_T)(Model_Target_B.xpageoffset + 1);
            Model_Target_B.stateLen++;
        }

        Model_Target_B.c++;
    }

    Model_Target_DW.FindNonzeroElements_DIMS1 = Model_Target_B.stateLen;

    /* End of Find: '<S1657>/Find Nonzero Elements' */

    /* Assignment: '<S1657>/Assignment' incorporates:
     *  Constant: '<S1657>/Constant3'
     *  Find: '<S1657>/Find Nonzero Elements'
     */
    memcpy(&Model_Target_B.Assignment_b[0], &Model_Target_B.MatrixMultiply_b[0],
           144U * sizeof(real32_T));
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx <
            Model_Target_DW.FindNonzeroElements_DIMS1; Model_Target_B.yIdx++)
    {
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Assignment_b[Model_Target_B.stateLen +
                ((Model_Target_B.FindNonzeroElements_n[Model_Target_B.yIdx] - 1)
                 << 3)] = 0.0F;
        }
    }

    /* End of Assignment: '<S1657>/Assignment' */

    /* Switch: '<S1606>/Switch3' incorporates:
     *  Constant: '<S1606>/Constant'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 224;
            Model_Target_B.xpageoffset++)
    {
        if (Model_TargetNearEnableRtcOut.REQ_Enable != 0U)
        {
            Model_Target_B.FRIn[Model_Target_B.xpageoffset] =
                Model_Target_B.Hr_p[Model_Target_B.xpageoffset];
        }
        else
        {
            Model_Target_B.FRIn[Model_Target_B.xpageoffset] = 0.0F;
        }
    }

    /* End of Switch: '<S1606>/Switch3' */

    /* S-Function (sdspupfir2): '<S1763>/Reconstruction Filter' incorporates:
     *  DownSample: '<S1763>/Downsample'
     *  DownSample: '<S256>/Downsample2'
     */
    /* Loop over each input channel */
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        Model_Target_B.yIdx = Model_Target_B.c * 33;
        Model_Target_B.writeIndex = Model_Target_B.c << 3;
        Model_Target_B.sample = Model_Target_B.writeIndex << 2;
        for (Model_Target_B.m = 0; Model_Target_B.m < 4; Model_Target_B.m++)
        {
            Model_Target_B.oIdx = Model_Target_B.sample + Model_Target_B.m;
            Model_Target_B.coefArrayIdx = Model_Target_B.m * 34;

            /* Consume delay line and beginning of input samples */
            for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                    Model_Target_B.stateLen++)
            {
                Model_Target_B.Delay3 = 0.0F;
                Model_Target_B.xpageoffset = 0;
                while (Model_Target_B.xpageoffset < Model_Target_B.stateLen + 1)
                {
                    Model_Target_B.Delay3 += Model_Target_B.Downsample
                        [(Model_Target_B.writeIndex + Model_Target_B.stateLen) -
                        Model_Target_B.xpageoffset] *
                        Model_Target_ConstP.ReconstructionFilter_FILTER_COEFF_n[Model_Target_B.coefArrayIdx
                        + Model_Target_B.xpageoffset];
                    Model_Target_B.xpageoffset++;
                }

                Model_Target_B.xpageoffset = 0;
                while (Model_Target_B.xpageoffset < 33 - Model_Target_B.stateLen)
                {
                    Model_Target_B.Delay3 +=
                        Model_Target_ConstP.ReconstructionFilter_FILTER_COEFF_n
                        [((Model_Target_B.coefArrayIdx + Model_Target_B.stateLen)
                          + Model_Target_B.xpageoffset) + 1] *
                        Model_Target_DW.ReconstructionFilter_TapDelayBuff[Model_Target_B.yIdx
                        + Model_Target_B.xpageoffset];
                    Model_Target_B.xpageoffset++;
                }

                Model_Target_B.Downsample2[Model_Target_B.oIdx] =
                    Model_Target_B.Delay3;
                Model_Target_B.oIdx += 4;
            }
        }

        /* Update delay line for next frame */
        Model_Target_B.stateLen = Model_Target_B.yIdx + 24;
        while (Model_Target_B.stateLen >= Model_Target_B.yIdx)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff[Model_Target_B.stateLen
                + 8] =
                Model_Target_DW.ReconstructionFilter_TapDelayBuff[Model_Target_B.stateLen];
            Model_Target_B.stateLen--;
        }

        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                Model_Target_B.stateLen++)
        {
            Model_Target_DW.ReconstructionFilter_TapDelayBuff
                [(Model_Target_B.yIdx - Model_Target_B.stateLen) + 7] =
                Model_Target_B.Downsample[Model_Target_B.writeIndex +
                Model_Target_B.stateLen];
        }
    }

    /* End of S-Function (sdspupfir2): '<S1763>/Reconstruction Filter' */

    /* Sum: '<S1763>/Sum' incorporates:
     *  Delay: '<S1763>/Band Separation Delay'
     *  DownSample: '<S256>/Downsample2'
     */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.c = (Model_Target_B.yIdx << 5) +
                Model_Target_B.stateLen;
            Model_Target_B.Sum_c[Model_Target_B.c] =
                Model_Target_DW.BandSeparationDelay_DSTATE[134 *
                Model_Target_B.yIdx + Model_Target_B.stateLen] -
                Model_Target_B.Downsample2[Model_Target_B.c];
        }
    }

    /* End of Sum: '<S1763>/Sum' */

    /* If: '<S1607>/If' incorporates:
     *  Assignment: '<S1715>/Assignment'
     *  Concatenate: '<S1608>/Matrix Concatenate4'
     *  Concatenate: '<S1671>/Headrest Matrix Concatenate'
     *  Constant: '<S1673>/Constant'
     *  Constant: '<S1715>/Constant3'
     *  Find: '<S1715>/Find Nonzero Elements'
     *  Gain: '<S1675>/Gain'
     *  Gain: '<S1694>/Gain'
     *  Logic: '<S1715>/OR'
     *  M-S-Function: '<S1669>/FeaturePath'
     *  M-S-Function: '<S1678>/FeaturePath'
     *  M-S-Function: '<S1697>/FeaturePath'
     *  M-S-Function: '<S1712>/FeaturePath'
     *  MATLAB Function: '<S1673>/MATLAB Function'
     *  MATLAB Function: '<S1674>/MATLAB Function'
     *  MATLAB Function: '<S1681>/PoolIirProcess'
     *  MATLAB Function: '<S1693>/MATLAB Function'
     *  MATLAB Function: '<S1700>/PoolIirProcess'
     *  MATLAB Function: '<S1712>/MATLAB Function'
     *  S-Function (AudioStats_MEX): '<S1678>/AudioStats'
     *  S-Function (AudioStats_MEX): '<S1697>/AudioStats'
     *  S-Function (TOP_MEX): '<S1676>/TOP'
     *  S-Function (TOP_MEX): '<S1678>/TOP'
     *  S-Function (TOP_MEX): '<S1678>/TOP1'
     *  S-Function (TOP_MEX): '<S1695>/TOP'
     *  S-Function (TOP_MEX): '<S1697>/TOP'
     *  S-Function (TOP_MEX): '<S1697>/TOP1'
     *  S-Function (TOP_MEX): '<S1712>/TOP'
     *  S-Function (TOP_MEX): '<S1725>/TOP'
     *  S-Function (sdspperm2): '<S1715>/Variable Selector'
     *  Selector: '<S1671>/DriverSelector'
     *  Selector: '<S1671>/HeadrestSelector'
     *  Selector: '<S1671>/PassengerSelector'
     *  SignalConversion generated from: '<S1671>/Headrest Matrix Concatenate'
     *  Sum: '<S1763>/Sum'
     */
    rtPrevAction = Model_Target_DW.If_ActiveSubsystem;
    Model_Target_DW.If_ActiveSubsystem = 0;
    if (rtPrevAction != 0)
    {
        if (rtPrevAction == 0)
        {
        }
    }

    /* Outputs for IfAction SubSystem: '<S1607>/Subsystem' incorporates:
     *  ActionPort: '<S1669>/Action Port'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 64;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.Delay3 = Model_Target_B.Sum_c[Model_Target_B.xpageoffset];

        /* SignalConversion generated from: '<S1671>/Headrest Matrix Concatenate' incorporates:
         *  Sum: '<S1763>/Sum'
         */
        Model_Target_B.VectorConcatenate1[Model_Target_B.xpageoffset] =
            Model_Target_B.Delay3;

        /* SignalConversion generated from: '<S1671>/Headrest Matrix Concatenate' */
        Model_Target_B.VectorConcatenate1[Model_Target_B.xpageoffset + 64] =
            Model_Target_B.Delay3;
    }

    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S1696>:1' */
    /*  figure out the frame size and channel count */
    /* '<S1696>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S1696>:1:8' frameSize = int32(frameSize); */
    /* '<S1696>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S1696>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S1696>:1:11' delayTime = int32(delayTime); */
    /* '<S1696>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1696>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1696>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex;

    /* '<S1696>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        Model_Target_B.delayTime[Model_Target_B.yIdx] = (int32_T)roundf
            (Model_Target_Near_p0_b0.Fr_eqdelays[Model_Target_B.yIdx]);

        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S1696>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0,
            2176);

        /* '<S1696>:1:32' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1696>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_m[Model_Target_B.writeIndex] =
                Model_Target_B.VectorConcatenate1[(Model_Target_B.yIdx << 5) +
                Model_Target_B.sample];

            /*  increment write pointer */
            /* '<S1696>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                2176);
        }

        /*  Advance buffer index for next channel */
        /* '<S1696>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 544,
            2176);
    }

    /*  Reset */
    /* '<S1696>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex, 32, 2176);

    /* '<S1696>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S1696>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S1696>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_B.delayTime[Model_Target_B.yIdx] + 32), 2176);

        /* '<S1696>:1:55' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1696>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.VectorConcatenate1[Model_Target_B.sample +
                (Model_Target_B.yIdx << 5)] =
                Model_Target_DW.delayBuffer_m[Model_Target_B.writeIndex];

            /*  increment write pointer */
            /* '<S1696>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                2176);
        }

        /*  Advance buffer index for next channel */
        /* '<S1696>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 544,
            2176);
    }

    memcpy(&NearHrEqFr38294PoolIirAudioIn[0],
           &Model_Target_B.VectorConcatenate1[0], sizeof(real32_T) << 7U);

    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1704>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1704>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1704>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1704>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1704>:1:29' else */
    /* '<S1704>:1:30' switch(VariantStr) */
    /* '<S1704>:1:31' case{"Hexagon"} */
    /* '<S1704>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&NearHrEqFr19PoolIirAudioOut[0],
                    &NearHrEqFr38294PoolIirAudioIn[0], &NearHrEqFr30301states[0]);
    memcpy(&Model_Target_B.Selector2_n[0], &NearHrEqFr19PoolIirAudioOut[0],
           sizeof(real32_T) << 6U);
    memcpy(&Model_Target_B.y_a[0], &NearHrEqFr19PoolIirAudioOut[64], sizeof
           (real32_T) << 6U);

    /*  % Inputs % Parameters */
    /* MATLAB Function 'NEAR/Near1p1/FrProc/Subsystem/Upmixer1p1Fr/MATLAB Function': '<S1724>:1' */
    /* '<S1724>:1:4' frameSize   = size(FrontAudioIn, 1); */
    /* '<S1724>:1:5' NonHr       = single(zeros(frameSize, FrontPeripheralChannelCount)); */
    memset(&Model_Target_B.MatrixMultiply_b[0], 0, 160U * sizeof(real32_T));

    /* '<S1724>:1:6' Hr          = single(zeros(frameSize, ChannelsPerHeadrest*HeadrestCount)); */
    memset(&Model_Target_B.VectorConcatenate1[0], 0, sizeof(real32_T) << 7U);

    /* '<S1724>:1:8' for k = 1:AnnChannelCount */
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        /* '<S1724>:1:9' for j = 1:FrontPeripheralChannelCount */
        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 5;
                Model_Target_B.xpageoffset++)
        {
            /*              NonHr(:,j) = FrontAudioIn(:,1); */
            /* '<S1724>:1:11' NonHr(:,j) = NonHr(:,j) + Mixer(FrontAudioIn(:,k), Loc(:,:,k), mix(:,:,j), interp); */
            Model_Target_Mixer_k(&Model_Target_B.Sum_c[Model_Target_B.c << 5],
                                 &Model_Target_B.MatrixConcatenate4[Model_Target_B.c
                                 << 1], &(Model_Target_Near_p0_b0.Fr_mix[25 *
                                  Model_Target_B.xpageoffset]), 1.0,
                                 Model_Target_B.HeadrestMatrixConcatenate_a);
            for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 32;
                    Model_Target_B.yIdx++)
            {
                Model_Target_B.stateLen = (Model_Target_B.xpageoffset << 5) +
                    Model_Target_B.yIdx;
                Model_Target_B.MatrixMultiply_b[Model_Target_B.stateLen] +=
                    Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx];
            }
        }

        /* '<S1724>:1:14' for j = 1:ChannelsPerHeadrest */
        /* '<S1724>:1:19' if HeadrestCount == 2 */
        /* '<S1724>:1:20' for j = 1:ChannelsPerHeadrest */
        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 2;
                Model_Target_B.xpageoffset++)
        {
            /*              Hr(:,j) = DriverAudioIn(:,1); */
            /* '<S1724>:1:16' Hr(:,j) = Hr(:,j) + Mixer(DriverAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount), interp); */
            Model_Target_B.yIdx = Model_Target_B.c << 5;
            Model_Target_B.stateLen = Model_Target_B.c << 1;
            Model_Target_Mixer_k(&Model_Target_B.Selector2_n[Model_Target_B.yIdx],
                                 &Model_Target_B.MatrixConcatenate4[Model_Target_B.stateLen],
                                 &(Model_Target_Near_p0_b0.Fr_mix
                                   [(Model_Target_B.xpageoffset + 5) * 25]), 1.0,
                                 Model_Target_B.HeadrestMatrixConcatenate_a);

            /*                  Hr(:,j+channels_per_headrest) = PassengerAudioIn(:,1); */
            /* '<S1724>:1:22' Hr(:,j+ChannelsPerHeadrest) = Hr(:,j+ChannelsPerHeadrest) + Mixer(PassengerAudioIn(:,k), Loc(:,:,k), mix(:,:,j+FrontPeripheralChannelCount+ChannelsPerHeadrest), interp); */
            Model_Target_Mixer_k(&Model_Target_B.y_a[Model_Target_B.yIdx],
                                 &Model_Target_B.MatrixConcatenate4[Model_Target_B.stateLen],
                                 &(Model_Target_Near_p0_b0.Fr_mix
                                   [(Model_Target_B.xpageoffset + 7) * 25]), 1.0,
                                 Model_Target_B.Merge_c);
            for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 32;
                    Model_Target_B.yIdx++)
            {
                Model_Target_B.stateLen = (Model_Target_B.xpageoffset << 5) +
                    Model_Target_B.yIdx;
                Model_Target_B.VectorConcatenate1[Model_Target_B.stateLen] +=
                    Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx];
                Model_Target_B.stateLen = ((Model_Target_B.xpageoffset + 2) << 5)
                    + Model_Target_B.yIdx;
                Model_Target_B.VectorConcatenate1[Model_Target_B.stateLen] +=
                    Model_Target_B.Merge_c[Model_Target_B.yIdx];
            }
        }
    }

    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'DelayPerChannel/MATLAB Function': '<S1677>:1' */
    /*  figure out the frame size and channel count */
    /* '<S1677>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S1677>:1:8' frameSize = int32(frameSize); */
    /* '<S1677>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S1677>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S1677>:1:11' delayTime = int32(delayTime); */
    /* '<S1677>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S1677>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S1677>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex_h;

    /* '<S1677>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 5; Model_Target_B.yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S1677>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0,
            2720);

        /* '<S1677>:1:32' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1677>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_a[Model_Target_B.writeIndex] =
                Model_Target_B.MatrixMultiply_b[(Model_Target_B.yIdx << 5) +
                Model_Target_B.sample];

            /*  increment write pointer */
            /* '<S1677>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                2720);
        }

        /*  Advance buffer index for next channel */
        /* '<S1677>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 544,
            2720);
    }

    /*  Reset */
    /* '<S1677>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex_h, 32,
        2720);

    /* '<S1677>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_h = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S1677>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 5; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S1677>:1:53' readIndex = circindex(bufferIndex, -(delayTime(channel)+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_Near_p0_b0.Fr_EqDelays[Model_Target_B.yIdx] + 32),
            2720);

        /* '<S1677>:1:55' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S1677>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.MatrixMultiply_b[Model_Target_B.sample +
                (Model_Target_B.yIdx << 5)] =
                Model_Target_DW.delayBuffer_a[Model_Target_B.writeIndex];

            /*  increment write pointer */
            /* '<S1677>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                2720);
        }

        /*  Advance buffer index for next channel */
        /* '<S1677>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 544,
            2720);
    }

    memcpy(&NearFsFrEq50753PoolIirAudioIn[0], &Model_Target_B.MatrixMultiply_b[0],
           160U * sizeof(real32_T));

    /* End of Outputs for S-Function (InitTriggerControl): '<S1690>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1682>/ITC1' */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S1685>:1' */
    /*  Extract configuration information from inputs */
    /* '<S1685>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S1685>:1:20' VariantStr = char(VariantUint8); */
    /* '<S1685>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1685>:1:29' else */
    /* '<S1685>:1:30' switch(VariantStr) */
    /* '<S1685>:1:31' case{"Hexagon"} */
    /* '<S1685>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&NearFsFrEq27702PoolIirAudioOut[0],
                    &NearFsFrEq50753PoolIirAudioIn[0], &NearFsFrEq11505states[0]);

    /* End of Outputs for S-Function (InitTriggerControl): '<S1709>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1701>/ITC1' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S1714>/RTC Request Response Trigger' */
    Model_Target_MATLABFunction_m(&(Model_Target_Near_p0_b0.Fr_RouterOutMap[0]),
        &(Model_TargetNearFr_RouterSetRtcOut.REQ_routerMap[0]),
        &Model_Target_B.sf_MATLABFunction_f2);

    /* End of Outputs for S-Function (RTC_NTF): '<S1714>/NTF Trigger' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 160;
            Model_Target_B.xpageoffset++)
    {
        /* Switch: '<S1669>/Switch1' incorporates:
         *  Constant: '<S1669>/Constant'
         */
        if (Model_TargetNearEnableRtcOut.REQ_Enable != 0U)
        {
            Model_Target_B.MatrixMultiply_b[Model_Target_B.xpageoffset] =
                NearFsFrEq27702PoolIirAudioOut[Model_Target_B.xpageoffset];
        }
        else
        {
            Model_Target_B.MatrixMultiply_b[Model_Target_B.xpageoffset] = 0.0F;
        }

        /* End of Switch: '<S1669>/Switch1' */
    }

    for (Model_Target_B.c = 0; Model_Target_B.c < 18; Model_Target_B.c++)
    {
        /* S-Function (sdspperm2): '<S1715>/Variable Selector' incorporates:
         *  Switch: '<S1669>/Switch1'
         */
        Model_Target_B.xpageoffset =
            Model_Target_B.sf_MATLABFunction_f2.routerMapOut[Model_Target_B.c];
        if (Model_Target_B.sf_MATLABFunction_f2.routerMapOut[Model_Target_B.c] -
            1 < 0)
        {
            Model_Target_B.xpageoffset = 1;
        }
        else if (Model_Target_B.sf_MATLABFunction_f2.routerMapOut[Model_Target_B.c]
                 - 1 >= 5)
        {
            Model_Target_B.xpageoffset = 5;
        }

        memcpy(&Model_Target_B.VariableSelector_k[Model_Target_B.c << 5],
               &Model_Target_B.MatrixMultiply_b[(Model_Target_B.xpageoffset << 5)
               + -32], sizeof(real32_T) << 5U);

        /* End of S-Function (sdspperm2): '<S1715>/Variable Selector' */
    }

    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 18;
            Model_Target_B.xpageoffset++)
    {
        /* Logic: '<S1715>/OR' incorporates:
         *  Constant: '<S1722>/Constant'
         *  Constant: '<S1723>/Constant'
         *  RelationalOperator: '<S1722>/Compare'
         *  RelationalOperator: '<S1723>/Compare'
         */
        Model_Target_B.OR_f[Model_Target_B.xpageoffset] =
            ((Model_Target_B.sf_MATLABFunction_f2.routerMapOut[Model_Target_B.xpageoffset]
              <= 0) ||
             (Model_Target_B.sf_MATLABFunction_f2.routerMapOut[Model_Target_B.xpageoffset]
              > 10));
    }

    Model_Target_B.stateLen = 0;
    Model_Target_B.c = 0;
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 18;
            Model_Target_B.xpageoffset++)
    {
        if (Model_Target_B.OR_f[Model_Target_B.c])
        {
            Model_Target_B.FindNonzeroElements_c[Model_Target_B.stateLen] =
                (int8_T)(Model_Target_B.xpageoffset + 1);
            Model_Target_B.stateLen++;
        }

        Model_Target_B.c++;
    }

    Model_Target_DW.FindNonzeroElements_DIMS1_f = Model_Target_B.stateLen;
    memcpy(&Model_Target_B.MatrixConcatenate_g[0],
           &Model_Target_B.VariableSelector_k[0], 576U * sizeof(real32_T));
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx <
            Model_Target_DW.FindNonzeroElements_DIMS1_f; Model_Target_B.yIdx++)
    {
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.MatrixConcatenate_g[Model_Target_B.stateLen +
                ((Model_Target_B.FindNonzeroElements_c[Model_Target_B.yIdx] - 1)
                 << 5)] = 0.0F;
        }
    }

    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 128;
            Model_Target_B.xpageoffset++)
    {
        /* Switch: '<S1669>/Switch3' incorporates:
         *  Constant: '<S1669>/Constant'
         */
        if (Model_TargetNearEnableRtcOut.REQ_Enable != 0U)
        {
            Model_Target_B.MatrixConcatenate_g[Model_Target_B.xpageoffset + 576]
                = Model_Target_B.VectorConcatenate1[Model_Target_B.xpageoffset];
        }
        else
        {
            Model_Target_B.MatrixConcatenate_g[Model_Target_B.xpageoffset + 576]
                = 0.0F;
        }

        /* End of Switch: '<S1669>/Switch3' */
    }

    /* End of Outputs for S-Function (InitTriggerControl): '<S1772>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1771>/ITC1' */

    /* MATLAB Function: '<S5>/MATLAB Function' */
    Model_Target_B.y = Model_TargetNearEnableRtcOut.REQ_Enable;

    /* Update for M-S-Function: '<S1876>/TSP' */
    /* MATLAB Function 'NEAR/MATLAB Function': '<S1602>:1' */
    /* '<S1602>:1:3' y = u; */
    // TSP advanced triggered capture for NearAnn1Ann1NonEntGainCalcGetNonEntBoostLeveldB '<S1876>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0100, 0, &Model_Target_B.Switch);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S1956>/TSP' */
    // TSP advanced triggered capture for NearAnn2Ann2NonEntGainCalcGetNonEntBoostLeveldB '<S1956>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0100, 1, &Model_Target_B.Switch_l);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S2036>/TSP' */
    // TSP advanced triggered capture for NearAnn3Ann3NonEntGainCalcGetNonEntBoostLeveldB '<S2036>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0100, 2, &Model_Target_B.Switch_g);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S2116>/TSP' */
    // TSP advanced triggered capture for NearAnn4Ann4NonEntGainCalcGetNonEntBoostLeveldB '<S2116>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0100, 3, &Model_Target_B.Switch_b);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for Delay: '<S1763>/Band Separation Delay' */
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 102;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.xpageoffset = Model_Target_B.c * 134 +
                Model_Target_B.stateLen;
            Model_Target_DW.BandSeparationDelay_DSTATE[Model_Target_B.xpageoffset]
                =
                Model_Target_DW.BandSeparationDelay_DSTATE[Model_Target_B.xpageoffset
                + 32];
        }
    }

    memcpy(&Model_Target_B.Selector2_n[0], &Model_Target_B.LoRoLimpRimp[0],
           sizeof(real32_T) << 6U);
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        memcpy(&Model_Target_DW.BandSeparationDelay_DSTATE[Model_Target_B.yIdx *
               134 + 102], &Model_Target_B.Selector2_n[Model_Target_B.yIdx << 5],
               sizeof(real32_T) << 5U);
    }

    /* End of Update for Delay: '<S1763>/Band Separation Delay' */
    /* End of Outputs for SubSystem: '<Root>/NEAR' */

    /* Outputs for Atomic SubSystem: '<S4>/PreAmpPart1' */
    Model_Target_PreAmpPart1();

    /* End of Outputs for SubSystem: '<S4>/PreAmpPart1' */

    /* Outputs for Atomic SubSystem: '<S4>/SrcDownMic' */
    Model_Target_SrcDownMicTID2();

    /* End of Outputs for SubSystem: '<S4>/SrcDownMic' */

    /* Outputs for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* SignalConversion generated from: '<S270>/Matrix Concatenate' incorporates:
     *  Concatenate: '<S270>/Matrix Concatenate'
     *  Constant: '<S270>/Constant'
     */
    Model_Target_B.MatrixConcatenate_j[10] = 0.0F;
    Model_Target_B.MatrixConcatenate_j[11] = 0.0F;

    /* S-Function (sdspsine2): '<S256>/Modulating Sine Wave' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.Downsample2[Model_Target_B.xpageoffset] =
            Model_Target_ConstP.ModulatingSineWave_Values_SineTable[Model_Target_DW.ModulatingSineWave_TableIdx];
        Model_Target_DW.ModulatingSineWave_TableIdx++;
        if (Model_Target_DW.ModulatingSineWave_TableIdx >= 10)
        {
            Model_Target_DW.ModulatingSineWave_TableIdx = 0U;
        }
    }

    /* End of S-Function (sdspsine2): '<S256>/Modulating Sine Wave' */

    /* Product: '<S256>/Matrix Multiply' incorporates:
     *  Constant: '<S256>/Constant'
     */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 5; Model_Target_B.yIdx++)
    {
        memcpy(&Model_Target_B.MatrixMultiply_b[Model_Target_B.yIdx << 5],
               &Model_Target_B.Downsample2[0], sizeof(real32_T) << 5U);
    }

    /* End of Product: '<S256>/Matrix Multiply' */

    /* SignalConversion generated from: '<S256>/Matrix Concatenate' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function'
     */
    memcpy(&HFBPFilt37133PoolIirAudioIn[0], &Model_Target_B.SFunction_l[0],
           sizeof(real32_T) << 5U);

    /* Delay: '<S32>/Delay2' */
    memcpy(&Model_Target_B.VectorConcatenate1[0],
           &Model_Target_DW.Delay2_DSTATE[0], sizeof(real32_T) << 7U);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S44>/RTC Request Response Trigger' */

    /* Switch: '<S37>/Switch' */
    rtb_Switch_iy = (real32_T)
        (Model_TargetPreAmpAudiopilotmuteReferenceRtcOut.REQ_muteReference == 0U);

    /* Product: '<S249>/MuteLPF' incorporates:
     *  Delay: '<S32>/Delay2'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 128;
            Model_Target_B.xpageoffset++)
    {
        HFBPFilt37133PoolIirAudioIn[Model_Target_B.xpageoffset + 32] =
            Model_Target_B.VectorConcatenate1[Model_Target_B.xpageoffset] *
            rtb_Switch_iy;
    }

    /* End of Product: '<S249>/MuteLPF' */
    /* MATLAB Function: '<S335>/PoolIirProcess' incorporates:
     *  Concatenate: '<S256>/Matrix Concatenate'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S339>:1' */
    /*  Extract configuration information from inputs */
    /* '<S339>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S339>:1:20' VariantStr = char(VariantUint8); */
    /* '<S339>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S339>:1:29' else */
    /* '<S339>:1:30' switch(VariantStr) */
    /* '<S339>:1:31' case{"Hexagon"} */
    /* '<S339>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&HFBPFilt11080PoolIirAudioOut[0],
                    &HFBPFilt37133PoolIirAudioIn[0], &HFBPFilt30618states[0]);

    /* Product: '<S256>/Product1' incorporates:
     *  Product: '<S256>/Matrix Multiply'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 160;
            Model_Target_B.xpageoffset++)
    {
        HFAA49482PoolIirAudioIn[Model_Target_B.xpageoffset] =
            Model_Target_B.MatrixMultiply_b[Model_Target_B.xpageoffset] *
            HFBPFilt11080PoolIirAudioOut[Model_Target_B.xpageoffset];
    }

    /* End of Product: '<S256>/Product1' */
    /* MATLAB Function: '<S319>/PoolIirProcess' incorporates:
     *  Product: '<S256>/Product1'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S323>:1' */
    /*  Extract configuration information from inputs */
    /* '<S323>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S323>:1:20' VariantStr = char(VariantUint8); */
    /* '<S323>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S323>:1:29' else */
    /* '<S323>:1:30' switch(VariantStr) */
    /* '<S323>:1:31' case{"Hexagon"} */
    /* '<S323>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&HFAA24216PoolIirAudioOut[0], &HFAA49482PoolIirAudioIn[0],
                    &HFAA13856states[0]);

    /* DownSample: '<S256>/Downsample2' */
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 10;
            Model_Target_B.stateLen++)
    {
        Model_Target_B.Downsample2[Model_Target_B.stateLen] =
            HFAA24216PoolIirAudioOut[Model_Target_B.stateLen << 4];
    }

    /* End of DownSample: '<S256>/Downsample2' */

    /* Selector: '<S256>/Selector1' */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        Model_Target_B.c = (Model_Target_B.yIdx + 1) << 1;
        Model_Target_B.xpageoffset = Model_Target_B.yIdx << 1;
        Model_Target_B.VectorConcatenate2_c[Model_Target_B.xpageoffset] =
            Model_Target_B.Downsample2[Model_Target_B.c];
        Model_Target_B.VectorConcatenate2_c[Model_Target_B.xpageoffset + 1] =
            Model_Target_B.Downsample2[Model_Target_B.c + 1];
    }

    /* End of Selector: '<S256>/Selector1' */
    /* MATLAB Function: '<S349>/delay' incorporates:
     *  Selector: '<S256>/Selector1'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S350>:1' */
    /*  figure out the frame size and channel count */
    /* '<S350>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S350>:1:8' frameSize = int32(frameSize); */
    /* '<S350>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S350>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S350>:1:11' delayTime = int32(delayTime); */
    /* '<S350>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S350>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S350>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex_o;

    /* '<S350>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S350>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0,
            1032);

        /* '<S350>:1:32' for sample = 1:frameSize */
        /*  overwrite oldest sample with the current input sample */
        /* '<S350>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
        Model_Target_B.c = Model_Target_B.yIdx << 1;
        Model_Target_DW.delayBuffer_h[Model_Target_B.writeIndex] =
            Model_Target_B.VectorConcatenate2_c[Model_Target_B.c];

        /*  increment write pointer */
        /* '<S350>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
        /*  overwrite oldest sample with the current input sample */
        /* '<S350>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
        Model_Target_DW.delayBuffer_h[circindex(Model_Target_B.writeIndex, 1,
            1032)] = Model_Target_B.VectorConcatenate2_c[Model_Target_B.c + 1];

        /*  increment write pointer */
        /* '<S350>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
        /*  Advance buffer index for next channel */
        /* '<S350>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 258,
            1032);
    }

    /*  Reset */
    /* '<S350>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex_o, 2, 1032);

    /* '<S350>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_o = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S350>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 4; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S350>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseRefLatencySamples + 2),
            1032);

        /* '<S350>:1:55' for sample = 1:frameSize */
        /*  overwrite oldest sample with the current input sample */
        /* '<S350>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
        Model_Target_B.c = Model_Target_B.yIdx << 1;
        Model_Target_B.MatrixConcatenate_j[Model_Target_B.c] =
            Model_Target_DW.delayBuffer_h[Model_Target_B.writeIndex];

        /*  increment write pointer */
        /* '<S350>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
        /*  overwrite oldest sample with the current input sample */
        /* '<S350>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
        Model_Target_B.MatrixConcatenate_j[Model_Target_B.c + 1] =
            Model_Target_DW.delayBuffer_h[circindex(Model_Target_B.writeIndex, 1,
            1032)];

        /*  increment write pointer */
        /* '<S350>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
        /*  Advance buffer index for next channel */
        /* '<S350>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 258,
            1032);
    }

    /* End of MATLAB Function: '<S349>/delay' */

    /* Selector: '<S256>/Selector' incorporates:
     *  Concatenate: '<S270>/Matrix Concatenate'
     */
    Model_Target_B.MatrixConcatenate_j[8] = Model_Target_B.Downsample2[0];
    Model_Target_B.MatrixConcatenate_j[9] = Model_Target_B.Downsample2[1];

    /* Buffer: '<S271>/Buffer' incorporates:
     *  Concatenate: '<S270>/Matrix Concatenate'
     */
    Model_Target_B.xpageoffset = 0;
    for (Model_Target_B.c = 0; Model_Target_B.c < 6; Model_Target_B.c++)
    {
        Model_Target_B.writeIndex = 2;
        Model_Target_B.sample = Model_Target_B.c << 9;
        Model_Target_B.yIdx = Model_Target_B.sample +
            Model_Target_DW.Buffer_inBufPtrIdx_e;
        if (Model_Target_DW.Buffer_inBufPtrIdx_e > 510)
        {
            Model_Target_B.stateLen = 0;
            while (Model_Target_B.stateLen < 512 -
                    Model_Target_DW.Buffer_inBufPtrIdx_e)
            {
                Model_Target_DW.Buffer_CircBuf_c[Model_Target_B.yIdx +
                    Model_Target_B.stateLen] =
                    Model_Target_B.MatrixConcatenate_j[Model_Target_B.xpageoffset
                    + Model_Target_B.stateLen];
                Model_Target_B.stateLen++;
            }

            Model_Target_B.xpageoffset = (Model_Target_B.xpageoffset -
                Model_Target_DW.Buffer_inBufPtrIdx_e) + 512;
            Model_Target_B.yIdx = Model_Target_B.sample;
            Model_Target_B.writeIndex = Model_Target_DW.Buffer_inBufPtrIdx_e -
                510;
        }

        Model_Target_B.stateLen = 0;
        while (Model_Target_B.stateLen < Model_Target_B.writeIndex)
        {
            Model_Target_DW.Buffer_CircBuf_c[Model_Target_B.yIdx +
                Model_Target_B.stateLen] =
                Model_Target_B.MatrixConcatenate_j[Model_Target_B.xpageoffset +
                Model_Target_B.stateLen];
            Model_Target_B.stateLen++;
        }

        Model_Target_B.xpageoffset += Model_Target_B.writeIndex;
    }

    Model_Target_DW.Buffer_inBufPtrIdx_e += 2;
    if (Model_Target_DW.Buffer_inBufPtrIdx_e >= 512)
    {
        Model_Target_DW.Buffer_inBufPtrIdx_e -= 512;
    }

    /* End of Buffer: '<S271>/Buffer' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S277>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S328>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S320>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S344>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S336>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S378>/ITC1' */
    /* Gain: '<S397>/Gain' incorporates:
     *  S-Function (SampleRateConverter_sfunc): '<S1600>/S-Function'
     */
    memcpy(&LPMicFilt1725PoolIirAudioIn[0], &Model_Target_B.SFunction_l[0],
           sizeof(real32_T) << 5U);

    /* MATLAB Function: '<S401>/PoolIirProcess' incorporates:
     *  Gain: '<S397>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S405>:1' */
    /*  Extract configuration information from inputs */
    /* '<S405>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S405>:1:20' VariantStr = char(VariantUint8); */
    /* '<S405>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S405>:1:29' else */
    /* '<S405>:1:30' switch(VariantStr) */
    /* '<S405>:1:31' case{"Hexagon"} */
    /* '<S405>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&LPMicFilt28254PoolIirAudioOut[0],
                    &LPMicFilt1725PoolIirAudioIn[0], &LPMicFilt61359states[0]);

    /* Buffer: '<S356>/BufferMic' */
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
            Model_Target_B.stateLen++)
    {
        Model_Target_DW.BufferMic_CircBuf[Model_Target_DW.BufferMic_inBufPtrIdx
            + Model_Target_B.stateLen] =
            LPMicFilt28254PoolIirAudioOut[Model_Target_B.stateLen];
    }

    Model_Target_DW.BufferMic_inBufPtrIdx += 32;
    if (Model_Target_DW.BufferMic_inBufPtrIdx >= 128)
    {
        Model_Target_DW.BufferMic_inBufPtrIdx -= 128;
    }

    /* End of Buffer: '<S356>/BufferMic' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S410>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S402>/ITC1' */
    /* Product: '<S249>/MuteLF' incorporates:
     *  Delay: '<S32>/Delay1'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        LFRefFilt33927PoolIirAudioIn[Model_Target_B.xpageoffset] = rtb_Switch_iy
            * Model_Target_DW.Delay1_DSTATE_lo[Model_Target_B.xpageoffset];
    }

    /* End of Product: '<S249>/MuteLF' */
    /* MATLAB Function: '<S417>/PoolIirProcess' incorporates:
     *  Product: '<S249>/MuteLF'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S421>:1' */
    /*  Extract configuration information from inputs */
    /* '<S421>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S421>:1:20' VariantStr = char(VariantUint8); */
    /* '<S421>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S421>:1:29' else */
    /* '<S421>:1:30' switch(VariantStr) */
    /* '<S421>:1:31' case{"Hexagon"} */
    /* '<S421>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&LFRefFilt59260PoolIirAudioOut[0],
                    &LFRefFilt33927PoolIirAudioIn[0], &LFRefFilt15698states[0]);

    /* Buffer: '<S356>/BufferRef' */
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
            Model_Target_B.stateLen++)
    {
        Model_Target_DW.BufferRef_CircBuf[Model_Target_DW.BufferRef_inBufPtrIdx
            + Model_Target_B.stateLen] =
            LFRefFilt59260PoolIirAudioOut[Model_Target_B.stateLen];
    }

    Model_Target_DW.BufferRef_inBufPtrIdx += 32;
    if (Model_Target_DW.BufferRef_inBufPtrIdx >= 128)
    {
        Model_Target_DW.BufferRef_inBufPtrIdx -= 128;
    }

    /* End of Buffer: '<S356>/BufferRef' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S426>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S418>/ITC1' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S45>/RTC Request Response Trigger' */

    /* RateTransition: '<S251>/Rate Transition3' */
    if (Model_Target_DW.RateTransition3_semaphoreTaken == 0)
    {
        Model_Target_DW.RateTransition3_Buffer0 =
            Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn;
    }

    /* End of RateTransition: '<S251>/Rate Transition3' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S48>/RTC Request Response Trigger' */

    /* RateTransition: '<S251>/Rate Transition6' */
    if (Model_Target_DW.RateTransition6_semaphoreTaken == 0)
    {
        Model_Target_DW.RateTransition6_Buffer0 = Model_Target_B.hvacDbspl;
    }

    /* End of RateTransition: '<S251>/Rate Transition6' */
    /* RateTransition: '<S252>/Rate Transition' */
    if (Model_Target_M->Timing.RateInteraction.TID2_6)
    {
        Model_Target_DW.RateTransition_Buffer =
            Model_Target_PreAmp_p4_b0.AudiopilotRatioLowBoundDb;

        /* RateTransition: '<S252>/Rate Transition1' */
        Model_Target_DW.RateTransition1_Buffer =
            Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb;
    }

    /* End of RateTransition: '<S252>/Rate Transition' */
    /* RateTransition: '<S249>/Speed Rate Transition' */
    if (Model_Target_DW.SpeedRateTransition_semaphoreTaken == 0)
    {
        Model_Target_DW.SpeedRateTransition_Buffer0 =
            Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn;
    }

    /* End of RateTransition: '<S249>/Speed Rate Transition' */
    /* End of Outputs for S-Function (RTC_NTF): '<S44>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S45>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S48>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S142>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S145>/RTC Request Response Trigger' */
    /* Gain: '<S518>/Gain' */
    memcpy(&Default59515PoolIirAudioIn[0],
           &Model_Target_PreAmpPart1_B.sf_tone_k.audioOut[0], sizeof(real32_T) <<
           6U);

    /* MATLAB Function: '<S522>/PoolIirProcess' incorporates:
     *  Gain: '<S518>/Gain'
     */
    /*  Process function for Pooliir */
    /*  */
    /*  Parameters: */
    /*    x:              input channels [frame size x number of inputs] */
    /*    NumStages:      array of filter lengths per channel [NumChannels x 1] */
    /*    CoeffsTarget:   coefficient set used for the specific target [total sim filter lengths x 1] */
    /*   */
    /*  Global parameters: */
    /*    states: working memory set up during roommode reset/init CRL */
    /*                    function call [StatesSize x 1] */
    /* -------------------------------------------------------------------------- */
    /* MATLAB Function 'PoolIirWithReset/PoolIir/TargetSpecific/PoolIirProcess': '<S526>:1' */
    /*  Extract configuration information from inputs */
    /* '<S526>:1:15' [~, NumChannels] = size(x); */
    /*  Initialize variables */
    /* '<S526>:1:20' VariantStr = char(VariantUint8); */
    /* '<S526>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S526>:1:29' else */
    /* '<S526>:1:30' switch(VariantStr) */
    /* '<S526>:1:31' case{"Hexagon"} */
    /* '<S526>:1:32' y = pooliir_hexagon_process(single(x), single(states)); */
    pooliir_process(&Default3743PoolIirAudioOut[0], &Default59515PoolIirAudioIn
                    [0], &Default13908states[0]);

    /* MATLAB Function: '<S485>/PreProcess' */
    /*  Pre-process by calculating the root mean square (rms) of the samples in the */
    /*  output frame or the maximum (peak) of the frame */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/EntertainmentLevelDetection/PreProcessing/PreProcess': '<S516>:1' */
    /*  Calculate RMS first */
    /* '<S516>:1:7' curr = 10 * log10(max(mean(Signal .* Signal, 1)) + eps); */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 64;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.Selector2_n[Model_Target_B.xpageoffset] =
            Default3743PoolIirAudioOut[Model_Target_B.xpageoffset] *
            Default3743PoolIirAudioOut[Model_Target_B.xpageoffset];
    }

    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 2;
            Model_Target_B.stateLen++)
    {
        Model_Target_B.xpageoffset = Model_Target_B.stateLen << 5;
        Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen] =
            Model_Target_B.Selector2_n[Model_Target_B.xpageoffset];
        for (Model_Target_B.c = 0; Model_Target_B.c < 31; Model_Target_B.c++)
        {
            Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen] +=
                Model_Target_B.Selector2_n[(Model_Target_B.xpageoffset +
                Model_Target_B.c) + 1];
        }

        Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen] =
            qhmath_div_f
            (Model_Target_B.MatrixConcatenate_eh[Model_Target_B.stateLen], 32.0F);
    }

    if (Model_Target_B.MatrixConcatenate_eh[0] <
            Model_Target_B.MatrixConcatenate_eh[1])
    {
        rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[1];
    }
    else
    {
        rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[0];
    }

    Model_Target_B.Delay3 = qhmath_log10_f(rtb_Switch_iy + 2.22044605E-16F) *
        10.0F;

    /* '<S516>:1:8' RmsOutput = max(curr); */
    /* '<S516>:1:10' if (PeakEnable) */
    if (Model_Target_ConstB.Compare_n)
    {
        /*  Calculate peak of frame if necessary */
        /* '<S516>:1:12' curr = 20 * log10(max(max(abs(Signal))) + eps); */
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 64;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Selector2_n[Model_Target_B.stateLen] = qhmath_abs_f
                (Default3743PoolIirAudioOut[Model_Target_B.stateLen]);
        }

        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 2;
                Model_Target_B.xpageoffset++)
        {
            Model_Target_B.c = Model_Target_B.xpageoffset << 5;
            Model_Target_B.MatrixConcatenate_eh[Model_Target_B.xpageoffset] =
                Model_Target_B.Selector2_n[Model_Target_B.c];
            for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 31;
                    Model_Target_B.stateLen++)
            {
                Model_Target_B.Max_g =
                    Model_Target_B.MatrixConcatenate_eh[Model_Target_B.xpageoffset];
                rtb_Switch_iy = Model_Target_B.Selector2_n[(Model_Target_B.c +
                    Model_Target_B.stateLen) + 1];
                if (Model_Target_B.Max_g < rtb_Switch_iy)
                {
                    Model_Target_B.Max_g = rtb_Switch_iy;
                }

                Model_Target_B.MatrixConcatenate_eh[Model_Target_B.xpageoffset] =
                    Model_Target_B.Max_g;
            }
        }

        if (Model_Target_B.MatrixConcatenate_eh[0] <
                Model_Target_B.MatrixConcatenate_eh[1])
        {
            rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[1];
        }
        else
        {
            rtb_Switch_iy = Model_Target_B.MatrixConcatenate_eh[0];
        }

        Model_Target_B.max_h = qhmath_log10_f(rtb_Switch_iy + 2.22044605E-16F) *
            20.0F;

        /* '<S516>:1:13' PeakOutput = max(curr); */
    }
    else
    {
        /* '<S516>:1:14' else */
        /*  If not, just set outpout to same as RMS */
        /* '<S516>:1:16' PeakOutput = RmsOutput; */
        Model_Target_B.max_h = Model_Target_B.Delay3;
    }

    /* MATLAB Function: '<S512>/delay' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S513>:1' */
    /*  figure out the frame size and channel count */
    /* '<S513>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S513>:1:8' frameSize = int32(frameSize); */
    /* '<S513>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S513>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S513>:1:11' delayTime = int32(delayTime); */
    /* '<S513>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S513>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S513>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex_f2;

    /* '<S513>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S513>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0, 576);

        /* '<S513>:1:32' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S513>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_hg[Model_Target_B.writeIndex] =
                Model_Target_PreAmpPart1_B.sf_tone_k.audioOut
                [(Model_Target_B.yIdx << 5) + Model_Target_B.sample];

            /*  increment write pointer */
            /* '<S513>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                576);
        }

        /*  Advance buffer index for next channel */
        /* '<S513>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 288,
            576);
    }

    /*  Reset */
    /* '<S513>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex_f2, 32,
        576);

    /* '<S513>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_f2 = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S513>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S513>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_PreAmp_p4_b0.LevelDetectMusicDelaySamples + 32), 576);

        /* '<S513>:1:55' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S513>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.audioOut_d[Model_Target_B.sample +
                (Model_Target_B.yIdx << 5)] =
                Model_Target_DW.delayBuffer_hg[Model_Target_B.writeIndex];

            /*  increment write pointer */
            /* '<S513>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                576);
        }

        /*  Advance buffer index for next channel */
        /* '<S513>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 288,
            576);
    }

    /* End of MATLAB Function: '<S512>/delay' */
    /* MATLAB Function: '<S549>/rgainy process' */
    Model_Target_rgainyprocess(Model_Target_ConstB.AudioStatsFunc_d,
        Model_Target_B.audioOut_d, &Model_Target_B.sf_rgainyprocess);

    /* MATLAB Function: '<S36>/select one channel gain' */
    /*  Rgainy outputs gains of all channels. In the entertainment path, we only */
    /*  have one ramper meaning that the same gain gets applied to all channels. */
    /*  The following code extracts the gain of just the first channel as output. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Volume/select one channel gain': '<S540>:1' */
    /* '<S540>:1:5' gainSingleChannel = squeeze(gainIn(:,1,:)); */
    Model_Target_B.gainSingleChannel = Model_Target_B.sf_rgainyprocess.gainOut[0];

    /* MATLAB Function: '<S35>/Linear2Db' */
    /*  Convert linear volume to dB */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/EntertainmentLevelDetection/Linear2Db': '<S483>:1' */
    /* '<S483>:1:4' VoldDb = single(20 * log10(Volume + eps)); */
    Model_Target_B.Max_g = qhmath_log10_f(Model_Target_B.gainSingleChannel +
        2.22044605E-16F) * 20.0F;

    /* MATLAB Function: '<S504>/InnerLink' incorporates:
     *  Constant: '<S31>/Constant'
     *  Constant: '<S35>/DyneqMode'
     *  MATLAB Function: '<S485>/PreProcess'
     */
    Model_Target_InnerLink(Model_Target_B.Delay3, Model_Target_B.max_h,
                           Model_Target_PreAmp_p4_b0.LevelDetectSysMaxDbspl,
                           Model_Target_PreAmp_p4_b0.DyneqLevelDetectSlowDecayDbPerSample,
                           Model_Target_PreAmp_p4_b0.DyneqLevelDetectHoldMarginDb,
                           Model_Target_PreAmp_p4_b0.DyneqLevelDetectHoldTimeSamples,
                           Model_Target_PreAmp_p4_b0.DyneqLevelDetectFastDecayDbPerSample,
                           Model_Target_PreAmp_p4_b0.DyneqLevelDetectMinVolumeDb,
                           Model_Target_PreAmp_p4_b0.DyneqLevelDetectMaxVolumeDb,
                           Model_Target_B.Max_g, 0.0, 0.0F,
                           &Model_Target_B.sf_InnerLink_a,
                           &Model_Target_DW.sf_InnerLink_a);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S171>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S491>/InnerLink' incorporates:
     *  Constant: '<S31>/Constant'
     *  Constant: '<S35>/AudiopilotMode'
     *  MATLAB Function: '<S485>/PreProcess'
     */
    Model_Target_InnerLink(Model_Target_B.Delay3, Model_Target_B.max_h,
                           Model_Target_PreAmp_p4_b0.LevelDetectSysMaxDbspl,
                           Model_Target_PreAmp_p4_b0.AudiopilotLevelDetectSlowDecayDbPerSample,
                           Model_Target_PreAmp_p4_b0.AudiopilotLevelDetectHoldMarginDb,
                           Model_Target_PreAmp_p4_b0.AudiopilotLevelDetectHoldTimeSamples,
                           Model_Target_PreAmp_p4_b0.AudiopilotLevelDetectFastDecayDbPerSample,
                           Model_Target_PreAmp_p4_b0.AudiopilotLevelDetectMinVolumeDb,
                           Model_Target_PreAmp_p4_b0.AudiopilotLevelDetectMaxVolumeDb,
                           Model_Target_B.Max_g, 0.0, 0.0F,
                           &Model_Target_B.sf_InnerLink,
                           &Model_Target_DW.sf_InnerLink);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S173>/RTC Request Response Trigger' */
    /* MATLAB Function: '<S133>/InputOverRide' */
    /*  This implements the overrides of the levels of the input signal */
    /*  If the flag is held high (value = 1), the input levels take on the  */
    /*  provided values. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/Boosts/InputOverride/InputOverRide': '<S170>:1' */
    /*  DynEq Signal Level */
    /* '<S170>:1:10' if (DynEqSignalOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRideFlag
        != 0U)
    {
        /* '<S170>:1:11' DynEqSignalOut = DynEqSignalOverRide; */
        Model_Target_B.Max_g =
            Model_TargetPreAmpAudiopilotsetLoudSignalOverRideRtcOut.REQ_LoudSignalOverRide;
    }
    else
    {
        /* '<S170>:1:12' else */
        /* '<S170>:1:13' DynEqSignalOut = DynEqSignalIn; */
        Model_Target_B.Max_g = Model_Target_B.sf_InnerLink_a.level;
    }

    /*  AudioPilot Signal Level */
    /* '<S170>:1:17' if (AudioPilotSignalOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRideFlag
        != 0U)
    {
        /* '<S170>:1:18' AudioPilotSignalOut = AudioPilotSignalOverRide; */
        Model_Target_B.max_h =
            Model_TargetPreAmpAudiopilotsetVNCSignalOverRideRtcOut.REQ_VNCSignalOverRide;
    }
    else
    {
        /* '<S170>:1:19' else */
        /* '<S170>:1:20' AudioPilotSignalOut = max(AudioPilotSignalIn, AudioPilotMinSignal); */
        Model_Target_B.max_h = fmaxf(Model_Target_B.sf_InnerLink.level,
            Model_Target_PreAmp_p4_b0.AudiopilotMinSignalLevelDbspl);
    }

    /* End of MATLAB Function: '<S133>/InputOverRide' */

    /* RateTransition: '<S34>/Rate Transition1' */
    Model_Target_B.a2 =
        Model_Target_DW.RateTransition1_Buffer_k[Model_Target_DW.RateTransition1_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S193>/RTC Request Response Trigger' */

    /* RateTransition: '<S34>/Rate Transition11' */
    Model_Target_B.xx =
        Model_Target_DW.RateTransition11_Buffer[Model_Target_DW.RateTransition11_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S196>/RTC Request Response Trigger' */

    /* RateTransition: '<S34>/Rate Transition6' */
    Model_Target_B.yy =
        Model_Target_DW.RateTransition6_Buffer[Model_Target_DW.RateTransition6_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S192>/RTC Request Response Trigger' */

    /* RateTransition: '<S34>/Rate Transition2' */
    Model_Target_B.q =
        Model_Target_DW.RateTransition2_Buffer[Model_Target_DW.RateTransition2_ActiveBufIdx];

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S195>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S108>/NoiseOverRide' */
    Model_Target_B.LFNoise = Model_Target_B.a2;
    Model_Target_B.WBNoise = Model_Target_B.xx;
    Model_Target_B.HFNoise = Model_Target_B.yy;
    Model_Target_B.Ratio = Model_Target_B.q;

    /*  This function executes the overrides. */
    /*  For each parameter or state, if the flag is enabled (set to 1) */
    /*  then the variable will take on the value provided. */
    /*  Otherwise, this is a pass through. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/InputOverRide/NoiseOverRide': '<S194>:1' */
    /*  Pass through */
    /* '<S194>:1:12' LFNoise = LFNoiseIn; */
    /* '<S194>:1:13' WBNoise = WBNoiseIn; */
    /* '<S194>:1:14' HFNoise = HFNoiseIn; */
    /* '<S194>:1:15' Ratio = RatioIn; */
    /*  Low frequency noise override */
    /* '<S194>:1:18' if (LFNoiseOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRideFlag
        != 0U)
    {
        /* '<S194>:1:19' LFNoise = LFNoiseOverRide; */
        Model_Target_B.LFNoise =
            Model_TargetPreAmpAudiopilotsetLFNoiseOverRideRtcOut.REQ_LFNoiseOverRide;
    }

    /*  Wide band noise override */
    /* '<S194>:1:23' if (WBNoiseOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRideFlag
        != 0U)
    {
        /* '<S194>:1:24' WBNoise = WBNoiseOverRide; */
        Model_Target_B.WBNoise =
            Model_TargetPreAmpAudiopilotsetWBNoiseOverRideRtcOut.REQ_WBNoiseOverRide;
    }

    /*  High frequency noise override */
    /* '<S194>:1:28' if (HFNoiseOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRideFlag
        != 0U)
    {
        /* '<S194>:1:29' HFNoise = HFNoiseOverRide; */
        Model_Target_B.HFNoise =
            Model_TargetPreAmpAudiopilotsetHFNoiseOverRideRtcOut.REQ_HFNoiseOverRide;
    }

    /*  Noise ratio override */
    /* '<S194>:1:33' if (RatioOverRideFlag) */
    if (Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRideFlag
        != 0U)
    {
        /* '<S194>:1:34' Ratio = RatioOverRide; */
        Model_Target_B.Ratio =
            Model_TargetPreAmpAudiopilotsetRatioOverRideRtcOut.REQ_RatioOverRide;
    }

    /* End of MATLAB Function: '<S108>/NoiseOverRide' */
    /* MATLAB Function: '<S105>/AlphaCalculation' incorporates:
     *  Switch: '<S105>/Switch1'
     *  Switch: '<S105>/Switch2'
     */
    /*  This calculates the alpha modifier for boost map adjustment. */
    /*  For each noise estimate, a value is calculated denoting the estimate's  */
    /*  position within a specified range.  The modifier is the product of */
    /*  the values from the two noise estimates. */
    /*  The modifier is a value between 0 and 1.   */
    /*  A value of 0 means no boost map adjustment. */
    /*  A value of 1 will allow the full boost map adjustment based on the ratio. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/BoostMapAdjustment/AlphaCalculation': '<S111>:1' */
    /*  alpha:  HF Noise */
    /* '<S111>:1:15' if HFNoise < HFNoiseLow */
    if (Model_Target_B.HFNoise <
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseLowBoundDbspl)
    {
        /* '<S111>:1:16' alpha = single(0); */
        rtb_alpha = 0.0F;
    }
    else if (Model_Target_B.HFNoise >
             Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseHighBoundDbspl)
    {
        /* '<S111>:1:17' elseif HFNoise > HFNoiseHigh */
        /* '<S111>:1:18' alpha = single(1); */
        rtb_alpha = 1.0F;
    }
    else
    {
        /* '<S111>:1:19' else */
        /* '<S111>:1:20' alpha = single((HFNoise-HFNoiseLow)/(HFNoiseHigh-HFNoiseLow)); */
        rtb_alpha = qhmath_div_f(Model_Target_B.HFNoise -
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseLowBoundDbspl,
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseHighBoundDbspl -
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseLowBoundDbspl);
    }

    /*  beta: LF Noise */
    /* '<S111>:1:24' if LFnoise < LFNoiseLow */
    if (Model_Target_B.LFNoise <
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseLowBoundDbspl)
    {
        /* '<S111>:1:25' beta = single(0); */
        Model_Target_B.a2 = 0.0F;
    }
    else if (Model_Target_B.LFNoise >
             Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseHighBoundDbspl)
    {
        /* '<S111>:1:26' elseif LFnoise > LFNoiseHigh */
        /* '<S111>:1:27' beta = single(1); */
        Model_Target_B.a2 = 1.0F;
    }
    else
    {
        /* '<S111>:1:28' else */
        /* '<S111>:1:29' beta  = single((LFnoise-LFNoiseLow)/(LFNoiseHigh-LFNoiseLow)); */
        Model_Target_B.a2 = qhmath_div_f(Model_Target_B.LFNoise -
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseLowBoundDbspl,
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseHighBoundDbspl -
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseLowBoundDbspl);
    }

    /*  product */
    /* '<S111>:1:33' alpha = alpha * beta; */
    rtb_alpha *= Model_Target_B.a2;

    /* End of MATLAB Function: '<S105>/AlphaCalculation' */

    /* MATLAB Function: '<S105>/BoostMapAdjustments' */
    /*  This adjusts the slope and the thresholds for all three bands */
    /*  based on the ratio and the alpha modifier. */
    /*  Typically the more aggressive tuning, denoted by suffix_1,  */
    /*  corresponds  to the higher ratio value, */
    /*  whereas the less aggressive base tuning,denoted by suffix_0, */
    /*  corresponds to the lower ratio value. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/BoostMapAdjustment/BoostMapAdjustments': '<S115>:1' */
    /*  Set up two-element arrays for the purpose of interpolation */
    /*  Note that the Ratio array has the high value before the low value. */
    /* '<S115>:1:20' RatioPair = [ratioHigh ratioLow]; */
    Model_Target_B.MatrixConcatenate_eh[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb;
    Model_Target_B.MatrixConcatenate_eh[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotRatioLowBoundDb;

    /* '<S115>:1:22' BthreshPair = [BassThresh0 BassThresh1]; */
    Model_Target_B.BthreshPair[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotBassThresh0Db;
    Model_Target_B.BthreshPair[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotBassThresh1Db;

    /* '<S115>:1:23' MthreshPair = [MidrangeThresh0 MidrangeThresh1]; */
    Model_Target_B.MthreshPair[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotMidrangeThresh0Db;
    Model_Target_B.MthreshPair[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotMidrangeThresh1Db;

    /* '<S115>:1:24' TthreshPair = [TrebleThresh0 TrebleThresh1]; */
    Model_Target_B.TthreshPair[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotTrebleThresh0Db;
    Model_Target_B.TthreshPair[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotTrebleThresh1Db;

    /* '<S115>:1:25' BslopePair = [BassSlope0 BassSlope1]; */
    Model_Target_B.BslopePair[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotBassSlope0Dbperdb;
    Model_Target_B.BslopePair[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotBassSlope1Dbperdb;

    /* '<S115>:1:26' MslopePair = [MidrangeSlope0 MidrangeSlope1]; */
    Model_Target_B.MslopePair[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotMidrangeSlope0Dbperdb;
    Model_Target_B.MslopePair[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotMidrangeSlope1Dbperdb;

    /* '<S115>:1:27' TslopePair = [TrebleSlope0 TrebleSlope1]; */
    Model_Target_B.TslopePair[0] =
        Model_Target_PreAmp_p4_b0.AudiopilotTrebleSlope0Dbperdb;
    Model_Target_B.TslopePair[1] =
        Model_Target_PreAmp_p4_b0.AudiopilotTrebleSlope1Dbperdb;

    /*  Saturation of the ratio value to the specified range */
    /*  Apply the alpha modifier */
    /* '<S115>:1:32' if ratio >= ratioHigh */
    /*  This is for ratio values higher than high value.   */
    /*  In these cases, the interp1() function really does not need to be run */
    /*  Optimization opportunity. */
    /* '<S115>:1:36' BassSlope = (interp1(RatioPair, BslopePair, ratioHigh, 'linear'))*alpha ... */
    /* '<S115>:1:37'                     + (1-alpha)*BslopePair(1); */
    Model_Target_B.yy = (1.0F - rtb_alpha) *
        Model_Target_PreAmp_p4_b0.AudiopilotBassSlope0Dbperdb +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_eh,
        Model_Target_B.BslopePair,
        Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* '<S115>:1:38' MidrangeSlope = (interp1(RatioPair, MslopePair, ratioHigh, 'linear'))*alpha ...    */
    /* '<S115>:1:39'                     + (1-alpha)*MslopePair(1); */
    Model_Target_B.a2 = (1.0F - rtb_alpha) *
        Model_Target_PreAmp_p4_b0.AudiopilotMidrangeSlope0Dbperdb +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_eh,
        Model_Target_B.MslopePair,
        Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* '<S115>:1:40' TrebleSlope = (interp1(RatioPair, TslopePair, ratioHigh, 'linear'))*alpha ... */
    /* '<S115>:1:41'                     + (1-alpha)*TslopePair(1); */
    /* '<S115>:1:42' BassThresh = (interp1(RatioPair, BthreshPair, ratioHigh, 'linear'))*alpha ... */
    /* '<S115>:1:43'                     + (1-alpha)*BthreshPair(1); */
    Model_Target_B.q = (1.0F - rtb_alpha) *
        Model_Target_PreAmp_p4_b0.AudiopilotBassThresh0Db + Model_Target_interp1
        (Model_Target_B.MatrixConcatenate_eh, Model_Target_B.BthreshPair,
         Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* '<S115>:1:44' MidrangeThresh = (interp1(RatioPair, MthreshPair, ratioHigh, 'linear'))*alpha ... */
    /* '<S115>:1:45'                     + (1-alpha)*MthreshPair(1); */
    Model_Target_B.xx = (1.0F - rtb_alpha) *
        Model_Target_PreAmp_p4_b0.AudiopilotMidrangeThresh0Db +
        Model_Target_interp1(Model_Target_B.MatrixConcatenate_eh,
        Model_Target_B.MthreshPair,
        Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb) * rtb_alpha;

    /* S-Function (TOP_MEX): '<S137>/TOP' */
    /* '<S115>:1:46' TrebleThresh = (interp1(RatioPair, TthreshPair, ratioHigh, 'linear'))*alpha ... */
    /* '<S115>:1:47'                     + (1-alpha)*TthreshPair(1); */
    /* Switch: '<S129>/Switch3' incorporates:
     *  Constant: '<S141>/Constant'
     *  MinMax: '<S141>/Max'
     *  MinMax: '<S141>/Min'
     *  Switch: '<S141>/Switch'
     */
    if (Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRideFlag
        != 0U)
    {
        rtb_Switch_iy =
            Model_TargetPreAmpAudiopilotsetVNCTrebleBoostOverRideRtcOut.REQ_VNCTrebleBoostOverRide;
    }
    else
    {
        if (Model_Target_PreAmp_p4_b0.AudiopilotTrebleDownwardSlopeDbPerDb >
                0.0F)
        {
            /* Switch: '<S141>/Switch' incorporates:
             *  MATLAB Function: '<S105>/BoostMapAdjustments'
             *  MinMax: '<S141>/Min1'
             *  Product: '<S141>/Product'
             *  Product: '<S141>/Product1'
             *  Sum: '<S141>/Sum'
             *  Sum: '<S141>/Sum1'
             */
            rtb_Switch_iy = fminf((Model_Target_B.max_h -
                                   Model_Target_PreAmp_p4_b0.AudiopilotTrebleDownwardThreshDbspl)
                                  * Model_Target_PreAmp_p4_b0.AudiopilotTrebleDownwardSlopeDbPerDb,
                                  (((1.0F - rtb_alpha) *
                                    Model_Target_PreAmp_p4_b0.AudiopilotTrebleThresh0Db
                                    + Model_Target_interp1
                                    (Model_Target_B.MatrixConcatenate_eh,
                Model_Target_B.TthreshPair,
                Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb) *
                                    rtb_alpha) + (Model_Target_B.WBNoise -
                                    Model_Target_B.max_h)) * ((1.0F - rtb_alpha)
                                   * Model_Target_PreAmp_p4_b0.AudiopilotTrebleSlope0Dbperdb
                                   + Model_Target_interp1
                                   (Model_Target_B.MatrixConcatenate_eh,
                                    Model_Target_B.TslopePair,
                                    Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb)
                                   * rtb_alpha));
        }
        else
        {
            /* Switch: '<S141>/Switch' incorporates:
             *  MATLAB Function: '<S105>/BoostMapAdjustments'
             *  Product: '<S141>/Product'
             *  Sum: '<S141>/Sum'
             */
            rtb_Switch_iy = (((1.0F - rtb_alpha) *
                              Model_Target_PreAmp_p4_b0.AudiopilotTrebleThresh0Db
                              + Model_Target_interp1
                              (Model_Target_B.MatrixConcatenate_eh,
                               Model_Target_B.TthreshPair,
                               Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb)
                              * rtb_alpha) + (Model_Target_B.WBNoise -
                              Model_Target_B.max_h)) * ((1.0F - rtb_alpha) *
                Model_Target_PreAmp_p4_b0.AudiopilotTrebleSlope0Dbperdb +
                Model_Target_interp1(Model_Target_B.MatrixConcatenate_eh,
                Model_Target_B.TslopePair,
                Model_Target_PreAmp_p4_b0.AudiopilotRatioHighBoundDb) *
                rtb_alpha);
        }

        rtb_Switch_iy = fminf(fmaxf(0.0F, rtb_Switch_iy),
                              Model_Target_PreAmp_p4_b0.AudiopilotTrebleMaxTotalBoostDb);
    }

    /* End of Switch: '<S129>/Switch3' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S232>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S233>/RTC Request Response Trigger' */

    /* MATLAB Function: '<S110>/Ramper' */
    /*  This ramps the on/off switches for both audiopilot and dynamic EQ */
    /*  T */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainCalculation/RampedEnable/Ramper': '<S234>:1' */
    /*  States */
    /*  Initialization */
    /* '<S234>:1:10' if isempty(dyneq_boost_gain_prev) */
    /* '<S234>:1:14' if isempty(audiopilot_boost_gain_prev) */
    /*  Default to disable  */
    /*  These values should typically not be used. */
    /* '<S234>:1:20' dyneq_boost_gain = single(0); */
    /* '<S234>:1:21' audiopilot_boost_gain = single(0); */
    /*  The value ramps up to 1 or decays to 0 with a first order filter */
    /*  The ramp coefficient is shared between the two features, */
    /*  AudioPilot and Dynamic EQ */
    /* '<S234>:1:27' if dyneq_on */
    if (Model_TargetPreAmpAudiopilotsetDyneqOnRtcOut.REQ_dyneq_on != 0U)
    {
        /* '<S234>:1:28' dyneq_boost_gain = (1-rampCoef) + (rampCoef * dyneq_boost_gain_prev); */
        rtb_alpha = (1.0F - Model_Target_PreAmp_p4_b0.AudiopilotEnableRampCoef)
            + Model_Target_PreAmp_p4_b0.AudiopilotEnableRampCoef *
            Model_Target_DW.dyneq_boost_gain_prev;
    }
    else
    {
        /* '<S234>:1:29' else */
        /* '<S234>:1:30' dyneq_boost_gain = rampCoef * dyneq_boost_gain_prev; */
        rtb_alpha = Model_Target_PreAmp_p4_b0.AudiopilotEnableRampCoef *
            Model_Target_DW.dyneq_boost_gain_prev;
    }

    /* '<S234>:1:33' if audiopilot_on */
    if (Model_TargetPreAmpAudiopilotsetAudioPilotOnRtcOut.REQ_audiopilot_on !=
            0U)
    {
        /* '<S234>:1:34' audiopilot_boost_gain = (1-rampCoef) + (rampCoef * audiopilot_boost_gain_prev); */
        rtb_TrebleSlope = (1.0F -
                           Model_Target_PreAmp_p4_b0.AudiopilotEnableRampCoef) +
            Model_Target_PreAmp_p4_b0.AudiopilotEnableRampCoef *
            Model_Target_DW.audiopilot_boost_gain_prev;
    }
    else
    {
        /* '<S234>:1:35' else */
        /* '<S234>:1:36' audiopilot_boost_gain = rampCoef * audiopilot_boost_gain_prev; */
        rtb_TrebleSlope = Model_Target_PreAmp_p4_b0.AudiopilotEnableRampCoef *
            Model_Target_DW.audiopilot_boost_gain_prev;
    }

    /*  Maintain states */
    /* '<S234>:1:40' dyneq_boost_gain_prev = dyneq_boost_gain; */
    Model_Target_DW.dyneq_boost_gain_prev = rtb_alpha;

    /* '<S234>:1:41' audiopilot_boost_gain_prev = audiopilot_boost_gain; */
    Model_Target_DW.audiopilot_boost_gain_prev = rtb_TrebleSlope;
    Model_Target_B.dyneq_boost_gain = rtb_alpha;
    Model_Target_B.audiopilot_boost_gain = rtb_TrebleSlope;

    /* End of MATLAB Function: '<S110>/Ramper' */

    /* Product: '<S129>/Product' */
    Model_Target_B.Product_h5 = rtb_Switch_iy *
        Model_Target_B.audiopilot_boost_gain;

    /* Switch: '<S129>/Switch' incorporates:
     *  Constant: '<S139>/Constant'
     *  MinMax: '<S139>/Max'
     *  MinMax: '<S139>/Min'
     *  Product: '<S139>/Product'
     *  Sum: '<S106>/Sum1'
     *  Sum: '<S139>/Sum'
     */
    if (Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRideFlag
        != 0U)
    {
        rtb_Switch_iy =
            Model_TargetPreAmpAudiopilotsetDynEQBoostOverRideRtcOut.REQ_DynEQBoostOverRide;
    }
    else
    {
        rtb_Switch_iy = fminf(fmaxf(0.0F,
                               (Model_Target_PreAmp_p4_b0.AudiopilotDyneqBassThreshDbspl
                                - (Model_Target_B.Product_h5 +
            Model_Target_B.Max_g)) *
                               Model_Target_PreAmp_p4_b0.AudiopilotDyneqBassSlopeDbPerDb),
                              Model_Target_PreAmp_p4_b0.AudiopilotBassMaxDyneqBoostDb);
    }

    /* Product: '<S129>/Product3' incorporates:
     *  Switch: '<S129>/Switch'
     */
    Model_Target_B.Product3 = rtb_Switch_iy * Model_Target_B.dyneq_boost_gain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S143>/RTC Request Response Trigger' */
    /* Switch: '<S129>/Switch1' incorporates:
     *  Constant: '<S138>/Constant'
     *  MinMax: '<S138>/Max'
     *  MinMax: '<S138>/Min'
     *  Switch: '<S138>/Switch'
     */
    if (Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRideFlag
        != 0U)
    {
        rtb_Switch_iy =
            Model_TargetPreAmpAudiopilotsetVNCBassBoostOverRideRtcOut.REQ_VNCBassBoostOverRide;
    }
    else
    {
        if (Model_Target_PreAmp_p4_b0.AudiopilotBassDownwardSlopeDbPerDb > 0.0F)
        {
            /* Switch: '<S138>/Switch' incorporates:
             *  MinMax: '<S138>/Min1'
             *  Product: '<S138>/Product'
             *  Product: '<S138>/Product1'
             *  Sum: '<S138>/Sum'
             *  Sum: '<S138>/Sum1'
             */
            rtb_Switch_iy = fminf((Model_Target_B.max_h -
                                   Model_Target_PreAmp_p4_b0.AudiopilotBassDownwardThreshDbspl)
                                  * Model_Target_PreAmp_p4_b0.AudiopilotBassDownwardSlopeDbPerDb,
                                  ((Model_Target_B.LFNoise -
                                    Model_Target_B.max_h) + Model_Target_B.q) *
                                  Model_Target_B.yy);
        }
        else
        {
            /* Switch: '<S138>/Switch' incorporates:
             *  Product: '<S138>/Product'
             *  Sum: '<S138>/Sum'
             */
            rtb_Switch_iy = ((Model_Target_B.LFNoise - Model_Target_B.max_h) +
                             Model_Target_B.q) * Model_Target_B.yy;
        }

        rtb_Switch_iy = fminf(fmaxf(0.0F, rtb_Switch_iy),
                              Model_Target_PreAmp_p4_b0.AudiopilotBassMaxAudiopilotBoostDb);
    }

    /* End of Switch: '<S129>/Switch1' */

    /* Product: '<S129>/Product2' */
    Model_Target_B.Product2 = rtb_Switch_iy *
        Model_Target_B.audiopilot_boost_gain;

    /* MinMax: '<S106>/Min' incorporates:
     *  Sum: '<S106>/Sum'
     */
    Model_Target_B.Min = fminf(Model_Target_B.Product3 + Model_Target_B.Product2,
        Model_Target_PreAmp_p4_b0.AudiopilotBassMaxTotalBoostDb);

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S69>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S69>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S144>/RTC Request Response Trigger' */
    /* Switch: '<S129>/Switch2' incorporates:
     *  Constant: '<S140>/Constant'
     *  MinMax: '<S140>/Max'
     *  MinMax: '<S140>/Min'
     *  Switch: '<S140>/Switch'
     */
    if (Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRideFlag
        != 0U)
    {
        rtb_Switch_iy =
            Model_TargetPreAmpAudiopilotsetVNCMidBoostOverRideRtcOut.REQ_VNCMidBoostOverRide;
    }
    else
    {
        if (Model_Target_PreAmp_p4_b0.AudiopilotMidrangeDownwardSlopeDbPerDb >
                0.0F)
        {
            /* Switch: '<S140>/Switch' incorporates:
             *  MinMax: '<S140>/Min1'
             *  Product: '<S140>/Product'
             *  Product: '<S140>/Product1'
             *  Sum: '<S140>/Sum'
             *  Sum: '<S140>/Sum1'
             */
            rtb_Switch_iy = fminf((Model_Target_B.max_h -
                                   Model_Target_PreAmp_p4_b0.AudiopilotMidrangeDownwardThreshDbspl)
                                  * Model_Target_PreAmp_p4_b0.AudiopilotMidrangeDownwardSlopeDbPerDb,
                                  ((Model_Target_B.WBNoise -
                                    Model_Target_B.max_h) + Model_Target_B.xx) *
                                  Model_Target_B.a2);
        }
        else
        {
            /* Switch: '<S140>/Switch' incorporates:
             *  Product: '<S140>/Product'
             *  Sum: '<S140>/Sum'
             */
            rtb_Switch_iy = ((Model_Target_B.WBNoise - Model_Target_B.max_h) +
                             Model_Target_B.xx) * Model_Target_B.a2;
        }

        rtb_Switch_iy = fminf(fmaxf(0.0F, rtb_Switch_iy),
                              Model_Target_PreAmp_p4_b0.AudiopilotMidrangeMaxTotalBoostDb);
    }

    /* End of Switch: '<S129>/Switch2' */

    /* Product: '<S129>/Product1' */
    Model_Target_B.Product1 = rtb_Switch_iy *
        Model_Target_B.audiopilot_boost_gain;

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S70>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S70>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S71>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S71>/NTF Trigger' */

    /* MinMax: '<S68>/TrebleMax' incorporates:
     *  Constant: '<S68>/Constant3'
     *  Gain: '<S81>/Gain'
     *  Math: '<S81>/Math Function'
     */
    Model_Target_B.max_h = fmaxf(qhmath_pow_f(10.0F, 0.05F *
        Model_Target_B.Product_h5), 0.0F);

    /* Switch: '<S68>/Switch' incorporates:
     *  Constant: '<S68>/Constant'
     *  Constant: '<S68>/Constant4'
     *  Gain: '<S80>/Gain'
     *  Math: '<S80>/Math Function'
     *  MinMax: '<S68>/MidrangeMax'
     *  Sum: '<S68>/Add1'
     */
    if (Model_Target_PreAmp_p4_b0.AudiopilotTwoDowngrade != 0U)
    {
        rtb_Switch_iy = 0.0F;
    }
    else
    {
        rtb_Switch_iy = fmaxf(qhmath_pow_f(10.0F, 0.05F *
                               Model_Target_B.Product1) - Model_Target_B.max_h,
                              0.0F);
    }

    /* End of Switch: '<S68>/Switch' */
    /* DiscreteFilter: '<S68>/Bpf' incorporates:
     *  S-Function (TOP_MEX): '<S76>/TOP'
     *  S-Function (TOP_MEX): '<S76>/TOP1'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        Model_Target_B.sample = Model_Target_B.c << 1;
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Bpf[Model_Target_B.yIdx] =
                Model_Target_PreAmp_p4_b0.AudiopilotBassBpfNumerator[0] *
                Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx] +
                Model_Target_DW.Bpf_states[Model_Target_B.sample];
            Model_Target_DW.Bpf_states[Model_Target_B.sample] =
                (Model_Target_DW.Bpf_states[Model_Target_B.sample + 1] +
                 Model_Target_PreAmp_p4_b0.AudiopilotBassBpfNumerator[1] *
                 Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx])
                - Model_Target_PreAmp_p4_b0.AudiopilotBassBpfDenominator[1] *
                Model_Target_B.Bpf[Model_Target_B.yIdx];
            Model_Target_DW.Bpf_states[Model_Target_B.sample + 1] =
                Model_Target_PreAmp_p4_b0.AudiopilotBassBpfNumerator[2] *
                Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx] -
                Model_Target_PreAmp_p4_b0.AudiopilotBassBpfDenominator[2] *
                Model_Target_B.Bpf[Model_Target_B.yIdx];
            Model_Target_B.yIdx++;
        }
    }

    /* End of DiscreteFilter: '<S68>/Bpf' */

    /* MinMax: '<S68>/BassMax' incorporates:
     *  Constant: '<S68>/Constant1'
     *  Gain: '<S79>/Gain'
     *  Math: '<S79>/Math Function'
     *  Sum: '<S68>/Add'
     *  Sum: '<S68>/Add2'
     */
    Model_Target_B.Max_g = fmaxf(qhmath_pow_f(10.0F, 0.05F * Model_Target_B.Min)
        - (Model_Target_B.max_h + rtb_Switch_iy), 0.0F);

    /* Product: '<S68>/BPFFramify' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset] =
            Model_Target_B.Max_g;
    }

    /* End of Product: '<S68>/BPFFramify' */

    /* DiscreteFilter: '<S68>/ZipperNoiseReductionBpf' incorporates:
     *  Product: '<S68>/BPFFramify'
     *  S-Function (TOP_MEX): '<S72>/TOP1'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
            Model_Target_B.stateLen++)
    {
        Model_Target_B.ZipperNoiseReductionBpf[Model_Target_B.yIdx] =
            Model_Target_PreAmp_p4_b0.AudiopilotAntiZipperRampLpfNumerator *
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] +
            Model_Target_DW.ZipperNoiseReductionBpf_states;
        Model_Target_DW.ZipperNoiseReductionBpf_states = 0.0F -
            Model_Target_PreAmp_p4_b0.AudiopilotAntiZipperRampLpfDenominator[1] *
            Model_Target_B.ZipperNoiseReductionBpf[Model_Target_B.yIdx];
        Model_Target_B.yIdx++;
    }

    /* End of DiscreteFilter: '<S68>/ZipperNoiseReductionBpf' */

    /* MATLAB Function: '<S68>/ApplyBpfGain' */
    Model_Target_ApplyBpfGain(Model_Target_B.Bpf,
        Model_Target_B.ZipperNoiseReductionBpf, &Model_Target_B.sf_ApplyBpfGain);

    /* DiscreteFilter: '<S68>/Lpf' incorporates:
     *  S-Function (TOP_MEX): '<S77>/TOP'
     *  S-Function (TOP_MEX): '<S77>/TOP1'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        Model_Target_B.sample = Model_Target_B.c << 2;
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.Lpf[Model_Target_B.yIdx] =
                Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfNumerator[0] *
                Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx] +
                Model_Target_DW.Lpf_states[Model_Target_B.sample];
            Model_Target_DW.Lpf_states[Model_Target_B.sample] =
                (Model_Target_DW.Lpf_states[Model_Target_B.sample + 1] +
                 Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfNumerator[1] *
                 Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx])
                - Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfDenominator[1] *
                Model_Target_B.Lpf[Model_Target_B.yIdx];
            Model_Target_DW.Lpf_states[Model_Target_B.sample + 1] =
                (Model_Target_DW.Lpf_states[Model_Target_B.sample + 2] +
                 Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfNumerator[2] *
                 Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx])
                - Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfDenominator[2] *
                Model_Target_B.Lpf[Model_Target_B.yIdx];
            Model_Target_DW.Lpf_states[Model_Target_B.sample + 2] =
                (Model_Target_DW.Lpf_states[Model_Target_B.sample + 3] +
                 Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfNumerator[3] *
                 Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx])
                - Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfDenominator[3] *
                Model_Target_B.Lpf[Model_Target_B.yIdx];
            Model_Target_DW.Lpf_states[Model_Target_B.sample + 3] =
                Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfNumerator[4] *
                Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx] -
                Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfDenominator[4] *
                Model_Target_B.Lpf[Model_Target_B.yIdx];
            Model_Target_B.yIdx++;
        }
    }

    /* End of DiscreteFilter: '<S68>/Lpf' */

    /* Product: '<S68>/LPFFramify' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset] =
            rtb_Switch_iy;
    }

    /* End of Product: '<S68>/LPFFramify' */

    /* DiscreteFilter: '<S68>/ZipperNoiseReductionLpf' incorporates:
     *  Product: '<S68>/LPFFramify'
     *  S-Function (TOP_MEX): '<S72>/TOP1'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
            Model_Target_B.stateLen++)
    {
        Model_Target_B.ZipperNoiseReductionLpf[Model_Target_B.yIdx] =
            Model_Target_PreAmp_p4_b0.AudiopilotAntiZipperRampLpfNumerator *
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] +
            Model_Target_DW.ZipperNoiseReductionLpf_states;
        Model_Target_DW.ZipperNoiseReductionLpf_states = 0.0F -
            Model_Target_PreAmp_p4_b0.AudiopilotAntiZipperRampLpfDenominator[1] *
            Model_Target_B.ZipperNoiseReductionLpf[Model_Target_B.yIdx];
        Model_Target_B.yIdx++;
    }

    /* End of DiscreteFilter: '<S68>/ZipperNoiseReductionLpf' */

    /* MATLAB Function: '<S68>/ApplyLpfGain' */
    Model_Target_ApplyBpfGain(Model_Target_B.Lpf,
        Model_Target_B.ZipperNoiseReductionLpf, &Model_Target_B.sf_ApplyLpfGain);

    /* Product: '<S68>/WideFramify' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset] =
            Model_Target_B.max_h;
    }

    /* End of Product: '<S68>/WideFramify' */

    /* DiscreteFilter: '<S68>/ZipperNoiseReductionWide' incorporates:
     *  Product: '<S68>/WideFramify'
     *  S-Function (TOP_MEX): '<S72>/TOP1'
     */
    Model_Target_B.yIdx = 0;
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 32;
            Model_Target_B.stateLen++)
    {
        Model_Target_B.ZipperNoiseReductionWide[Model_Target_B.yIdx] =
            Model_Target_PreAmp_p4_b0.AudiopilotAntiZipperRampLpfNumerator *
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx] +
            Model_Target_DW.ZipperNoiseReductionWide_states;
        Model_Target_DW.ZipperNoiseReductionWide_states = 0.0F -
            Model_Target_PreAmp_p4_b0.AudiopilotAntiZipperRampLpfDenominator[1] *
            Model_Target_B.ZipperNoiseReductionWide[Model_Target_B.yIdx];
        Model_Target_B.yIdx++;
    }

    /* End of DiscreteFilter: '<S68>/ZipperNoiseReductionWide' */

    /* MATLAB Function: '<S68>/ApplyWideGain' incorporates:
     *  DiscreteFilter: '<S68>/ZipperNoiseReductionWide'
     */
    /*  This applies a frame of gains to the input audio */
    /*  It should work for any number of channels */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/GainApplication/Compensation/ApplyWideGain': '<S75>:1' */
    /* '<S75>:1:5' numchan = size(audio,2); */
    /* '<S75>:1:6' out = audio .* (gain * ones(1,numchan)); */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        memcpy(&Model_Target_B.Selector2_n[Model_Target_B.yIdx << 5],
               &Model_Target_B.ZipperNoiseReductionWide[0], sizeof(real32_T) <<
               5U);
    }

    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 64; Model_Target_B.yIdx
            ++)
    {
        Model_Target_B.Downsample2[Model_Target_B.yIdx] =
            Model_Target_B.sf_rgainyprocess.audioOut[Model_Target_B.yIdx] *
            Model_Target_B.Selector2_n[Model_Target_B.yIdx];
    }

    /* End of MATLAB Function: '<S68>/ApplyWideGain' */
    /* MATLAB Function: '<S84>/delay' */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S85>:1' */
    /*  figure out the frame size and channel count */
    /* '<S85>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S85>:1:8' frameSize = int32(frameSize); */
    /* '<S85>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S85>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S85>:1:11' delayTime = int32(delayTime); */
    /* '<S85>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S85>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S85>:1:23' bufferIndex = delayIndex; */
    Model_Target_B.xpageoffset = Model_Target_DW.delayIndex_ip;

    /* '<S85>:1:25' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        /*  Save writeIndex for next channel */
        /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
        /*  up the registers before any buffer access */
        /* '<S85>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset, 0, 76);

        /* '<S85>:1:32' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S85>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
            Model_Target_DW.delayBuffer_k[Model_Target_B.writeIndex] =
                Model_Target_B.Downsample2[(Model_Target_B.yIdx << 5) +
                Model_Target_B.sample];

            /*  increment write pointer */
            /* '<S85>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                76);
        }

        /*  Advance buffer index for next channel */
        /* '<S85>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 38,
            76);
    }

    /*  Reset */
    /* '<S85>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    Model_Target_B.xpageoffset = circindex(Model_Target_DW.delayIndex_ip, 32, 76);

    /* '<S85>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_ip = Model_Target_B.xpageoffset;

    /*  Read samples from delay line */
    /* '<S85>:1:50' for channel = 1:numChannels */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        /*  Setup read pointer */
        /* '<S85>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
        Model_Target_B.writeIndex = circindex(Model_Target_B.xpageoffset,
            -(Model_Target_PreAmp_p4_b0.AudiopilotMidrangeLpfAlignDelaySamples +
              32), 76);

        /* '<S85>:1:55' for sample = 1:frameSize */
        for (Model_Target_B.sample = 0; Model_Target_B.sample < 32;
                Model_Target_B.sample++)
        {
            /*  overwrite oldest sample with the current input sample */
            /* '<S85>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
            Model_Target_B.Downsample2[Model_Target_B.sample +
                (Model_Target_B.yIdx << 5)] =
                Model_Target_DW.delayBuffer_k[Model_Target_B.writeIndex];

            /*  increment write pointer */
            /* '<S85>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
            Model_Target_B.writeIndex = circindex(Model_Target_B.writeIndex, 1,
                76);
        }

        /*  Advance buffer index for next channel */
        /* '<S85>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
        Model_Target_B.xpageoffset = circindex(Model_Target_B.xpageoffset, 38,
            76);
    }

    /* End of MATLAB Function: '<S84>/delay' */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 64;
            Model_Target_B.xpageoffset++)
    {
        /* Sum: '<S68>/Sum' */
        Model_Target_B.Sum[Model_Target_B.xpageoffset] =
            (Model_Target_B.Downsample2[Model_Target_B.xpageoffset] +
             Model_Target_B.sf_ApplyLpfGain.out[Model_Target_B.xpageoffset]) +
            Model_Target_B.sf_ApplyBpfGain.out[Model_Target_B.xpageoffset];
    }

    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S107>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S142>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S143>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S144>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S145>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S171>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S173>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S107>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S192>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S193>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S195>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S196>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S232>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S233>/NTF Trigger' */

    /* RateTransition: '<S34>/Rate Transition9' */
    Model_Target_B.Max_g =
        Model_Target_DW.RateTransition9_Buffer[Model_Target_DW.RateTransition9_ActiveBufIdx];

    /* Switch: '<S487>/audiopilot' incorporates:
     *  MATLAB Function: '<S485>/PreProcess'
     */
    Model_Target_B.audiopilot = Model_Target_B.Delay3;

    /* Switch: '<S500>/dyneq' incorporates:
     *  MATLAB Function: '<S485>/PreProcess'
     */
    Model_Target_B.dyneq = Model_Target_B.Delay3;

    /* End of Outputs for S-Function (InitTriggerControl): '<S531>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S523>/ITC1' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S535>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S535>/NTF Trigger' */
    /* End of Outputs for S-Function (RTC_REQ_RSP): '<S564>/RTC Request Response Trigger' */
    /* End of Outputs for S-Function (RTC_NTF): '<S564>/NTF Trigger' */
    /* MATLAB Function: '<S563>/balanceProcess' incorporates:
     *  S-Function (TOP_MEX): '<S563>/TOP'
     *  Sum: '<S68>/Sum'
     */
    /*  % inputs */
    /*  parameters */
    /* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/Balance/Balance/balanceProcess': '<S574>:1' */
    /*  Applies the Left and Right gains to the respective channels via multiple */
    /*    rampers */
    /*  Inputs: */
    /*   audioIn: Input audio */
    /*   channelToRamperMap: Input channels mapped to their corresponding ramper. */
    /*   MaskNumRampers: Number of rampers (set in the Mask file) = 4 */
    /*  Data Store objects (registered in "Edit Data" dialog) */
    /*  Figure out the frame size, channel count and number of rampers */
    /* '<S574>:1:16' [frameSize, ~] = size(audioIn); */
    /*  set the size and datatype of the output buffer */
    /* '<S574>:1:19' audioOut = coder.nullcopy(audioIn); */
    /*    Every channel needs a ramper, but every ramper does not need to be on a */
    /*    channel necessarily. */
    /* '<S574>:1:23' for ramper = 1:MaskNumRampers */
    for (Model_Target_B.c = 0; Model_Target_B.c < 4; Model_Target_B.c++)
    {
        /*  Get the gains */
        /* '<S574>:1:25' gain = Rampers(ramper).currentGain; */
        Model_Target_B.max_h =
            Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c].
            currentGain;

        /* '<S574>:1:26' rampCoeffMultipliers = ones(1, frameSize, 'single'); */
        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 32;
                Model_Target_B.xpageoffset++)
        {
            Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.xpageoffset]
                = 1.0F;
        }

        /* '<S574>:1:27' if (Freeze(1) == false) */
        if (Model_TargetControlDsms.PreAmpBalance_CfgFreeze == 0U)
        {
            /* '<S574>:1:28' if (Rampers(ramper).frameCount == 0) */
            if (Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c]
                    .frameCount == 0)
            {
                /*  The ramp is finished. Stop ramping and SNAP to the target */
                /* '<S574>:1:30' gain = Rampers(ramper).targetGain; */
                Model_Target_B.max_h =
                    Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c]
                    .targetGain;
            }
            else
            {
                /* '<S574>:1:31' else */
                /*  The ramp is *NOT* frozen or done: gain is moving */
                /* '<S574>:1:33' k = Rampers(ramper).rampCoeff; */
                /* '<S574>:1:34' rampCoeffMultipliers = (k * rampCoeffMultipliers) .^ (1:frameSize); */
                for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 32;
                        Model_Target_B.yIdx++)
                {
                    Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx]
                        = qhmath_pow_f
                        (Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c]
                         .rampCoeff, (real32_T)((real_T)Model_Target_B.yIdx +
                          1.0));
                }

                /* '<S574>:1:35' Rampers(ramper).frameCount = Rampers(ramper).frameCount - 1; */
                Model_Target_B.xpageoffset =
                    Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c]
                    .frameCount;
                if (Model_Target_B.xpageoffset < -2147483647)
                {
                    Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c]
                        .frameCount = MIN_int32_T;
                }
                else
                {
                    Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c]
                        .frameCount = Model_Target_B.xpageoffset - 1;
                }
            }
        }

        /*  Apply the gains to the corresponding channels via the Mask parameter */
        /*  and tuneTop paramter "channelToRamperMap".   */
        /* '<S574>:1:41' currentChannelGroup = find(channelToRamperMap == ramper); */
        tmp[0] = ((real_T)(Model_Target_B.c + 1) ==
                  Model_Target_PreAmp_p11_b0.Balance_CfgChanRampMap[0]);
        tmp[1] = ((real_T)(Model_Target_B.c + 1) ==
                  Model_Target_PreAmp_p11_b0.Balance_CfgChanRampMap[1]);
        Model_Target_eml_find_a(tmp, Model_Target_B.d_data,
                                Model_Target_B.d_size);

        /* '<S574>:1:42' for ch = 1:numel(currentChannelGroup) */
        Model_Target_B.stateLen = Model_Target_B.d_size[1];
        for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset <
                Model_Target_B.stateLen; Model_Target_B.xpageoffset++)
        {
            /* '<S574>:1:43' audioOut(:,currentChannelGroup(ch)) = (gain * rampCoeffMultipliers)' .* audioIn(:,currentChannelGroup(ch)); */
            Model_Target_B.writeIndex =
                Model_Target_B.d_data[Model_Target_B.xpageoffset];
            for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 32;
                    Model_Target_B.yIdx++)
            {
                Model_Target_B.audioOut_n4[Model_Target_B.yIdx +
                    ((Model_Target_B.writeIndex - 1) << 5)] =
                    Model_Target_B.Sum[((Model_Target_B.writeIndex - 1) << 5) +
                    Model_Target_B.yIdx] * (Model_Target_B.max_h *
                    Model_Target_B.HeadrestMatrixConcatenate_a[Model_Target_B.yIdx]);
            }
        }

        /* '<S574>:1:45' Rampers(ramper).currentGain = gain * rampCoeffMultipliers(end); */
        Model_TargetControlDsms.PreAmpBalance_CfgRampers[Model_Target_B.c].
            currentGain = Model_Target_B.max_h *
            Model_Target_B.HeadrestMatrixConcatenate_a[31];
    }

    /*  If ramper value of -1 is encountered, this indicates an unused channel. */
    /*  Assign values of zero to all samples of these channels. */
    /* '<S574>:1:50' unusedChannelGroup = find(channelToRamperMap == -1); */
    tmp[0] = (Model_Target_PreAmp_p11_b0.Balance_CfgChanRampMap[0] == -1.0F);
    tmp[1] = (Model_Target_PreAmp_p11_b0.Balance_CfgChanRampMap[1] == -1.0F);
    Model_Target_eml_find_a(tmp, Model_Target_B.d_data, Model_Target_B.d_size);

    /* '<S574>:1:51' for unusedCh = 1:numel(unusedChannelGroup) */
    Model_Target_B.c = Model_Target_B.d_size[1];
    for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < Model_Target_B.c;
         Model_Target_B.stateLen++)
    {
        /* '<S574>:1:52' audioOut(:,unusedChannelGroup(unusedCh)) = 0; */
        Model_Target_B.writeIndex =
            Model_Target_B.d_data[Model_Target_B.stateLen];
        memset(&Model_Target_B.audioOut_n4[(Model_Target_B.writeIndex << 5) +
               -32], 0, sizeof(real32_T) << 5U);
    }

    /* End of MATLAB Function: '<S563>/balanceProcess' */

    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 1' */
    Model_Target_Medusa5H1Part1();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 1' */

    /* Delay: '<S1330>/Variable Integer Delay' */
    if (Model_Target_PreAmp_p13_b0.NearDelay < 1.0F)
    {
        /* Delay: '<S1330>/Variable Integer Delay' */
        memcpy(&Model_Target_B.VariableIntegerDelay[0],
               &Model_Target_B.LoRoLimpRimp[0], sizeof(real32_T) << 4U);
    }
    else
    {
        if (Model_Target_PreAmp_p13_b0.NearDelay > 100.0F)
        {
            Model_Target_B.b = 100U;
        }
        else
        {
            rtb_Switch_iy = fmodf(truncf(Model_Target_PreAmp_p13_b0.NearDelay),
                                  4.2949673E+9F);
            Model_Target_B.b = rtb_Switch_iy < 0.0F ? (uint32_T)-(int32_T)
                (uint32_T)-rtb_Switch_iy : (uint32_T)rtb_Switch_iy;
        }

        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                Model_Target_B.stateLen++)
        {
            if ((uint32_T)Model_Target_B.stateLen < Model_Target_B.b)
            {
                Model_Target_B.c = (Model_Target_B.stateLen - (int32_T)
                                    Model_Target_B.b) + 100;
                Model_Target_B.VariableIntegerDelay[Model_Target_B.stateLen] =
                    Model_Target_DW.VariableIntegerDelay_DSTATE[Model_Target_B.c];
                Model_Target_B.VariableIntegerDelay[Model_Target_B.stateLen + 8]
                    =
                    Model_Target_DW.VariableIntegerDelay_DSTATE[Model_Target_B.c
                    + 100];
            }
            else
            {
                Model_Target_B.c = Model_Target_B.stateLen - (int32_T)
                    Model_Target_B.b;
                Model_Target_B.VariableIntegerDelay[Model_Target_B.stateLen] =
                    Model_Target_B.LoRoLimpRimp[Model_Target_B.c];
                Model_Target_B.VariableIntegerDelay[Model_Target_B.stateLen + 8]
                    = Model_Target_B.LoRoLimpRimp[Model_Target_B.c + 8];
            }
        }
    }

    /* End of Delay: '<S1330>/Variable Integer Delay' */

    /* Gain: '<S1332>/Gain' */
    memcpy(&NearWiggle24579FirEvenInput[0], &Model_Target_B.LoRoLimpRimp[0],
           sizeof(real32_T) << 4U);

    /* MATLAB Function: '<S1337>/FirEvenProcess' incorporates:
     *  Constant: '<S1330>/Constant'
     *  Gain: '<S1332>/Gain'
     */
    /*  Extract configuration information from inputs */
    /* MATLAB Function 'FirEven/FirEven/Hexagon/FirEvenProcess': '<S1339>:1' */
    /* '<S1339>:1:4' [FilterLength, ~] = size(FlippedCoeffs); */
    /* '<S1339>:1:5' [FrameSize, NumChannels] = size(u); */
    /*  Initialize variables */
    /*  persistent States; */
    /*  if isempty(States) */
    /*      States = single(zeros(FilterLength + FrameSize*2 + 2, NumChannels)); */
    /*  end */
    /*  Set correct data types */
    /* '<S1339>:1:17' FilterLength = uint32(FilterLength); */
    /* '<S1339>:1:18' FrameSize = uint32(FrameSize); */
    /* '<S1339>:1:19' ActiveCoeffSet = uint32(ActiveCoeffSet); */
    /* '<S1339>:1:22' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S1339>:1:25' else */
    /*  FIR EVEN HEXAGON */
    /* '<S1339>:1:27' if (FilterLength > FrameSize) */
    /* '<S1339>:1:28' y = fireven_hexagon_process_mt(single(u), uint32(ActiveCoeffSet), single(States), uint32(CodeWorkMemory)); */
    Model_Target_B.uv[0] = 0U;
    Model_Target_B.uv[1] = 0U;
    fireven_process_mt(&Model_Target_B.Downsample[0],
                       &NearWiggle24579FirEvenInput[0], &Model_Target_B.uv[0],
                       &NearWiggle40274States[0],
                       &NearWiggle50534CodeWorkMemory[0]);

    /* MATLAB Function: '<S1331>/Crossfade ' incorporates:
     *  Delay: '<S1330>/Variable Integer Delay'
     */
    /*  fadetime in ms */
    /*  sigSelect = 0 passes normalEnt, sigSelect = 1 passes monoEnt */
    /* MATLAB Function 'CrossFader/Crossfade ': '<S1335>:1' */
    /*  first run init */
    /* '<S1335>:1:9' if (isempty(currentFadeInd)) */
    /*  Selection changed */
    /* '<S1335>:1:15' startFade = 0; */
    Model_Target_B.stateLen = 0;

    /* '<S1335>:1:16' if (currentSig ~= sigSelect) */
    if (Model_Target_DW.currentSig != Model_Target_B.y)
    {
        /*     currentSig = sigSelect; */
        /* '<S1335>:1:18' currentSig = uint32(sigSelect); */
        Model_Target_DW.currentSig = Model_Target_B.y;

        /* '<S1335>:1:19' currentFadeInd = 0; */
        Model_Target_DW.currentFadeInd = 0.0;

        /* '<S1335>:1:20' startFade = 1; */
        Model_Target_B.stateLen = 1;
    }

    /* '<S1335>:1:23' crossfadedOutput = single(zeros(size(normalEnt))); */
    /* '<S1335>:1:24' normalEntOutput = single(zeros(size(normalEnt))); */
    /* '<S1335>:1:25' monoEntOutput = single(zeros(size(normalEnt))); */
    /*  Process the audio */
    /* '<S1335>:1:28' if ((currentFadeInd ~= 0)||(startFade)) */
    if ((Model_Target_DW.currentFadeInd != 0.0) || (Model_Target_B.stateLen != 0))
    {
        /*  Apply the cross fade gains, either because we're mid-ramp or we're */
        /*  starting over */
        /* '<S1335>:1:31' for (samp = 1:size(normalEnt, 1) */
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                Model_Target_B.stateLen++)
        {
            /* '<S1335>:1:32' currentFadeInd = currentFadeInd + 1; */
            Model_Target_DW.currentFadeInd++;

            /*  lookup gains for this sample */
            /* '<S1335>:1:34' if (currentFadeInd > fadeSamples) */
            if (Model_Target_DW.currentFadeInd > Model_Target_ConstB.Product)
            {
                /*  we hit the end of the ramp, but we're still working */
                /*  a frame that was ramping */
                /* '<S1335>:1:37' if (currentSig) */
                if (Model_Target_DW.currentSig != 0U)
                {
                    /* '<S1335>:1:38' normalEntGain = 0; */
                    Model_Target_B.vncBoostGain_d = 0.0;

                    /* '<S1335>:1:39' monoEntGain = 1; */
                    Model_Target_B.Switch1 = 1.0;
                }
                else
                {
                    /* '<S1335>:1:40' else */
                    /* '<S1335>:1:41' normalEntGain = 1; */
                    Model_Target_B.vncBoostGain_d = 1.0;

                    /* '<S1335>:1:42' monoEntGain = 0; */
                    Model_Target_B.Switch1 = 0.0;
                }

                /* '<S1335>:1:44' else */
                /*  actively ramping */
                /* '<S1335>:1:46' if (currentSig) */
            }
            else if (Model_Target_DW.currentSig != 0U)
            {
                /*                  sig1Gain = fadeDownGain(currentFadeInd); */
                /* '<S1335>:1:48' normalEntGain = 1-(currentFadeInd/fadeSamples); */
                Model_Target_B.Switch1 = Model_Target_DW.currentFadeInd /
                    Model_Target_ConstB.Product;
                Model_Target_B.vncBoostGain_d = 1.0 - Model_Target_B.Switch1;

                /*                  sig2Gain = fadeUpGain(currentFadeInd); */
                /* '<S1335>:1:50' monoEntGain = (currentFadeInd/fadeSamples); */
            }
            else
            {
                /* '<S1335>:1:51' else */
                /*                  sig1Gain = fadeUpGain(currentFadeInd); */
                /* '<S1335>:1:53' normalEntGain = (currentFadeInd/fadeSamples); */
                Model_Target_B.vncBoostGain_d = Model_Target_DW.currentFadeInd /
                    Model_Target_ConstB.Product;

                /*                  sig2Gain = fadeDownGain(currentFadeInd); */
                /* '<S1335>:1:55' monoEntGain = 1-(currentFadeInd/fadeSamples); */
                Model_Target_B.Switch1 = 1.0 - Model_Target_DW.currentFadeInd /
                    Model_Target_ConstB.Product;
            }

            /*  apply gains */
            /* '<S1335>:1:59' normalEntOutput(samp,:) = (normalEnt(samp,:)*normalEntGain); */
            /* '<S1335>:1:60' monoEntOutput(samp,:) = (monoEnt(samp,:)*monoEntGain); */
            /* '<S1335>:1:61' crossfadedOutput(samp,:) = single(normalEnt(samp,:)*normalEntGain + monoEnt(samp,:)*monoEntGain); */
            Model_Target_B.crossfadedOutput[Model_Target_B.stateLen] =
                Model_Target_B.VariableIntegerDelay[Model_Target_B.stateLen] *
                (real32_T)Model_Target_B.vncBoostGain_d +
                Model_Target_B.Downsample[Model_Target_B.stateLen] * (real32_T)
                Model_Target_B.Switch1;
            Model_Target_B.crossfadedOutput[Model_Target_B.stateLen + 8] =
                Model_Target_B.VariableIntegerDelay[Model_Target_B.stateLen + 8]
                * (real32_T)Model_Target_B.vncBoostGain_d +
                Model_Target_B.Downsample[Model_Target_B.stateLen + 8] *
                (real32_T)Model_Target_B.Switch1;
        }

        /*  reset fade if finished */
        /* '<S1335>:1:64' if (currentFadeInd > fadeSamples) */
        if (Model_Target_DW.currentFadeInd > Model_Target_ConstB.Product)
        {
            /* '<S1335>:1:65' currentFadeInd = 0; */
            Model_Target_DW.currentFadeInd = 0.0;
        }

        /* '<S1335>:1:67' else */
        /*  Just pass selected signal */
        /* '<S1335>:1:69' if (currentSig) */
    }
    else if (Model_Target_DW.currentSig != 0U)
    {
        /* '<S1335>:1:70' crossfadedOutput = single(monoEnt(1:size(normalEnt,1),1:size(normalEnt,2))); */
        memcpy(&Model_Target_B.crossfadedOutput[0], &Model_Target_B.Downsample[0],
               sizeof(real32_T) << 4U);
    }
    else
    {
        /* '<S1335>:1:71' else */
        /* '<S1335>:1:72' crossfadedOutput = single(normalEnt); */
        memcpy(&Model_Target_B.crossfadedOutput[0],
               &Model_Target_B.VariableIntegerDelay[0], sizeof(real32_T) << 4U);
    }

    /* End of MATLAB Function: '<S1331>/Crossfade ' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1341>/ITC1' */
    /* End of Outputs for S-Function (InitTriggerControl): '<S1340>/ITC1' */
    /* Update for Delay: '<S1330>/Variable Integer Delay' */
    for (Model_Target_B.c = 0; Model_Target_B.c < 2; Model_Target_B.c++)
    {
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 92;
                Model_Target_B.stateLen++)
        {
            Model_Target_B.xpageoffset = Model_Target_B.c * 100 +
                Model_Target_B.stateLen;
            Model_Target_DW.VariableIntegerDelay_DSTATE[Model_Target_B.xpageoffset]
                =
                Model_Target_DW.VariableIntegerDelay_DSTATE[Model_Target_B.xpageoffset
                + 8];
        }
    }

    memcpy(&Model_Target_B.Downsample[0], &Model_Target_B.LoRoLimpRimp[0],
           sizeof(real32_T) << 4U);
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 2; Model_Target_B.yIdx++)
    {
        for (Model_Target_B.stateLen = 0; Model_Target_B.stateLen < 8;
                Model_Target_B.stateLen++)
        {
            Model_Target_DW.VariableIntegerDelay_DSTATE[(Model_Target_B.stateLen
                + 100 * Model_Target_B.yIdx) + 92] = Model_Target_B.Downsample
                [(Model_Target_B.yIdx << 3) + Model_Target_B.stateLen];
        }
    }

    /* End of Update for Delay: '<S1330>/Variable Integer Delay' */
    /* End of Outputs for SubSystem: '<S33>/NearWiggleFilters' */

    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 2' */
    Model_Target_Medusa5H1Part2TID2();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 2' */

    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 3' */
    Model_Target_Medusa5H1Part3();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 3' */

    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 4' */
    Model_Target_Medusa5H1Part4();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 4' */

    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 5' */
    Model_Target_Medusa5H1Part5();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 5' */

    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 6' */
    Model_Target_Medusa5H1Part6();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 6' */

    /* Outputs for Atomic SubSystem: '<S33>/SleepingBeauty' */
    /* Outputs for Atomic SubSystem: '<S1345>/Enabled' */
    Model_Target_Enabled();

    /* End of Outputs for SubSystem: '<S1345>/Enabled' */

    /* Outputs for Atomic SubSystem: '<S33>/VLS' */
    Model_Target_VLS();

    /* End of Outputs for SubSystem: '<S33>/VLS' */

    /* Outputs for Atomic SubSystem: '<S33>/MedusaPostHoligram' */
    /* Sum: '<S559>/Add' incorporates:
     *  Assignment: '<S1657>/Assignment'
     *  Selector: '<S1346>/Selector'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 144;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_MedusaPostHoligram_B.MatrixConcatenate[Model_Target_B.xpageoffset]
            = Model_Target_B.PreAmp2NonHrDr[Model_Target_B.xpageoffset] +
            Model_Target_B.Assignment_b[Model_Target_B.xpageoffset];
    }

    /* End of Sum: '<S559>/Add' */

    /* Sum: '<S559>/Add1' incorporates:
     *  Concatenate: '<S5>/Matrix Concatenate'
     */
    for (Model_Target_B.xpageoffset = 0; Model_Target_B.xpageoffset < 704;
            Model_Target_B.xpageoffset++)
    {
        Model_Target_B.FRIn[Model_Target_B.xpageoffset] =
            Model_Target_B.sf_fade_l.audioOut[Model_Target_B.xpageoffset] +
            Model_Target_B.MatrixConcatenate_g[Model_Target_B.xpageoffset];
    }

    /* End of Sum: '<S559>/Add1' */

    /* Outputs for Atomic SubSystem: '<S559>/MedusaPostHoligram' */
    Model_Target_MedusaPostHoligram();

    /* End of Outputs for SubSystem: '<S559>/MedusaPostHoligram' */

    /* Outputs for Atomic SubSystem: '<S4>/SrcUp' */
    Model_Target_SrcUpTID2();

    /* End of Outputs for SubSystem: '<S4>/SrcUp' */

    /* Update for Delay: '<S30>/Delay3' */
    Model_Target_DW.Delay3_DSTATE = Model_Target_B.Max_g;

    /* Update for Atomic SubSystem: '<S4>/PreAmpPart1' */
    Model_Target_PreAmpPart1_Update();

    /* End of Update for SubSystem: '<S4>/PreAmpPart1' */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 3968;
            Model_Target_B.yIdx++)
    {
        /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
        /* Update for Delay: '<S32>/Delay2' */
        Model_Target_DW.Delay2_DSTATE[Model_Target_B.yIdx] =
            Model_Target_DW.Delay2_DSTATE[Model_Target_B.yIdx + 128];

        /* End of Update for SubSystem: '<S25>/AudioPilot35' */
    }

    /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Update for Delay: '<S32>/Delay2' incorporates:
     *  Selector: '<S586>/Selector1'
     */
    memcpy(&Model_Target_DW.Delay2_DSTATE[3968], &Model_Target_B.LoRoLimpRimp[0],
           sizeof(real32_T) << 7U);

    /* End of Update for SubSystem: '<S25>/AudioPilot35' */
    for (Model_Target_B.yIdx = 0; Model_Target_B.yIdx < 992; Model_Target_B.yIdx
            ++)
    {
        /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
        /* Update for Delay: '<S32>/Delay1' */
        Model_Target_DW.Delay1_DSTATE_lo[Model_Target_B.yIdx] =
            Model_Target_DW.Delay1_DSTATE_lo[Model_Target_B.yIdx + 32];

        /* End of Update for SubSystem: '<S25>/AudioPilot35' */
    }

    /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Update for Delay: '<S32>/Delay1' incorporates:
     *  S-Function (sdspstatfcns): '<S585>/Mean'
     */
    memcpy(&Model_Target_DW.Delay1_DSTATE_lo[992], &Model_Target_B.Mean[0],
           sizeof(real32_T) << 5U);

    /* Update for M-S-Function: '<S46>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotVehicleSpeed '<S46>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 37,
                    &(Model_TargetPreAmpAudiopilotsetSpeedInRtcOut.REQ_speedIn));

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S41>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHvacDbspl '<S41>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 13, &Model_Target_B.hvacDbspl);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S227>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseDbspl '<S227>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 15, &Model_Target_B.LFNoise);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S230>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotWbNoiseDbspl '<S230>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 38, &Model_Target_B.WBNoise);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S225>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseDbspl '<S225>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 6, &Model_Target_B.HFNoise);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S228>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotNoiseRatio '<S228>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 32, &Model_Target_B.Ratio);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S229>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotTotalBassBoostDb '<S229>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 36, &Model_Target_B.Min);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S222>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotMidrangeBoostDb '<S222>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 2, &Model_Target_B.Product1);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S223>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotTrebleBoostDb '<S223>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 3, &Model_Target_B.Product_h5);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S224>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotDyneqBassBoostDb '<S224>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 4, &Model_Target_B.Product3);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S221>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotBassBoostDb '<S221>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 0, &Model_Target_B.Product2);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S226>/TSP' incorporates:
     *  Constant: '<S34>/IgnoreMicFlag'
     */
    // TSP advanced triggered capture for PreAmpAudiopilotIgnoreMicFlag '<S226>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 14, &Model_Target_ConstP.pooled109);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S235>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotAudiopilotBoostGain '<S235>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 1,
                    &Model_Target_B.audiopilot_boost_gain);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S236>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotDyneqBoostGain '<S236>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 5, &Model_Target_B.dyneq_boost_gain);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S496>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchAudiopilotEnvDb '<S496>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 39, &Model_Target_B.audiopilot);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S497>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchAudiopilotLevelDbspl '<S497>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 40, &Model_Target_B.sf_InnerLink.level);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S509>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchDyneqEnvDb '<S509>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 41, &Model_Target_B.dyneq);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S510>/TSP' */
    // TSP advanced triggered capture for PreAmpLevelWatchDyneqLevelDbspl '<S510>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 42,
                    &Model_Target_B.sf_InnerLink_a.level);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S25>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S558>/Medusa5H1 Part 3' */
    Model_Target_Medusa5H1Part3_Update();

    /* End of Update for SubSystem: '<S558>/Medusa5H1 Part 3' */
}

/* Model step function for TID3 */
void Model_Target_step3(void)  /* Sample time: [0.0014444444444444444s, 0.0s] */
{
    int32_T bufferIndex;
    int32_T currentOffset;
    int32_T offsetFromMemBase;
    int32_T uyIdx;

    /* Outputs for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Buffer: '<S356>/BufferRef' */
    for (bufferIndex = 0; bufferIndex < 64; bufferIndex++)
    {
        Model_Target_B.BufferRef[bufferIndex] =
            Model_Target_DW.BufferRef_CircBuf[Model_Target_DW.BufferRef_outBufPtrIdx
            + bufferIndex];
    }

    bufferIndex = Model_Target_DW.BufferRef_outBufPtrIdx + 64;
    if (Model_Target_DW.BufferRef_outBufPtrIdx + 64 == 128)
    {
        bufferIndex = 0;
    }

    Model_Target_DW.BufferRef_outBufPtrIdx = bufferIndex;

    /* End of Buffer: '<S356>/BufferRef' */
    /* MATLAB Function: '<S431>/delay' incorporates:
     *  Buffer: '<S356>/BufferRef'
     *  Concatenate: '<S353>/Matrix Concatenate1'
     *  DownSample: '<S356>/DownsampleRef'
     */
    /*  Our delayline lives in global variable. We treat as a circular buffer.  */
    /* MATLAB Function 'Delay/delay': '<S432>:1' */
    /*  figure out the frame size and channel count */
    /* '<S432>:1:7' [frameSize, numChannels] = size(audioIn); */
    /* '<S432>:1:8' frameSize = int32(frameSize); */
    /* '<S432>:1:9' stateLen = int32(maxDelayTime)+frameSize; */
    /* '<S432>:1:10' totalLen = int32(stateLen * numChannels); */
    /* '<S432>:1:11' delayTime = int32(delayTime); */
    /* '<S432>:1:12' audioOut = coder.nullcopy(audioIn); */
    /*  writeIndex points to our current write location in buffer */
    /* '<S432>:1:16' if isempty(delayIndex) */
    /*  delayBuffer is a circular buffer that holds previous samples */
    /*  Write data to delay buffer */
    /* '<S432>:1:23' bufferIndex = delayIndex; */
    /* '<S432>:1:25' for channel = 1:numChannels */
    /*  Save writeIndex for next channel */
    /*  Instead of writeIndex = bufferIndex, this calls into circindex to set */
    /*  up the registers before any buffer access */
    /* '<S432>:1:30' writeIndex = circindex(bufferIndex, int32(0), totalLen); */
    /* '<S432>:1:32' for sample = 1:frameSize */
    /*  overwrite oldest sample with the current input sample */
    /* '<S432>:1:35' delayBuffer(writeIndex + 1) = audioIn(sample, channel); */
    Model_Target_DW.delayBuffer_g[circindex(Model_Target_DW.delayIndex_k, 0, 70)]
        = Model_Target_B.BufferRef[0];

    /*  increment write pointer */
    /* '<S432>:1:38' writeIndex = circindex(writeIndex, int32(1), totalLen); */
    /*  Advance buffer index for next channel */
    /* '<S432>:1:42' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
    /*  Reset */
    /* '<S432>:1:46' bufferIndex = circindex(delayIndex, frameSize, totalLen); */
    bufferIndex = circindex(Model_Target_DW.delayIndex_k, 1, 70);

    /* '<S432>:1:47' delayIndex = bufferIndex; */
    Model_Target_DW.delayIndex_k = bufferIndex;

    /*  Read samples from delay line */
    /* '<S432>:1:50' for channel = 1:numChannels */
    /*  Setup read pointer */
    /* '<S432>:1:53' readIndex = circindex(bufferIndex, -(delayTime+frameSize), totalLen); */
    /* '<S432>:1:55' for sample = 1:frameSize */
    /*  overwrite oldest sample with the current input sample */
    /* '<S432>:1:58' audioOut(sample, channel) = delayBuffer(readIndex + 1); */
    Model_Target_B.MatrixConcatenate1[0] =
        Model_Target_DW.delayBuffer_g[circindex(bufferIndex,
        -(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseRefLatencySamples + 1), 70)];

    /* Buffer: '<S356>/BufferMic' */
    /*  increment write pointer */
    /* '<S432>:1:61' readIndex = circindex(readIndex, int32(1), totalLen); */
    /*  Advance buffer index for next channel */
    /* '<S432>:1:66' bufferIndex = circindex(bufferIndex, stateLen, totalLen); */
    for (bufferIndex = 0; bufferIndex < 64; bufferIndex++)
    {
        Model_Target_B.BufferMic[bufferIndex] =
            Model_Target_DW.BufferMic_CircBuf[Model_Target_DW.BufferMic_outBufPtrIdx
            + bufferIndex];
    }

    currentOffset = Model_Target_DW.BufferMic_outBufPtrIdx + 64;
    if (Model_Target_DW.BufferMic_outBufPtrIdx + 64 == 128)
    {
        currentOffset = 0;
    }

    Model_Target_DW.BufferMic_outBufPtrIdx = currentOffset;

    /* End of Buffer: '<S356>/BufferMic' */

    /* DownSample: '<S356>/DownsampleMic' incorporates:
     *  Buffer: '<S356>/BufferMic'
     *  Concatenate: '<S353>/Matrix Concatenate1'
     */
    Model_Target_B.MatrixConcatenate1[1] = Model_Target_B.BufferMic[0];

    /* Buffer: '<S369>/Buffer' incorporates:
     *  Concatenate: '<S353>/Matrix Concatenate1'
     */
    currentOffset = 0;
    uyIdx = 1;
    offsetFromMemBase = Model_Target_DW.Buffer_inBufPtrIdx_g;
    if (Model_Target_DW.Buffer_inBufPtrIdx_g > 511)
    {
        currentOffset = 512 - Model_Target_DW.Buffer_inBufPtrIdx_g;
        offsetFromMemBase = 0;
        uyIdx = Model_Target_DW.Buffer_inBufPtrIdx_g - 511;
    }

    for (bufferIndex = 0; bufferIndex < uyIdx; bufferIndex++)
    {
        Model_Target_DW.Buffer_CircBuf_d[offsetFromMemBase + bufferIndex] =
            Model_Target_B.MatrixConcatenate1[currentOffset + bufferIndex];
    }

    currentOffset += uyIdx;
    uyIdx = 1;
    offsetFromMemBase = Model_Target_DW.Buffer_inBufPtrIdx_g + 512;
    if (Model_Target_DW.Buffer_inBufPtrIdx_g > 511)
    {
        currentOffset = (currentOffset - Model_Target_DW.Buffer_inBufPtrIdx_g) +
            512;
        offsetFromMemBase = 512;
        uyIdx = Model_Target_DW.Buffer_inBufPtrIdx_g - 511;
    }

    for (bufferIndex = 0; bufferIndex < uyIdx; bufferIndex++)
    {
        Model_Target_DW.Buffer_CircBuf_d[offsetFromMemBase + bufferIndex] =
            Model_Target_B.MatrixConcatenate1[currentOffset + bufferIndex];
    }

    Model_Target_DW.Buffer_inBufPtrIdx_g++;
    if (Model_Target_DW.Buffer_inBufPtrIdx_g >= 512)
    {
        Model_Target_DW.Buffer_inBufPtrIdx_g -= 512;
    }

    /* End of Buffer: '<S369>/Buffer' */
    /* End of Outputs for SubSystem: '<S25>/AudioPilot35' */
}

/* Model step function for TID4 */
void Model_Target_step4(void)  /* Sample time: [0.0028888888888888892s, 0.0s] */
{
    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 2' */
    Model_Target_Medusa5H1Part2TID4();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 2' */
}

/* Model step function for TID5 */
void Model_Target_step5(void)   /* Sample time: [0.011555555555555557s, 0.0s] */
{
    /* Outputs for Atomic SubSystem: '<S558>/Medusa5H1 Part 2' */
    Model_Target_Medusa5H1Part2TID5();

    /* End of Outputs for SubSystem: '<S558>/Medusa5H1 Part 2' */
}

/* Model step function for TID6 */
void Model_Target_step6(void)    /* Sample time: [0.04622222222222222s, 0.0s] */
{
    creal32_T tmp[65];
    creal32_T a[25];
    creal32_T a_0;
    creal32_T *rtb_Selector_e_0;
    int32_T RfftRefRfftInput_tmp;
    int32_T c_i;
    int32_T chanIdx;
    int32_T chanIdx_tmp;
    int32_T i;
    int32_T i_0;
    int32_T loop_ub;
    int32_T re_tmp;
    real32_T IRGlobalMin[65];
    real32_T b_x_data[65];
    real32_T rtb_u[65];
    real32_T Change;
    real32_T Slew;
    real32_T acc;
    real32_T acc_0;
    real32_T rtb_log10;
    boolean_T GnnUpdate;

    /* Outputs for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Buffer: '<S271>/Buffer' */
    i_0 = 0;
    for (chanIdx = 0; chanIdx < 6; chanIdx++)
    {
        RfftRefRfftInput_tmp = Model_Target_DW.Buffer_outBufPtrIdx_d - 128;
        if (Model_Target_DW.Buffer_outBufPtrIdx_d - 128 < 0)
        {
            RfftRefRfftInput_tmp = Model_Target_DW.Buffer_outBufPtrIdx_d + 384;
        }

        loop_ub = 256;
        if (RfftRefRfftInput_tmp > 256)
        {
            c_i = (chanIdx << 9) + RfftRefRfftInput_tmp;
            for (i = 0; i < 512 - RfftRefRfftInput_tmp; i++)
            {
                Model_Target_B.Buffer_e[i_0 + i] =
                    Model_Target_DW.Buffer_CircBuf_c[c_i + i];
            }

            i_0 = (i_0 - RfftRefRfftInput_tmp) + 512;
            loop_ub = RfftRefRfftInput_tmp - 256;
            RfftRefRfftInput_tmp = 0;
        }

        c_i = (chanIdx << 9) + RfftRefRfftInput_tmp;
        for (i = 0; i < loop_ub; i++)
        {
            Model_Target_B.Buffer_e[i_0 + i] =
                Model_Target_DW.Buffer_CircBuf_c[c_i + i];
        }

        i_0 += loop_ub;
        RfftRefRfftInput_tmp += loop_ub;
    }

    if (RfftRefRfftInput_tmp == 512)
    {
        RfftRefRfftInput_tmp = 0;
    }

    Model_Target_DW.Buffer_outBufPtrIdx_d = RfftRefRfftInput_tmp;

    /* End of Buffer: '<S271>/Buffer' */

    /* MATLAB Function: '<S272>/Windowing' incorporates:
     *  Buffer: '<S271>/Buffer'
     *  Constant: '<S271>/const'
     */
    memcpy(&RfftRefRfftInput[0], &Model_Target_B.Buffer_e[0], 1536U * sizeof
           (real32_T));

    /*  Get sizes */
    /* MATLAB Function 'RfftWindowing/Windowing': '<S274>:1' */
    /* '<S274>:1:4' [~, numChannels] = size(u); */
    /*  Loop since array-vector multiply operation doesn't work here */
    /*  Input/Output have the same variable name for in-place processing */
    /* '<S274>:1:8' for i = 1:numChannels */
    for (i = 0; i < 6; i++)
    {
        /* '<S274>:1:9' u(:, i) = u(:,i) .* win; */
        for (i_0 = 0; i_0 < 256; i_0++)
        {
            RfftRefRfftInput_tmp = (i << 8) + i_0;
            RfftRefRfftInput[RfftRefRfftInput_tmp] =
                RfftRefRfftInput[RfftRefRfftInput_tmp] *
                Model_Target_ConstP.pooled51[i_0];
        }
    }

    /* End of MATLAB Function: '<S272>/Windowing' */

    /* MATLAB Function: '<S276>/MATLAB Function1' */
    /*  Computes the Real FFT of a Multi-Channel Signal.  */
    /*  During Code Generation, hexagon rfft crl function is used. */
    /*  Inputs: */
    /*      u - purely real signal.  */
    /*          size = [fftSize, numChannels] */
    /*      fftSize - size of each input channel. Also the size of FFT */
    /*  Outputs: */
    /*      y - fftSize/2 + 1 unique FFT coefficients of each channel of u. */
    /*          size = [fftSize/2 + 1, numChannels] */
    /*  ------------------------------------------------------------------------- */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function1': '<S279>:1' */
    /* '<S279>:1:17' numChannels = size(u, 2); */
    /* '<S279>:1:18' spectrumSize = (fftSize/2) + 1; */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S279>:1:21' y = coder.nullcopy(complex(single(zeros(spectrumSize, numChannels)))); */
    /*  Simulation */
    /* '<S279>:1:24' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S279>:1:27' else */
    /* '<S279>:1:28' y = rfft_process(single(u), Twiddle1, Twiddle2, RfftOutputTmp, int32(fftSize), int32(numChannels)); */
    rfft_process(&Model_Target_B.fcv[0], &RfftRefRfftInput[0],
                 &RfftRefRfftBufferTwiddle1[0], &RfftRefRfftBufferTwiddle2[0],
                 &RfftRefRfftBufferRfftOutputTmp[0], 256, 6);

    /* Selector: '<S270>/Selector' incorporates:
     *  MATLAB Function: '<S276>/MATLAB Function1'
     */
    rtb_Selector_e_0 = &Model_Target_B.fcv[0];

    /* MATLAB Function: '<S253>/FormCoherenceMatrixGXY' incorporates:
     *  Constant: '<S253>/Constant1'
     *  Selector: '<S270>/Selector'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /FormCoherenceMatrixGXY': '<S258>:1' */
    /* '<S258>:1:3' K = HFWELCHSIZE; */
    /*  K: size of Welch window */
    /* '<S258>:1:4' L = ceil(size(StftIn,1)/2); */
    /*  L: number frequency bins */
    /* '<S258>:1:5' M = size(StftIn,2); */
    /*  M: mic + number of ref channels */
    /*  Initialize states */
    /* '<S258>:1:11' if isempty(GXY) */
    /* '<S258>:1:14' if isempty(frame_counter) */
    /*  Modulo K Counter */
    /* '<S258>:1:19' if frame_counter < K */
    if (Model_Target_DW.frame_counter < 16)
    {
        /*  frame counter increment */
        /* '<S258>:1:21' frame_counter = frame_counter + int16(1); */
        Model_Target_DW.frame_counter++;
    }
    else
    {
        /* '<S258>:1:22' else */
        /*  reset frame counter */
        /* '<S258>:1:24' frame_counter = int16(1); */
        Model_Target_DW.frame_counter = 1;
    }

    /* '<S258>:1:28' if frame_counter < K */
    if (Model_Target_DW.frame_counter < 16)
    {
        /*  Reset at the first frame */
        /* '<S258>:1:30' if frame_counter == 1 */
        if (Model_Target_DW.frame_counter == 1)
        {
            /* '<S258>:1:31' GXY = complex(single(zeros(L,M,M))); */
            memset(&Model_Target_DW.GXY[0], 0, 1625U * sizeof(creal32_T));
        }

        /*  Accumulate */
        /* '<S258>:1:34' for i = 1:M */
        for (i = 0; i < 5; i++)
        {
            /* '<S258>:1:35' for j = i:M */
            RfftRefRfftInput_tmp = 4 - i;
            for (i_0 = 0; i_0 <= RfftRefRfftInput_tmp; i_0++)
            {
                loop_ub = i + i_0;

                /*  Loop over the lower triangular matrix (including the diagonal) */
                /* '<S258>:1:37' EXY = (conj((2*StftIn(1:2:end,i)))) .* (2*StftIn(1:2:end,j)); */
                /* '<S258>:1:38' GXY(:,i,j) = GXY(:,i,j)+ EXY/K; */
                for (chanIdx_tmp = 0; chanIdx_tmp < 65; chanIdx_tmp++)
                {
                    c_i = chanIdx_tmp << 1;
                    re_tmp = 129 * i + c_i;
                    acc = rtb_Selector_e_0[re_tmp].re * 2.0F;
                    acc_0 = -(rtb_Selector_e_0[re_tmp].im * 2.0F);
                    re_tmp = 129 * loop_ub + c_i;
                    rtb_log10 = rtb_Selector_e_0[re_tmp].re * 2.0F;
                    Change = rtb_Selector_e_0[re_tmp].im * 2.0F;
                    Slew = acc * rtb_log10 - acc_0 * Change;
                    acc_0 = acc * Change + acc_0 * rtb_log10;
                    if (acc_0 == 0.0F)
                    {
                        acc = qhmath_div_f(Slew, 16.0F);
                        acc_0 = 0.0F;
                    }
                    else if (Slew == 0.0F)
                    {
                        acc = 0.0F;
                        acc_0 = qhmath_div_f(acc_0, 16.0F);
                    }
                    else
                    {
                        acc = qhmath_div_f(Slew, 16.0F);
                        acc_0 = qhmath_div_f(acc_0, 16.0F);
                    }

                    c_i = (65 * i + chanIdx_tmp) + 325 * loop_ub;
                    tmp[chanIdx_tmp].re = Model_Target_DW.GXY[c_i].re + acc;
                    tmp[chanIdx_tmp].im = Model_Target_DW.GXY[c_i].im + acc_0;
                }

                memcpy(&Model_Target_DW.GXY[i * 65 + loop_ub * 325], &tmp[0],
                       65U * sizeof(creal32_T));
            }
        }

        /* '<S258>:1:41' GnnUpdate = false; */
        GnnUpdate = false;
    }
    else
    {
        /* '<S258>:1:42' else */
        /*  Last Frame */
        /* '<S258>:1:44' for i = 1:M */
        for (i_0 = 0; i_0 < 5; i_0++)
        {
            /* '<S258>:1:45' for j = i:M */
            chanIdx = 4 - i_0;
            for (i = 0; i <= chanIdx; i++)
            {
                loop_ub = i_0 + i;

                /*  Loop over the lower triangular matrix (including the diagonal) */
                /* '<S258>:1:47' EXY = (conj((2*StftIn(1:2:end,i)))) .* (2*StftIn(1:2:end,j)); */
                /* '<S258>:1:48' GXY(:,i,j) = GXY(:,i,j)+ EXY/K; */
                for (RfftRefRfftInput_tmp = 0; RfftRefRfftInput_tmp < 65;
                        RfftRefRfftInput_tmp++)
                {
                    c_i = RfftRefRfftInput_tmp << 1;
                    re_tmp = 129 * i_0 + c_i;
                    acc = rtb_Selector_e_0[re_tmp].re * 2.0F;
                    acc_0 = -(rtb_Selector_e_0[re_tmp].im * 2.0F);
                    re_tmp = 129 * loop_ub + c_i;
                    rtb_log10 = rtb_Selector_e_0[re_tmp].re * 2.0F;
                    Change = rtb_Selector_e_0[re_tmp].im * 2.0F;
                    Slew = acc * rtb_log10 - acc_0 * Change;
                    acc_0 = acc * Change + acc_0 * rtb_log10;
                    if (acc_0 == 0.0F)
                    {
                        acc = qhmath_div_f(Slew, 16.0F);
                        acc_0 = 0.0F;
                    }
                    else if (Slew == 0.0F)
                    {
                        acc = 0.0F;
                        acc_0 = qhmath_div_f(acc_0, 16.0F);
                    }
                    else
                    {
                        acc = qhmath_div_f(Slew, 16.0F);
                        acc_0 = qhmath_div_f(acc_0, 16.0F);
                    }

                    chanIdx_tmp = (65 * i_0 + RfftRefRfftInput_tmp) + 325 *
                        loop_ub;
                    tmp[RfftRefRfftInput_tmp].re =
                        Model_Target_DW.GXY[chanIdx_tmp].re + acc;
                    tmp[RfftRefRfftInput_tmp].im =
                        Model_Target_DW.GXY[chanIdx_tmp].im + acc_0;
                }

                memcpy(&Model_Target_DW.GXY[i_0 * 65 + loop_ub * 325], &tmp[0],
                       65U * sizeof(creal32_T));
            }

            /* '<S258>:1:50' for j = 1:i-1 */
            for (chanIdx = 0; chanIdx < i_0; chanIdx++)
            {
                /*  Construct full matrix when Welch window size is met */
                /* '<S258>:1:52' GXY(:,i,j) = conj(GXY(:,j,i)); */
                for (RfftRefRfftInput_tmp = 0; RfftRefRfftInput_tmp < 65;
                        RfftRefRfftInput_tmp++)
                {
                    loop_ub = (65 * chanIdx + RfftRefRfftInput_tmp) + 325 * i_0;
                    tmp[RfftRefRfftInput_tmp].re = Model_Target_DW.GXY[loop_ub].
                        re;
                    tmp[RfftRefRfftInput_tmp].im = -Model_Target_DW.GXY[loop_ub]
                        .im;
                }

                memcpy(&Model_Target_DW.GXY[i_0 * 65 + chanIdx * 325], &tmp[0],
                       65U * sizeof(creal32_T));
            }
        }

        /* '<S258>:1:55' GnnUpdate = true; */
        GnnUpdate = true;
    }

    /* S-Function (TOP_MEX): '<S263>/RefPowerMin' */
    /* '<S258>:1:57' GXYOut = GXY; */
    /* If: '<S259>/If' incorporates:
     *  MATLAB Function: '<S253>/FormCoherenceMatrixGXY'
     */
    if (GnnUpdate)
    {
        /* Outputs for IfAction SubSystem: '<S259>/If Action Subsystem' incorporates:
         *  ActionPort: '<S264>/Action Port'
         */
        /*  global GXY; */
        /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /GaussianElimination/If Action Subsystem/GaussianElimination': '<S267>:1' */
        /* '<S267>:1:6' u = GXY; */
        /* '<S267>:1:7' M = size(u,1); */
        /*  Number of frequency bins */
        /* '<S267>:1:8' N = size(u,2); */
        /*  Size of coherence matrix */
        /*  Vectors of Noise */
        /* '<S267>:1:11' c = single(zeros(M,1)); */
        /* '<S267>:1:12' Gyy = real(u(:,N,N)); */
        /* '<S267>:1:14' for i = 1:M */
        /*  For coherence that is higher than threshold (meaning noise is low), we will enhance it to avoid */
        /*  overestimation at low noise level */
        /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /GaussianElimination/If Action Subsystem/CoherenceModifier': '<S266>:1' */
        /* '<S266>:1:5' N = length(u); */
        /* '<S266>:1:6' threshold = 0.88; */
        /* y = u; */
        /* '<S266>:1:8' for i = 1:N */
        for (i = 0; i < 65; i++)
        {
            /* MATLAB Function: '<S264>/GaussianElimination' */
            /*  Loop over each frequency bin */
            /* '<S267>:1:16' S_data = squeeze(u(i,:,:)); */
            /* '<S267>:1:17' S_mod = GaussianElim(S_data); */
            for (i_0 = 0; i_0 < 5; i_0++)
            {
                for (RfftRefRfftInput_tmp = 0; RfftRefRfftInput_tmp < 5;
                        RfftRefRfftInput_tmp++)
                {
                    a[RfftRefRfftInput_tmp + 5 * i_0] = Model_Target_DW.GXY[(65 *
                        RfftRefRfftInput_tmp + i) + 325 * i_0];
                }
            }

            /*  This function performs Gaussian elimination  */
            /*  on a cross-correlation matrix, a.  */
            /* '<S267>:1:31' temp = a; */
            /* '<S267>:1:32' m = size(a,1); */
            /* '<S267>:1:33' for j =1:m-1 */
            for (loop_ub = 0; loop_ub < 4; loop_ub++)
            {
                /* '<S267>:1:34' for i = j+1:m */
                RfftRefRfftInput_tmp = 3 - loop_ub;
                for (c_i = 0; c_i <= RfftRefRfftInput_tmp; c_i++)
                {
                    real32_T br;
                    boolean_T guard1 = false;
                    boolean_T guard2 = false;
                    i_0 = (loop_ub + c_i) + 1;

                    /* '<S267>:1:35' if ((j>1) && abs(a(j,j)/temp(j,j)) > 0.001) || ((j==1) && abs(a(j,j))>eps) */
                    guard1 = false;
                    guard2 = false;
                    if (loop_ub + 1 > 1)
                    {
                        chanIdx_tmp = loop_ub * 5 + loop_ub;
                        acc_0 = a[chanIdx_tmp].re;
                        rtb_log10 = a[chanIdx_tmp].im;
                        chanIdx_tmp = (chanIdx_tmp % 5 * 65 + i) + chanIdx_tmp /
                            5 * 325;
                        br = Model_Target_DW.GXY[chanIdx_tmp].re;
                        Change = Model_Target_DW.GXY[chanIdx_tmp].im;
                        if (Change == 0.0F)
                        {
                            if (rtb_log10 == 0.0F)
                            {
                                acc = qhmath_div_f(acc_0, br);
                                acc_0 = 0.0F;
                            }
                            else if (acc_0 == 0.0F)
                            {
                                acc = 0.0F;
                                acc_0 = qhmath_div_f(rtb_log10, br);
                            }
                            else
                            {
                                acc = qhmath_div_f(acc_0, br);
                                acc_0 = qhmath_div_f(rtb_log10, br);
                            }
                        }
                        else if (br == 0.0F)
                        {
                            if (acc_0 == 0.0F)
                            {
                                acc = qhmath_div_f(rtb_log10, Change);
                                acc_0 = 0.0F;
                            }
                            else if (rtb_log10 == 0.0F)
                            {
                                acc = 0.0F;
                                acc_0 = -qhmath_div_f(acc_0, Change);
                            }
                            else
                            {
                                acc = qhmath_div_f(rtb_log10, Change);
                                acc_0 = -qhmath_div_f(acc_0, Change);
                            }
                        }
                        else
                        {
                            Slew = qhmath_abs_f(br);
                            acc = qhmath_abs_f(Change);
                            if (Slew > acc)
                            {
                                Slew = qhmath_div_f(Change, br);
                                Change = Slew * Change + br;
                                acc = qhmath_div_f(Slew * rtb_log10 + acc_0,
                                                   Change);
                                acc_0 = qhmath_div_f(rtb_log10 - Slew * acc_0,
                                                     Change);
                            }
                            else if (acc == Slew)
                            {
                                br = br > 0.0F ? 0.5F : -0.5F;
                                Change = Change > 0.0F ? 0.5F : -0.5F;
                                acc = qhmath_div_f(acc_0 * br + rtb_log10 *
                                                   Change, Slew);
                                acc_0 = qhmath_div_f(rtb_log10 * br - acc_0 *
                                                     Change, Slew);
                            }
                            else
                            {
                                Slew = qhmath_div_f(br, Change);
                                Change += Slew * br;
                                acc = qhmath_div_f(Slew * acc_0 + rtb_log10,
                                                   Change);
                                acc_0 = qhmath_div_f(Slew * rtb_log10 - acc_0,
                                                     Change);
                            }
                        }

                        if (qhmath_hypot_f(acc, acc_0) > 0.001)
                        {
                            guard1 = true;
                        }
                        else
                        {
                            guard2 = true;
                        }
                    }
                    else
                    {
                        guard2 = true;
                    }

                    if (guard2)
                    {
                        if (loop_ub + 1 == 1)
                        {
                            chanIdx_tmp = 5 * loop_ub + loop_ub;
                            if (qhmath_hypot_f(a[chanIdx_tmp].re, a[chanIdx_tmp]
                                               .im) > 2.22044605E-16F)
                            {
                                guard1 = true;
                            }
                        }
                    }

                    if (guard1)
                    {
                        /*  starting from 2nd row, if the conditioned psd is close to */
                        /*  zero, we should skip using this row for the next elimination */
                        /*  operation; similarly if the first input (G11) is zero, we */
                        /*  should skip using the first row */
                        /* '<S267>:1:41' mult = a(i,j)/a(j,j); */
                        chanIdx_tmp = 5 * loop_ub + i_0;
                        acc_0 = a[chanIdx_tmp].re;
                        rtb_log10 = a[chanIdx_tmp].im;
                        br = a[5 * loop_ub + loop_ub].re;
                        Change = a[5 * loop_ub + loop_ub].im;
                        if (Change == 0.0F)
                        {
                            if (rtb_log10 == 0.0F)
                            {
                                acc = qhmath_div_f(acc_0, br);
                                acc_0 = 0.0F;
                            }
                            else if (acc_0 == 0.0F)
                            {
                                acc = 0.0F;
                                acc_0 = qhmath_div_f(rtb_log10, br);
                            }
                            else
                            {
                                acc = qhmath_div_f(acc_0, br);
                                acc_0 = qhmath_div_f(rtb_log10, br);
                            }
                        }
                        else if (br == 0.0F)
                        {
                            if (acc_0 == 0.0F)
                            {
                                acc = qhmath_div_f(rtb_log10, Change);
                                acc_0 = 0.0F;
                            }
                            else if (rtb_log10 == 0.0F)
                            {
                                acc = 0.0F;
                                acc_0 = -qhmath_div_f(acc_0, Change);
                            }
                            else
                            {
                                acc = qhmath_div_f(rtb_log10, Change);
                                acc_0 = -qhmath_div_f(acc_0, Change);
                            }
                        }
                        else
                        {
                            Slew = qhmath_abs_f(br);
                            acc = qhmath_abs_f(Change);
                            if (Slew > acc)
                            {
                                Slew = qhmath_div_f(Change, br);
                                Change = Slew * Change + br;
                                acc = qhmath_div_f(Slew * rtb_log10 + acc_0,
                                                   Change);
                                acc_0 = qhmath_div_f(rtb_log10 - Slew * acc_0,
                                                     Change);
                            }
                            else if (acc == Slew)
                            {
                                br = br > 0.0F ? 0.5F : -0.5F;
                                Change = Change > 0.0F ? 0.5F : -0.5F;
                                acc = qhmath_div_f(acc_0 * br + rtb_log10 *
                                                   Change, Slew);
                                acc_0 = qhmath_div_f(rtb_log10 * br - acc_0 *
                                                     Change, Slew);
                            }
                            else
                            {
                                Slew = qhmath_div_f(br, Change);
                                Change += Slew * br;
                                acc = qhmath_div_f(Slew * acc_0 + rtb_log10,
                                                   Change);
                                acc_0 = qhmath_div_f(Slew * rtb_log10 - acc_0,
                                                     Change);
                            }
                        }

                        /* '<S267>:1:42' a(i,:) = a(i,:)-a(j,:)*mult; */
                        for (chanIdx_tmp = 0; chanIdx_tmp < 5; chanIdx_tmp++)
                        {
                            chanIdx = 5 * chanIdx_tmp + loop_ub;
                            re_tmp = 5 * chanIdx_tmp + i_0;
                            rtb_log10 = a[chanIdx].re;
                            Change = a[chanIdx].im;
                            a_0.re = a[re_tmp].re - (rtb_log10 * acc - Change *
                                acc_0);
                            a_0.im = a[re_tmp].im - (rtb_log10 * acc_0 + Change *
                                acc);
                            a[re_tmp] = a_0;
                        }
                    }
                }
            }

            /* '<S267>:1:46' b = a; */
            /* '<S267>:1:18' Snn_Gauss = S_mod(N,N); */
            /* Gnn(i) = real(Snn_Gauss); */
            /* '<S267>:1:20' if S_data(N,N) > eps */
            if (Model_Target_DW.GXY[i + 1560].re > 2.22044605E-16F)
            {
                /* '<S267>:1:21' c(i) = 1-real(Snn_Gauss)/real(S_data(N,N)); */
                acc_0 = 1.0F - qhmath_div_f(a[24].re, Model_Target_DW.GXY[i +
                    1560].re);
            }
            else
            {
                /* '<S267>:1:22' else */
                /* '<S267>:1:23' c(i) = 1; */
                acc_0 = 1.0F;
            }

            /* MATLAB Function: '<S264>/CoherenceModifier' */
            /* '<S266>:1:9' if u(i) > threshold */
            if (acc_0 > 0.88)
            {
                /* '<S266>:1:10' u(i) = sqrt((u(i)-threshold)*(1-threshold)) + threshold; */
                acc_0 = qhmath_sqrt_f((acc_0 - 0.88F) * 0.12F) + 0.88F;
            }

            /* End of MATLAB Function: '<S264>/CoherenceModifier' */

            /* Merge: '<S259>/Merge' incorporates:
             *  Constant: '<S264>/Constant'
             *  MATLAB Function: '<S264>/GaussianElimination'
             *  MinMax: '<S264>/FloorValue'
             *  Product: '<S264>/Product1'
             *  Sum: '<S264>/Subtract1'
             */
            Model_Target_B.Merge_a[i] = fmaxf((1.0F - acc_0) *
                Model_Target_DW.GXY[i + 1560].re,
                Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseRefPowerMin);
        }

        /* End of Outputs for SubSystem: '<S259>/If Action Subsystem' */
    }
    else
    {
        /* Outputs for IfAction SubSystem: '<S259>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S265>/Action Port'
         */
        /* Merge: '<S259>/Merge' incorporates:
         *  DataStoreRead: '<S259>/Data Store Read1'
         *  SignalConversion generated from: '<S265>/Gnn'
         */
        memcpy(&Model_Target_B.Merge_a[0], &Model_Target_DW.Gnn[0], 65U * sizeof
               (real32_T));

        /* End of Outputs for SubSystem: '<S259>/If Action Subsystem1' */
    }

    /* End of If: '<S259>/If' */

    /* DataStoreWrite: '<S253>/Data Store Write' */
    memcpy(&Model_Target_DW.Gnn[0], &Model_Target_B.Merge_a[0], 65U * sizeof
           (real32_T));

    /* MATLAB Function: '<S253>/GnnInitNoiseFloor' */
    /*  Initialize noise floor in Gnn based on ref_pow_min TOP  */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /GnnInitNoiseFloor': '<S260>:1' */
    /*  Flag */
    /*  Initialize the flag */
    /* '<S260>:1:8' if isempty(init_noise_floor) */
    /*  Initialize Gnn */
    /* '<S260>:1:13' if(~init_noise_floor) */
    if (!Model_Target_DW.init_noise_floor)
    {
        /* '<S260>:1:14' Gnn(:) = RefPowerMin; */
        for (i_0 = 0; i_0 < 65; i_0++)
        {
            Model_Target_DW.Gnn[i_0] =
                Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseRefPowerMin;
        }

        /* '<S260>:1:15' init_noise_floor = true; */
        Model_Target_DW.init_noise_floor = true;
    }

    /* End of MATLAB Function: '<S253>/GnnInitNoiseFloor' */

    /* MATLAB Function: '<S261>/ExtractMicLevel' incorporates:
     *  MATLAB Function: '<S253>/FormCoherenceMatrixGXY'
     */
    /*  This function generates a microphone level by  */
    /*  (1) Extracting Gyy from the cross-spectral density matrix */
    /*      It is the last entry (last column, last row) of the matrix. */
    /*  (2) Sum Gyy over all frequency bands */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/HfNoiseMusicSeparation /MicPsdLevel/ExtractMicLevel': '<S268>:1' */
    /* '<S268>:1:7' Gyy = CSD(:,end,end); */
    /* '<S268>:1:8' MicLevel = sum(Gyy); */
    Model_Target_B.MicLevel = Model_Target_DW.GXY[1560];
    for (i = 0; i < 64; i++)
    {
        Model_Target_B.MicLevel.re += Model_Target_DW.GXY[i + 1561].re;
        Model_Target_B.MicLevel.im += Model_Target_DW.GXY[i + 1561].im;
    }

    /* End of MATLAB Function: '<S261>/ExtractMicLevel' */
    /* S-Function (sdspmsumprod): '<S289>/MatrixSumPowCurr' incorporates:
     *  Merge: '<S259>/Merge'
     */
    acc = Model_Target_B.Merge_a[0];

    /* S-Function (sdspmsumprod): '<S289>/MatrixSumPowPrev' incorporates:
     *  Delay: '<S281>/Delay'
     */
    acc_0 = Model_Target_DW.Delay_DSTATE_d[0];
    for (i = 0; i < 64; i++)
    {
        /* S-Function (sdspmsumprod): '<S289>/MatrixSumPowCurr' incorporates:
         *  Merge: '<S259>/Merge'
         */
        acc += Model_Target_B.Merge_a[i + 1];

        /* S-Function (sdspmsumprod): '<S289>/MatrixSumPowPrev' incorporates:
         *  Delay: '<S281>/Delay'
         */
        acc_0 += Model_Target_DW.Delay_DSTATE_d[i + 1];
    }

    /* Bias: '<S289>/Bias1' incorporates:
     *  Bias: '<S289>/Bias'
     *  Product: '<S289>/Divide1'
     *  S-Function (sdspmsumprod): '<S289>/MatrixSumPowCurr'
     *  S-Function (sdspmsumprod): '<S289>/MatrixSumPowPrev'
     */
    acc_0 = qhmath_div_f(1.0F, acc + 2.22044605E-16F) * acc_0 - 1.0F;

    /* Sum: '<S289>/Add6' incorporates:
     *  Bias: '<S289>/Bias2'
     *  Bias: '<S289>/Bias3'
     *  Delay: '<S281>/Delay2'
     *  Gain: '<S289>/Gain'
     *  Math: '<S289>/Math Function'
     *  Math: '<S289>/Math Function1'
     *  MinMax: '<S289>/MinMax1'
     *  Product: '<S289>/Product2'
     *  Product: '<S289>/Product3'
     *
     * About '<S289>/Math Function':
     *  Operator: magnitude^2
     *
     * About '<S289>/Math Function1':
     *  Operator: reciprocal
     */
    acc = fmaxf(qhmath_div_f(1.0F, acc_0 * acc_0 + 1.0F),
                Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinstatMin)
        * (-Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinstatBeta
           + 1.0F) +
        Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinstatBeta *
        Model_Target_DW.Delay2_DSTATE_b;
    for (i_0 = 0; i_0 < 65; i_0++)
    {
        /* Bias: '<S290>/Bias1' incorporates:
         *  Bias: '<S290>/Bias'
         *  Delay: '<S281>/Delay'
         *  Delay: '<S281>/Delay1'
         *  Product: '<S290>/Divide2'
         */
        acc_0 = qhmath_div_f(Model_Target_DW.Delay_DSTATE_d[i_0],
                             Model_Target_DW.Delay1_DSTATE_n[i_0] +
                             2.22044605E-16F) - 1.0F;

        /* MinMax: '<S287>/MinMax2' incorporates:
         *  Bias: '<S286>/Bias'
         *  Bias: '<S287>/Bias2'
         *  Bias: '<S290>/Bias2'
         *  Delay: '<S281>/Delay'
         *  Gain: '<S286>/Gain'
         *  Math: '<S290>/Math Function2'
         *  Merge: '<S259>/Merge'
         *  Product: '<S286>/Product'
         *  Product: '<S286>/Product1'
         *  Product: '<S287>/Divide'
         *  Sum: '<S286>/Add'
         *
         * About '<S290>/Math Function2':
         *  Operator: magnitude^2
         */
        acc_0 = fmaxf(qhmath_div_f
                      (Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinstatAlphaFactor
                       * acc, (acc_0 * acc_0 + 1.0F) + 2.22044605E-16F),
                      Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinstatAlphaMin);
        rtb_u[i_0] = (-acc_0 + 1.0F) * Model_Target_B.Merge_a[i_0] + acc_0 *
            Model_Target_DW.Delay_DSTATE_d[i_0];
    }

    /* MATLAB Function: '<S291>/ComputePmin' */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/HFNoiseEstimatorCoh/PostProcessing/HfImpulseRejection/MinSearch/ComputePmin': '<S300>:1' */
    /* '<S300>:1:10' numFreqBins = size(P,1); */
    /*  Because of restrictions on vsriable-size arrays, this number is currently */
    /*  hard-coded. It is intended to be subWin. */
    /* '<S300>:1:14' numSubWin = 3; */
    /*  The minimum value of 1e-8, currently hard-coded, should also be variable */
    /*  or globally defined. */
    /* '<S300>:1:19' if isempty(IRMinCount) */
    /* '<S300>:1:20' if isempty(IRSubMin) */
    /* '<S300>:1:21' if isempty(IRPowMS) */
    /*  The following is a low-storage method for calculating a running minimum */
    /*  over a sliding window */
    /* '<S300>:1:25' IRMinCount = mod(IRMinCount + 1, numSubWin*subWinLen); */
    Model_Target_DW.IRMinCount = Model_Target_mod(Model_Target_DW.IRMinCount +
        1.0F, 3.0F *
        Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionSubWinLenSamples);

    /* '<S300>:1:26' currentSubWin = floor(IRMinCount / subWinLen) + 1; */
    acc_0 = qhmath_floor_f(qhmath_div_f(Model_Target_DW.IRMinCount,
                            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionSubWinLenSamples));

    /* '<S300>:1:28' if mod(IRMinCount, subWinLen) == 0 */
    if (Model_Target_mod(Model_Target_DW.IRMinCount,
                         Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionSubWinLenSamples)
        == 0.0F)
    {
        /* '<S300>:1:29' IRSubMin(currentSubWin, :) = 1; */
        for (i_0 = 0; i_0 < 65; i_0++)
        {
            Model_Target_DW.IRSubMin[((int32_T)(acc_0 + 1.0F) + 3 * i_0) - 1] =
                1.0F;
        }
    }

    /* '<S300>:1:32' IRSubMin(currentSubWin, :) = min(IRSubMin(currentSubWin, :), P.'); */
    for (i = 0; i < 65; i++)
    {
        IRGlobalMin[i] = fminf(Model_Target_DW.IRSubMin[((int32_T)(acc_0 + 1.0F)
                                + 3 * i) - 1], rtb_u[i]);
    }

    for (i_0 = 0; i_0 < 65; i_0++)
    {
        Model_Target_DW.IRSubMin[((int32_T)(acc_0 + 1.0F) + 3 * i_0) - 1] =
            IRGlobalMin[i_0];
    }

    /* '<S300>:1:33' IRGlobalMin = min(IRSubMin); */
    for (loop_ub = 0; loop_ub < 65; loop_ub++)
    {
        rtb_log10 = Model_Target_DW.IRSubMin[3 * loop_ub];
        i_0 = 3 * loop_ub + 1;
        if (rtb_log10 > Model_Target_DW.IRSubMin[i_0])
        {
            rtb_log10 = Model_Target_DW.IRSubMin[i_0];
        }

        acc_0 = Model_Target_DW.IRSubMin[3 * loop_ub + 2];
        if (rtb_log10 > acc_0)
        {
            rtb_log10 = acc_0;
        }

        IRGlobalMin[loop_ub] = rtb_log10;
    }

    /*  Flatness Calculations */
    /*  Geometric mean over arithmatic mean */
    /* '<S300>:1:37' flatness = 10^(mean(log10(IRGlobalMin(flatIdx1:flatIdx2)))) / ... */
    /* '<S300>:1:38' 	(mean(IRGlobalMin(flatIdx1:flatIdx2))+eps); */
    if (Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex
        > Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex)
    {
        chanIdx = 1;
        RfftRefRfftInput_tmp = 0;
    }
    else
    {
        chanIdx = (int32_T)
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex;
        RfftRefRfftInput_tmp = (int32_T)
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex;
    }

    if (Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex
        > Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex)
    {
        i_0 = 0;
        i = 0;
    }
    else
    {
        i_0 = (int32_T)
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessLowIndex
            - 1;
        i = (int32_T)
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessHighIndex;
    }

    loop_ub = RfftRefRfftInput_tmp - chanIdx;
    c_i = loop_ub + 1;
    for (RfftRefRfftInput_tmp = 0; RfftRefRfftInput_tmp <= loop_ub;
            RfftRefRfftInput_tmp++)
    {
        b_x_data[RfftRefRfftInput_tmp] = IRGlobalMin[(chanIdx +
            RfftRefRfftInput_tmp) - 1];
        b_x_data[RfftRefRfftInput_tmp] = qhmath_log10_f
            (b_x_data[RfftRefRfftInput_tmp]);
    }

    if (loop_ub + 1 == 0)
    {
        acc_0 = 0.0F;
    }
    else
    {
        acc_0 = b_x_data[0];
        for (loop_ub = 2; loop_ub <= c_i; loop_ub++)
        {
            acc_0 += b_x_data[loop_ub - 1];
        }
    }

    chanIdx_tmp = i - i_0;
    if (chanIdx_tmp == 0)
    {
        rtb_log10 = 0.0F;
    }
    else
    {
        rtb_log10 = IRGlobalMin[i_0];
        for (RfftRefRfftInput_tmp = 2; RfftRefRfftInput_tmp <= chanIdx_tmp;
                RfftRefRfftInput_tmp++)
        {
            rtb_log10 += IRGlobalMin[(i_0 + RfftRefRfftInput_tmp) - 1];
        }
    }

    acc_0 = qhmath_div_f(qhmath_pow_f(10.0F, qhmath_div_f(acc_0, (real32_T)c_i)),
                         qhmath_div_f(rtb_log10, (real32_T)chanIdx_tmp) +
                         2.22044605E-16F);

    /* '<S300>:1:40' if flatness >= flatThresh */
    if (acc_0 >=
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionFlatnessThresh)
    {
        /*  accept new value */
        /* '<S300>:1:42' IRPowMS = powMSCoef*IRPowMS + (1-powMSCoef)*IRGlobalMin; */
        for (i_0 = 0; i_0 < 65; i_0++)
        {
            Model_Target_DW.IRPowMS[i_0] = (1.0F -
                Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinSearchCoef)
                * IRGlobalMin[i_0] +
                Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinSearchCoef
                * Model_Target_DW.IRPowMS[i_0];
        }
    }
    else
    {
        /* '<S300>:1:43' else */
        /*  else, take the smaller of the current sample and the storage */
        /* '<S300>:1:45' IRPowMS = min(IRPowMS, IRGlobalMin); */
        for (i_0 = 0; i_0 < 65; i_0++)
        {
            Model_Target_DW.IRPowMS[i_0] = fminf(Model_Target_DW.IRPowMS[i_0],
                IRGlobalMin[i_0]);
        }
    }

    /* '<S300>:1:48' powMin = single(IRPowMS.'*minGain); */
    Model_Target_B.flatness = acc_0;

    /* Sum: '<S281>/Sum of Elements' */
    acc_0 = -0.0F;
    for (i_0 = 0; i_0 < 65; i_0++)
    {
        /* MATLAB Function: '<S291>/ComputePmin' */
        rtb_log10 = Model_Target_DW.IRPowMS[i_0] *
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionMinSearchMinGain;

        /* Sum: '<S281>/Sum of Elements' */
        acc_0 += rtb_log10;

        /* MATLAB Function: '<S291>/ComputePmin' */
        IRGlobalMin[i_0] = rtb_log10;
    }

    /* Sum: '<S281>/Sum of Elements' */
    Model_Target_B.SumofElements = acc_0;

    /* Sqrt: '<S281>/Sqrt' */
    acc_0 = qhmath_sqrt_f(Model_Target_B.SumofElements);

    /* Switch: '<S293>/Switch' incorporates:
     *  Constant: '<S293>/Constant'
     *  Delay: '<S293>/Delay'
     *  RelationalOperator: '<S293>/Relational Operator'
     */
    if (acc_0 < Model_Target_DW.Delay_DSTATE_n0)
    {
        rtb_log10 = 1.0F;
    }
    else
    {
        rtb_log10 =
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseImpulseRejectionLevelUpdateCoef;
    }

    /* End of Switch: '<S293>/Switch' */

    /* Sum: '<S293>/Add1' incorporates:
     *  Bias: '<S293>/Bias'
     *  Delay: '<S293>/Delay'
     *  Gain: '<S293>/Gain'
     *  Product: '<S293>/Product'
     *  Product: '<S293>/Product1'
     */
    acc_0 = (-rtb_log10 + 1.0F) * Model_Target_DW.Delay_DSTATE_n0 + acc_0 *
        rtb_log10;

    /* Sum: '<S281>/Add' incorporates:
     *  Constant: '<S288>/Constant'
     *  Gain: '<S288>/Gain'
     *  Math: '<S288>/Magsq'
     *  Math: '<S288>/log10'
     *  Sum: '<S288>/Sum1'
     *
     * About '<S288>/Magsq':
     *  Operator: magnitude^2
     *
     * About '<S288>/log10':
     *  Operator: log10
     */
    Model_Target_B.Add_o = qhmath_log10_f((acc_0 + 2.22044605E-16F) * (acc_0 +
        2.22044605E-16F)) * 10.0F +
        Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseOffsetDb;

    /* MATLAB Function: '<S282>/Slew' incorporates:
     *  Constant: '<S282>/init'
     */
    /* MATLAB Function 'Slew': '<S309>:1' */
    /* '<S309>:1:5' if isempty(PrevChange) */
    /* '<S309>:1:6' if isempty(PrevDelta) */
    /* '<S309>:1:7' if isempty(PrevPostSlew) */
    if (!Model_Target_DW.PrevPostSlew_not_empty_c)
    {
        /* '<S309>:1:7' ; */
        /* '<S309>:1:7' PrevPostSlew = single(SlewInit); */
        Model_Target_DW.PrevPostSlew_b = 20.0F;
        Model_Target_DW.PrevPostSlew_not_empty_c = true;
    }

    /* '<S309>:1:9' Delta = PreSlew - PrevPostSlew; */
    rtb_log10 = Model_Target_B.Add_o - Model_Target_DW.PrevPostSlew_b;

    /* '<S309>:1:11' if Delta > 0 */
    if (rtb_log10 > 0.0F)
    {
        /*  setup for positive delta */
        /* '<S309>:1:12' Change = min(SlewAttack, Delta); */
        Change = fminf
            (Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseSlewAttackDbPerSample,
             rtb_log10);

        /* '<S309>:1:13' SlowSlew = min(SlowSlew, Delta); */
    }
    else
    {
        /* '<S309>:1:14' else */
        /*  setup for negative delta */
        /* '<S309>:1:15' Change = max(SlewDecay, Delta); */
        Change = fmaxf
            (Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseSlewDecayDbPerSample,
             rtb_log10);

        /* '<S309>:1:16' SlowSlew = max(-SlowSlew, Delta); */
    }

    /* '<S309>:1:19' if PrevDelta*Delta > 0 */
    if (Model_Target_DW.PrevDelta_p * rtb_log10 > 0.0F)
    {
        /*  did we reach our target? */
        /* '<S309>:1:20' Slew = single(PrevChange); */
        Slew = Model_Target_DW.PrevChange_c;

        /*  no, continue the current path */
    }
    else
    {
        /* '<S309>:1:21' else */
        /*  otherwise, we have reached our target */
        /* '<S309>:1:22' Slew = single(0); */
        Slew = 0.0F;

        /*  no slew in the dead zone */
    }

    /* '<S309>:1:25' if SpeedBoundFlag && Slew == 0 */
    /* '<S309>:1:29' if (abs(Delta) <= SlewThreshold) ...		% are we within the zone? */
    /* '<S309>:1:30' 		&& (abs(Slew) < abs(Change)) */
    if ((qhmath_abs_f(rtb_log10) <=
            Model_Target_PreAmp_p4_b0.AudiopilotHfNoiseSlewThresholdDb) &&
            (qhmath_abs_f(Slew) < qhmath_abs_f(Change)))
    {
        /* 		% are we within the zone? */
        /*  is change still bigger than slew? */
        /*  (offshoot protection)x */
        /* '<S309>:1:32' Change = Slew; */
        Change = Slew;

        /*  freeze or continue the current */
    }

    /* '<S309>:1:35' PrevDelta = Delta; */
    Model_Target_DW.PrevDelta_p = rtb_log10;

    /* '<S309>:1:36' PrevChange = Change; */
    Model_Target_DW.PrevChange_c = Change;

    /* '<S309>:1:38' PrevPostSlew = PrevPostSlew + Change; */
    Model_Target_DW.PrevPostSlew_b += Change;

    /* '<S309>:1:39' PostSlew = PrevPostSlew; */
    Model_Target_B.PostSlew_j = Model_Target_DW.PrevPostSlew_b;

    /* End of MATLAB Function: '<S282>/Slew' */
    /* RateTransition: '<S249>/LFNoise postSmooth Rate Transition' */
    rtb_log10 =
        Model_Target_DW.LFNoisepostSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx];

    /* RateTransition: '<S249>/LFNoise preSmooth Rate Transition' */
    Change =
        Model_Target_DW.LFNoisepreSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx];

    /* RateTransition: '<S249>/Speed Rate Transition' */
    Model_Target_DW.SpeedRateTransition_semaphoreTaken = 1;
    Slew = Model_Target_DW.SpeedRateTransition_Buffer0;
    Model_Target_DW.SpeedRateTransition_semaphoreTaken = 0;

    /* MATLAB Function: '<S448>/APLFUP' */
    /*  This function is to check if the low freq noise goes up when the high */
    /*  freq noise is going up. Only when both noise go up, the flag is set to */
    /*  enable the ratio change and tuning adjustment */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/RatioCalculation/APLFUP/APLFUP': '<S457>:1' */
    /* '<S457>:1:14' if isempty(prev) */
    /* '<S457>:1:15' if isempty(counter) */
    /* '<S457>:1:16' if isempty(counter2) */
    /* '<S457>:1:17' if isempty(LFUP) */
    /* '<S457>:1:19' if ((LF >= prev + noiseUpThresh) && (speed >= SpeedThresh)) */
    if ((rtb_log10 >= Model_Target_DW.prev +
            Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateLfNoiseUpdateThreshDb)
        && (Slew >=
            Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateSpeedUpdateThreshMph))
    {
        /* '<S457>:1:20' LFUP = single(1); */
        Model_Target_DW.LFUP = 1.0F;

        /* '<S457>:1:21' counter = single(0); */
        Model_Target_DW.counter_j = 0.0F;

        /*  If low freq noise goes up by more than noiseUpThresh dB and the speed */
        /*  is above the SpeedThresh, set the flag ON and reset the counter, this */
        /*  is usually the case when the windows roll down */
    }
    else if ((Model_Target_DW.LFUP == 1.0F) && (Model_Target_DW.counter_j <
              Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateFlagHoldTimeSamples))
    {
        /* '<S457>:1:25' elseif (LFUP == 1) && (counter < HoldTime1) */
        /* '<S457>:1:26' counter = counter + 1; */
        Model_Target_DW.counter_j++;

        /*  elseif the flag is ON and the hold period has not expired, update the */
        /*  counter for hold time1 */
    }
    else
    {
        /* '<S457>:1:29' else */
        /* '<S457>:1:30' LFUP = single(0); */
        Model_Target_DW.LFUP = 0.0F;

        /* '<S457>:1:31' counter = single(0); */
        Model_Target_DW.counter_j = 0.0F;

        /*  else, reset the flag and the counter */
    }

    /* '<S457>:1:35' if (LF > LFUPThresh) && (speed >= SpeedThresh) || (HF > HFUPThresh) */
    if (((rtb_log10 >
            Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateLfNoiseThreshDbspl) &&
         (Slew >=
            Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateSpeedUpdateThreshMph))
        || (Model_Target_B.PostSlew_j >
            Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateHfNoiseThreshDbspl))
    {
        /* '<S457>:1:36' LFUP = single(1); */
        Model_Target_DW.LFUP = 1.0F;

        /* '<S457>:1:37' counter = HoldTime1 - 2; */
        Model_Target_DW.counter_j =
            Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateFlagHoldTimeSamples -
            2.0F;

        /*  In another case, if the low freq noise level is above LFUPThresh and */
        /*  the high freq noise is above HFUPThresh and the speed is above */
        /*  SpeedThresh, set the flag ON. This usually happens when the window is */
        /*  already down and vehicle starts to speed up */
    }

    /*  to prevent too small variations in low freq noise, we only update the low */
    /*  freq noise reading every HoldTime2 seconds. */
    /* '<S457>:1:46' if counter2 == HoldTime2 - 1 */
    if (Model_Target_PreAmp_p4_b0.AudiopilotRatioUpdateLfNoiseUpdatePeriodSamples
        - 1.0F == Model_Target_DW.counter2)
    {
        /* '<S457>:1:47' prev = LF; */
        Model_Target_DW.prev = rtb_log10;

        /* '<S457>:1:48' counter2 = single(0); */
        Model_Target_DW.counter2 = 0.0F;
    }
    else
    {
        /* '<S457>:1:49' else */
        /* '<S457>:1:50' counter2 = counter2 + 1; */
        Model_Target_DW.counter2++;
    }

    /* '<S457>:1:53' LFUPFlag = LFUP; */
    Model_Target_B.LFUPFlag = Model_Target_DW.LFUP;

    /* End of MATLAB Function: '<S448>/APLFUP' */
    /* MATLAB Function: '<S455>/RatioSmoother' incorporates:
     *  Gain: '<S468>/Gain'
     *  Gain: '<S474>/Gain'
     *  Math: '<S468>/Math Function'
     *  Math: '<S474>/Math Function'
     *  MinMax: '<S455>/MinMax'
     *  MinMax: '<S455>/MinMax1'
     *  RateTransition: '<S252>/Rate Transition'
     *  RateTransition: '<S252>/Rate Transition1'
     *  Sum: '<S455>/Subtract'
     */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/RatioCalculation/RatioSmoother/RatioSmoother': '<S473>:1' */
    /* '<S473>:1:11' if isempty(PreRatioLinLP) */
    /* '<S473>:1:12' if isempty(ImpFiltState) */
    /* '<S473>:1:13' if isempty(ImpRejFiltOut) */
    if (!Model_Target_DW.ImpRejFiltOut_not_empty)
    {
        /* '<S473>:1:13' ; */
        /* '<S473>:1:13' ImpRejFiltOut = single(ImpRejFiltOutInit); */
        Model_Target_DW.ImpRejFiltOut = qhmath_pow_f(10.0F, 0.05F *
            Model_Target_DW.RateTransition1_Buffer);
        Model_Target_DW.ImpRejFiltOut_not_empty = true;
    }

    /*  Energy Conversion */
    /* '<S473>:1:16' PreRatioLinLP = PreRatioLinLP*RatioCoef ... */
    /* '<S473>:1:17'     + abs(PreRatioLinear)*(1-RatioCoef); */
    Model_Target_DW.PreRatioLinLP = qhmath_pow_f(10.0F, fminf(fmaxf(Change -
        Model_Target_B.Add_o, Model_Target_DW.RateTransition_Buffer),
        Model_Target_DW.RateTransition1_Buffer) * 0.05F) * (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotRatioEnergyLpfCoef) +
        Model_Target_DW.PreRatioLinLP *
        Model_Target_PreAmp_p4_b0.AudiopilotRatioEnergyLpfCoef;

    /*  Instantaneous Noise Estimate */
    /* '<S473>:1:20' RatioInstant = abs(PreRatioLinLP); */
    rtb_log10 = qhmath_abs_f(Model_Target_DW.PreRatioLinLP);

    /*  Impulse Estimate */
    /*  Double application of 1st order LPF (A Dublin hack) */
    /* '<S473>:1:24' ImpFiltState(1) = ImpFiltState(1)*RatioFiltCoef ... */
    /* '<S473>:1:25'     + RatioInstant*(1-RatioFiltCoef); */
    Model_Target_DW.ImpFiltState[0] = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef)
        * rtb_log10 + Model_Target_DW.ImpFiltState[0] *
        Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef;

    /* '<S473>:1:26' ImpFiltState(2) = ImpFiltState(2)*RatioFiltCoef ... */
    /* '<S473>:1:27'     + ImpFiltState(1)*(1-RatioFiltCoef); */
    Model_Target_DW.ImpFiltState[1] = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef)
        * Model_Target_DW.ImpFiltState[0] + Model_Target_DW.ImpFiltState[1] *
        Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionImpulseVarianceLpfCoef;

    /*  Variances */
    /* '<S473>:1:30' noiseVar = NoiseScale * ImpFiltState(2)^2; */
    Change = Model_Target_DW.ImpFiltState[1] * Model_Target_DW.ImpFiltState[1] *
        Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionNoiseVarianceScale;

    /* '<S473>:1:31' impulseVar = ImpulseScale ... */
    /* '<S473>:1:32'     * (min(0,RatioInstant-ImpFiltState(2)))^2; */
    Slew = fminf(0.0F, rtb_log10 - Model_Target_DW.ImpFiltState[1]);

    /* '<S473>:1:33' totalVar = noiseVar + max(0,impulseVar); */
    /*  Gamma correction */
    /* '<S473>:1:36' impRejFiltCoef = (1 - GammaCorr*noiseVar/(totalVar+eps)); */
    Change = 1.0F - qhmath_div_f
        (Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionGamma0 *
         Change, (fmaxf(0.0F, Slew * Slew *
                        Model_Target_PreAmp_p4_b0.AudiopilotRatioImpulseRejectionImpulseVarianceScale)
                  + Change) + 2.22044605E-16F);

    /*  Impulse Reject Filter */
    /*  If the new value is larger than the current value, use the new value for */
    /*  update.  Otherwise, if the new value is smaller, then update only if the */
    /*  update flag is also raised. */
    /* '<S473>:1:42' if (RatioInstant >= ImpRejFiltOut) || ((RatioInstant < ImpRejFiltOut)&& UpdateFlag) */
    if ((rtb_log10 >= Model_Target_DW.ImpRejFiltOut) || (Model_Target_B.LFUPFlag
         != 0.0F))
    {
        /* '<S473>:1:43' ImpRejFiltOut = impRejFiltCoef*ImpRejFiltOut+RatioInstant*(1-impRejFiltCoef); */
        Model_Target_DW.ImpRejFiltOut = (1.0F - Change) * rtb_log10 + Change *
            Model_Target_DW.ImpRejFiltOut;
    }

    /* Sum: '<S475>/Sum1' incorporates:
     *  Constant: '<S252>/RatioOutputLowBound'
     *  Constant: '<S475>/Constant'
     *  MATLAB Function: '<S455>/RatioSmoother'
     */
    /*  dBSPL Conversion and microphone energy check */
    /* '<S473>:1:47' RatioLinear = max(ImpRejFiltOut+eps, PreRatioMin); */
    rtb_log10 = fmaxf(Model_Target_DW.ImpRejFiltOut + 2.22044605E-16F, 100.0F) +
        2.22044605E-16F;

    /* Sum: '<S475>/Sum2' incorporates:
     *  Gain: '<S475>/Gain'
     *  Math: '<S475>/Magsq'
     *  Math: '<S475>/log10'
     *
     * About '<S475>/Magsq':
     *  Operator: magnitude^2
     *
     * About '<S475>/log10':
     *  Operator: log10
     */
    Model_Target_B.Sum2 = qhmath_log10_f(rtb_log10 * rtb_log10) * 10.0F;

    /* MATLAB Function: '<S454>/Slew' incorporates:
     *  RateTransition: '<S252>/Rate Transition1'
     */
    /* MATLAB Function 'Slew': '<S464>:1' */
    /* '<S464>:1:5' if isempty(PrevChange) */
    /* '<S464>:1:6' if isempty(PrevDelta) */
    /* '<S464>:1:7' if isempty(PrevPostSlew) */
    if (!Model_Target_DW.PrevPostSlew_not_empty)
    {
        /* '<S464>:1:7' ; */
        /* '<S464>:1:7' PrevPostSlew = single(SlewInit); */
        Model_Target_DW.PrevPostSlew = Model_Target_DW.RateTransition1_Buffer;
        Model_Target_DW.PrevPostSlew_not_empty = true;
    }

    /* '<S464>:1:9' Delta = PreSlew - PrevPostSlew; */
    rtb_log10 = Model_Target_B.Sum2 - Model_Target_DW.PrevPostSlew;

    /* '<S464>:1:11' if Delta > 0 */
    if (rtb_log10 > 0.0F)
    {
        /*  setup for positive delta */
        /* '<S464>:1:12' Change = min(SlewAttack, Delta); */
        Change = fminf
            (Model_Target_PreAmp_p4_b0.AudiopilotRatioSlewAttackDbPerSample,
             rtb_log10);

        /* '<S464>:1:13' SlowSlew = min(SlowSlew, Delta); */
    }
    else
    {
        /* '<S464>:1:14' else */
        /*  setup for negative delta */
        /* '<S464>:1:15' Change = max(SlewDecay, Delta); */
        Change = fmaxf
            (Model_Target_PreAmp_p4_b0.AudiopilotRatioSlewDecayDbPerSample,
             rtb_log10);

        /* '<S464>:1:16' SlowSlew = max(-SlowSlew, Delta); */
    }

    /* '<S464>:1:19' if PrevDelta*Delta > 0 */
    if (Model_Target_DW.PrevDelta * rtb_log10 > 0.0F)
    {
        /*  did we reach our target? */
        /* '<S464>:1:20' Slew = single(PrevChange); */
        Slew = Model_Target_DW.PrevChange;

        /*  no, continue the current path */
    }
    else
    {
        /* '<S464>:1:21' else */
        /*  otherwise, we have reached our target */
        /* '<S464>:1:22' Slew = single(0); */
        Slew = 0.0F;

        /*  no slew in the dead zone */
    }

    /* '<S464>:1:25' if SpeedBoundFlag && Slew == 0 */
    /* '<S464>:1:29' if (abs(Delta) <= SlewThreshold) ...		% are we within the zone? */
    /* '<S464>:1:30' 		&& (abs(Slew) < abs(Change)) */
    if ((qhmath_abs_f(rtb_log10) <=
            Model_Target_PreAmp_p4_b0.AudiopilotRatioSlewThresholdDb) &&
            (qhmath_abs_f(Slew) < qhmath_abs_f(Change)))
    {
        /* 		% are we within the zone? */
        /*  is change still bigger than slew? */
        /*  (offshoot protection)x */
        /* '<S464>:1:32' Change = Slew; */
        Change = Slew;

        /*  freeze or continue the current */
    }

    /* '<S464>:1:35' PrevDelta = Delta; */
    Model_Target_DW.PrevDelta = rtb_log10;

    /* '<S464>:1:36' PrevChange = Change; */
    Model_Target_DW.PrevChange = Change;

    /* '<S464>:1:38' PrevPostSlew = PrevPostSlew + Change; */
    Model_Target_DW.PrevPostSlew += Change;

    /* '<S464>:1:39' PostSlew = PrevPostSlew; */
    Model_Target_B.PostSlew = Model_Target_DW.PrevPostSlew;

    /* End of MATLAB Function: '<S454>/Slew' */
    /* RateTransition: '<S34>/Rate Transition2' */
    Model_Target_DW.RateTransition2_Buffer[Model_Target_DW.RateTransition2_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew;
    Model_Target_DW.RateTransition2_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition2_ActiveBufIdx == 0);

    /* RateTransition: '<S34>/Rate Transition6' */
    Model_Target_DW.RateTransition6_Buffer[Model_Target_DW.RateTransition6_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew_j;
    Model_Target_DW.RateTransition6_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition6_ActiveBufIdx == 0);

    /* End of Outputs for SubSystem: '<S25>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Update for M-S-Function: '<S269>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseMicPsdLevel '<S269>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 9, &Model_Target_B.MicLevel);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S262>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoisePowerSpectralDensity '<S262>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 11, &Model_Target_B.Merge_a[0]);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for Delay: '<S281>/Delay2' */
    Model_Target_DW.Delay2_DSTATE_b = acc;

    /* Update for Delay: '<S281>/Delay' incorporates:
     *  Sum: '<S286>/Add'
     */
    memcpy(&Model_Target_DW.Delay_DSTATE_d[0], &rtb_u[0], 65U * sizeof(real32_T));

    /* Update for Delay: '<S281>/Delay1' */
    memcpy(&Model_Target_DW.Delay1_DSTATE_n[0], &IRGlobalMin[0], 65U * sizeof
           (real32_T));

    /* Update for Delay: '<S293>/Delay' */
    Model_Target_DW.Delay_DSTATE_n0 = acc_0;

    /* Update for M-S-Function: '<S283>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoisePostSlew '<S283>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 10, &Model_Target_B.PostSlew_j);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S284>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoisePreSlew '<S284>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 12, &Model_Target_B.Add_o);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S292>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseImpulseRejectionPmin '<S292>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 8, &Model_Target_B.SumofElements);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S301>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotHfNoiseImpulseRejectionFlatness '<S301>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 7, &Model_Target_B.flatness);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S452>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotRatioPostSlew '<S452>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 33, &Model_Target_B.PostSlew);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S453>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotRatioPreSlew '<S453>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 34, &Model_Target_B.Sum2);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S456>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotRatioUpdateFlag '<S456>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 35, &Model_Target_B.LFUPFlag);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S25>/AudioPilot35' */
}

/* Model step function for TID7 */
void Model_Target_step7(void)    /* Sample time: [0.18488888888888888s, 0.0s] */
{
    creal32_T y_p[31];
    creal32_T *tmp;
    int32_T i;
    int32_T loop;
    int32_T nSamps;
    int32_T yIdx;
    real32_T y_l[31];
    real32_T NoisePreSlew;
    real32_T Slew;
    real32_T rtb_RateTransition3;
    real32_T rtb_Switch_a;

    /* Outputs for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* RateTransition: '<S251>/Rate Transition' */
    if (Model_Target_M->Timing.RateInteraction.TID7_8)
    {
        /* RateTransition: '<S251>/Rate Transition' */
        Model_Target_B.RateTransition = Model_Target_DW.RateTransition_Buffer0;
    }

    /* End of RateTransition: '<S251>/Rate Transition' */

    /* RateTransition: '<S251>/Rate Transition3' */
    Model_Target_DW.RateTransition3_semaphoreTaken = 1;
    rtb_RateTransition3 = Model_Target_DW.RateTransition3_Buffer0;
    Model_Target_DW.RateTransition3_semaphoreTaken = 0;

    /* MATLAB Function: '<S434>/SpeedBounds' incorporates:
     *  S-Function (TOP_MEX): '<S444>/TOP'
     *  S-Function (TOP_MEX): '<S445>/TOP'
     *  S-Function (TOP_MEX): '<S446>/TOP'
     */
    /*  Apply speed bounds to the noise */
    /*  Set up speed bound flag for slewing */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/SpeedBoundsAndNoiseSlew/SpeedBounds/SpeedBounds': '<S443>:1' */
    /* '<S443>:1:7' if SpeedBoundOn > 0 */
    if (Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsOn > 0.0F)
    {
        /*  limit input speed to the range of indices in the table */
        /* '<S443>:1:9' Speed = min(Speed, SpeedAxis(end)); */
        /* '<S443>:1:10' Speed = max(Speed, SpeedAxis(1)); */
        NoisePreSlew = fmaxf(fminf(rtb_RateTransition3,
                              Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsAxis
                              [127]),
                             Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsAxis
                             [0]);

        /*  interpolate if speed does not match indices exactly */
        /* '<S443>:1:12' CurrNoiseBoundL = interp1(SpeedAxis, BoundLow, Speed, 'linear'); */
        rtb_RateTransition3 = Model_Target_interp1_m
            (&(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsAxis[0]),
             &(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsMinDbspl[0]),
             NoisePreSlew);

        /* '<S443>:1:13' CurrNoiseBoundH = interp1(SpeedAxis, BoundHigh, Speed, 'linear'); */
        Slew = Model_Target_interp1_m
            (&(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsAxis[0]),
             &(Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsMaxDbspl[0]),
             NoisePreSlew);

        /*  apply speed bounds */
        /* '<S443>:1:15' NoisePreSlew = single(max(Noise, CurrNoiseBoundL)); */
        /* '<S443>:1:16' NoisePreSlew = single(min(NoisePreSlew, CurrNoiseBoundH)); */
        NoisePreSlew = fminf(fmaxf(0.0F, rtb_RateTransition3), Slew);

        /*  set up speed bounds flag */
        /* '<S443>:1:19' if (NoisePreSlew ~= Noise) */
        if (NoisePreSlew != 0.0F)
        {
            /* '<S443>:1:20' SpeedBoundFlag = 1; */
            Model_Target_B.SpeedBoundFlag = 1.0;
        }
        else
        {
            /* '<S443>:1:21' else */
            /* '<S443>:1:22' SpeedBoundFlag = 0; */
            Model_Target_B.SpeedBoundFlag = 0.0;
        }
    }
    else
    {
        /* '<S443>:1:24' else */
        /*  else: pass noise through */
        /*  unset speed bound flag */
        /* '<S443>:1:27' NoisePreSlew = single(Noise); */
        NoisePreSlew = 0.0F;

        /* '<S443>:1:28' SpeedBoundFlag = 0; */
        Model_Target_B.SpeedBoundFlag = 0.0;

        /* '<S443>:1:29' CurrNoiseBoundL = single(0); */
        rtb_RateTransition3 = 0.0F;

        /* '<S443>:1:30' CurrNoiseBoundH = single(0); */
        Slew = 0.0F;
    }

    Model_Target_B.NoisePreSlew = NoisePreSlew;
    Model_Target_B.CurrNoiseBoundL = rtb_RateTransition3;
    Model_Target_B.CurrNoiseBoundH = Slew;

    /* End of MATLAB Function: '<S434>/SpeedBounds' */
    /* MATLAB Function: '<S433>/Slew' */
    /* MATLAB Function 'Slew': '<S437>:1' */
    /* '<S437>:1:5' if isempty(PrevChange) */
    /* '<S437>:1:6' if isempty(PrevDelta) */
    /* '<S437>:1:7' if isempty(PrevPostSlew) */
    if (!Model_Target_DW.PrevPostSlew_not_empty_i)
    {
        /* '<S437>:1:7' ; */
        /* '<S437>:1:7' PrevPostSlew = single(SlewInit); */
        Model_Target_DW.PrevPostSlew_h =
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSpeedBoundsMinBoundsLowestValDbspl;
        Model_Target_DW.PrevPostSlew_not_empty_i = true;
    }

    /* '<S437>:1:9' Delta = PreSlew - PrevPostSlew; */
    rtb_Switch_a = Model_Target_B.NoisePreSlew - Model_Target_DW.PrevPostSlew_h;

    /* '<S437>:1:11' if Delta > 0 */
    if (rtb_Switch_a > 0.0F)
    {
        /*  setup for positive delta */
        /* '<S437>:1:12' Change = min(SlewAttack, Delta); */
        rtb_RateTransition3 = fminf
            (Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSlewAttackDbPerSample,
             rtb_Switch_a);

        /* '<S437>:1:13' SlowSlew = min(SlowSlew, Delta); */
        NoisePreSlew = fminf
            (Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSlewSlowDbPerSample,
             rtb_Switch_a);
    }
    else
    {
        /* '<S437>:1:14' else */
        /*  setup for negative delta */
        /* '<S437>:1:15' Change = max(SlewDecay, Delta); */
        rtb_RateTransition3 = fmaxf
            (Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSlewDecayDbPerSample,
             rtb_Switch_a);

        /* '<S437>:1:16' SlowSlew = max(-SlowSlew, Delta); */
        NoisePreSlew = fmaxf
            (-Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSlewSlowDbPerSample,
             rtb_Switch_a);
    }

    /* '<S437>:1:19' if PrevDelta*Delta > 0 */
    if (Model_Target_DW.PrevDelta_b * rtb_Switch_a > 0.0F)
    {
        /*  did we reach our target? */
        /* '<S437>:1:20' Slew = single(PrevChange); */
        Slew = Model_Target_DW.PrevChange_n;

        /*  no, continue the current path */
    }
    else
    {
        /* '<S437>:1:21' else */
        /*  otherwise, we have reached our target */
        /* '<S437>:1:22' Slew = single(0); */
        Slew = 0.0F;

        /*  no slew in the dead zone */
    }

    /* '<S437>:1:25' if SpeedBoundFlag && Slew == 0 */
    if ((Model_Target_B.SpeedBoundFlag != 0.0) && (Slew == 0.0F))
    {
        /*  are we speed-bounded? */
        /* '<S437>:1:26' Slew = SlowSlew; */
        Slew = NoisePreSlew;

        /*  yes, change to a slow slew */
    }

    /* '<S437>:1:29' if (abs(Delta) <= SlewThreshold) ...		% are we within the zone? */
    /* '<S437>:1:30' 		&& (abs(Slew) < abs(Change)) */
    if ((qhmath_abs_f(rtb_Switch_a) <=
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSlewThresholdDb) &&
            (qhmath_abs_f(Slew) < qhmath_abs_f(rtb_RateTransition3)))
    {
        /* 		% are we within the zone? */
        /*  is change still bigger than slew? */
        /*  (offshoot protection)x */
        /* '<S437>:1:32' Change = Slew; */
        rtb_RateTransition3 = Slew;

        /*  freeze or continue the current */
    }

    /* '<S437>:1:35' PrevDelta = Delta; */
    Model_Target_DW.PrevDelta_b = rtb_Switch_a;

    /* '<S437>:1:36' PrevChange = Change; */
    Model_Target_DW.PrevChange_n = rtb_RateTransition3;

    /* '<S437>:1:38' PrevPostSlew = PrevPostSlew + Change; */
    Model_Target_DW.PrevPostSlew_h += rtb_RateTransition3;

    /* '<S437>:1:39' PostSlew = PrevPostSlew; */
    Model_Target_B.PostSlew_l = Model_Target_DW.PrevPostSlew_h;

    /* End of MATLAB Function: '<S433>/Slew' */

    /* RateTransition: '<S249>/LFNoise postSmooth Rate Transition' */
    Model_Target_DW.LFNoisepostSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew_l;
    Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx = (int8_T)
        (Model_Target_DW.LFNoisepostSmoothRateTransition_ActiveBufIdx == 0);

    /* RateTransition: '<S249>/LFNoise preSmooth Rate Transition' */
    Model_Target_DW.LFNoisepreSmoothRateTransition_Buffer[Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx
        == 0] = Model_Target_B.RateTransition;
    Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx = (int8_T)
        (Model_Target_DW.LFNoisepreSmoothRateTransition_ActiveBufIdx == 0);

    /* RateTransition: '<S251>/Rate Transition6' */
    Model_Target_DW.RateTransition6_semaphoreTaken = 1;
    rtb_Switch_a = Model_Target_DW.RateTransition6_Buffer0;
    Model_Target_DW.RateTransition6_semaphoreTaken = 0;

    /* MinMax: '<S352>/MinMax1' incorporates:
     *  Bias: '<S352>/Bias'
     *  Gain: '<S352>/Gain'
     *  Sum: '<S352>/Add'
     */
    rtb_Switch_a = fmaxf(fmaxf(Model_Target_B.PostSlew_l, rtb_Switch_a),
                         (Model_Target_B.PostSlew_l + rtb_Switch_a) * 0.5F +
                         3.7F);

    /* Buffer: '<S369>/Buffer' */
    yIdx = 0;
    loop = Model_Target_DW.Buffer_outBufPtrIdx_i - 128;
    if (Model_Target_DW.Buffer_outBufPtrIdx_i - 128 < 0)
    {
        loop = Model_Target_DW.Buffer_outBufPtrIdx_i + 384;
    }

    nSamps = 256;
    if (loop > 256)
    {
        for (i = 0; i < 512 - loop; i++)
        {
            Model_Target_B.Buffer_i[i] = Model_Target_DW.Buffer_CircBuf_d[loop +
                i];
        }

        yIdx = 512 - loop;
        nSamps = loop - 256;
        loop = 0;
    }

    for (i = 0; i < nSamps; i++)
    {
        Model_Target_B.Buffer_i[yIdx + i] =
            Model_Target_DW.Buffer_CircBuf_d[loop + i];
    }

    yIdx += nSamps;
    loop = Model_Target_DW.Buffer_outBufPtrIdx_i - 128;
    if (Model_Target_DW.Buffer_outBufPtrIdx_i - 128 < 0)
    {
        loop = Model_Target_DW.Buffer_outBufPtrIdx_i + 384;
    }

    nSamps = 256;
    if (loop > 256)
    {
        for (i = 0; i < 512 - loop; i++)
        {
            Model_Target_B.Buffer_i[yIdx + i] =
                Model_Target_DW.Buffer_CircBuf_d[(loop + i) + 512];
        }

        yIdx = (yIdx - loop) + 512;
        nSamps = loop - 256;
        loop = 0;
    }

    for (i = 0; i < nSamps; i++)
    {
        Model_Target_B.Buffer_i[yIdx + i] = Model_Target_DW.Buffer_CircBuf_d
            [(loop + i) + 512];
    }

    loop += nSamps;
    if (loop == 512)
    {
        loop = 0;
    }

    Model_Target_DW.Buffer_outBufPtrIdx_i = loop;

    /* End of Buffer: '<S369>/Buffer' */

    /* MATLAB Function: '<S373>/Windowing' incorporates:
     *  Buffer: '<S369>/Buffer'
     *  Constant: '<S369>/const'
     */
    memcpy(&LfRfftWindowRfftInput[0], &Model_Target_B.Buffer_i[0], sizeof
           (real32_T) << 9U);

    /*  Get sizes */
    /* MATLAB Function 'RfftWindowing/Windowing': '<S375>:1' */
    /* '<S375>:1:4' [~, numChannels] = size(u); */
    /*  Loop since array-vector multiply operation doesn't work here */
    /*  Input/Output have the same variable name for in-place processing */
    /* '<S375>:1:8' for i = 1:numChannels */
    for (i = 0; i < 2; i++)
    {
        /* '<S375>:1:9' u(:, i) = u(:,i) .* win; */
        for (yIdx = 0; yIdx < 256; yIdx++)
        {
            loop = (i << 8) + yIdx;
            LfRfftWindowRfftInput[loop] = LfRfftWindowRfftInput[loop] *
                Model_Target_ConstP.pooled51[yIdx];
        }
    }

    /* End of MATLAB Function: '<S373>/Windowing' */

    /* MATLAB Function: '<S377>/MATLAB Function1' */
    /*  Computes the Real FFT of a Multi-Channel Signal.  */
    /*  During Code Generation, hexagon rfft crl function is used. */
    /*  Inputs: */
    /*      u - purely real signal.  */
    /*          size = [fftSize, numChannels] */
    /*      fftSize - size of each input channel. Also the size of FFT */
    /*  Outputs: */
    /*      y - fftSize/2 + 1 unique FFT coefficients of each channel of u. */
    /*          size = [fftSize/2 + 1, numChannels] */
    /*  ------------------------------------------------------------------------- */
    /* MATLAB Function 'Rfft/Rfft/Hexagon/MATLAB Function1': '<S380>:1' */
    /* '<S380>:1:17' numChannels = size(u, 2); */
    /* '<S380>:1:18' spectrumSize = (fftSize/2) + 1; */
    /*  Nullcopy copies type, size, and complexity of input to output */
    /* '<S380>:1:21' y = coder.nullcopy(complex(single(zeros(spectrumSize, numChannels)))); */
    /*  Simulation */
    /* '<S380>:1:24' if(coder.target('MATLAB') || coder.target('Sfun')) */
    /* '<S380>:1:27' else */
    /* '<S380>:1:28' y = rfft_process(single(u), Twiddle1, Twiddle2, RfftOutputTmp, int32(fftSize), int32(numChannels)); */
    rfft_process(&Model_Target_B.y_m[0], &LfRfftWindowRfftInput[0],
                 &LfRfftWindowRfftBufferTwiddle1[0],
                 &LfRfftWindowRfftBufferTwiddle2[0],
                 &LfRfftWindowRfftBufferRfftOutputTmp[0], 256, 2);

    /* S-Function (sdspsubmtrx): '<S368>/BandLimitingMic' */
    memcpy(&Model_Target_B.BandLimitingMic[0], &Model_Target_B.y_m[135], 31U *
           sizeof(creal32_T));

    /* S-Function (sdspsubmtrx): '<S368>/BandLimitingRef' */
    memcpy(&Model_Target_B.BandLimitingRef[0], &Model_Target_B.y_m[6], 31U *
           sizeof(creal32_T));

    /* MATLAB Function: '<S368>/CrossPSD' incorporates:
     *  Constant: '<S368>/WelchSize'
     */
    /*  This function forms the power spectral density over */
    /*  LFWELCHSIZE frames. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfMusicNoiseSeparation/Coherence/CrossPSD': '<S370>:1' */
    /* '<S370>:1:5' K = LFWELCHSIZE; */
    /*  Double States */
    /*  Holds the PSD accumulation */
    /*  Contains the previous PSD */
    /* '<S370>:1:12' if isempty(counter) */
    /* '<S370>:1:13' if isempty(Psd) */
    /* '<S370>:1:14' if isempty(prevout) */
    /*  Increment the counter */
    /* '<S370>:1:17' counter = counter + 1; */
    Model_Target_DW.counter_l++;

    /*  The output is the previous PSD for K frames until */
    /*  the next PSD is ready */
    /* '<S370>:1:21' if counter < K */
    if (Model_Target_DW.counter_l < 3.0)
    {
        /* '<S370>:1:22' Psd = Psd + u/K; */
        /* '<S370>:1:23' y = prevout; */
        for (yIdx = 0; yIdx < 31; yIdx++)
        {
            real32_T re;
            real32_T re_tmp;

            /* Math: '<S368>/Math Function' incorporates:
             *  S-Function (sdspsubmtrx): '<S368>/BandLimitingMic'
             */
            rtb_RateTransition3 = Model_Target_B.BandLimitingMic[yIdx].re;
            NoisePreSlew = -Model_Target_B.BandLimitingMic[yIdx].im;

            /* Product: '<S368>/Product3' incorporates:
             *  S-Function (sdspsubmtrx): '<S368>/BandLimitingRef'
             */
            Slew = Model_Target_B.BandLimitingRef[yIdx].re;
            re_tmp = Model_Target_B.BandLimitingRef[yIdx].im;
            re = Slew * rtb_RateTransition3 - re_tmp * NoisePreSlew;
            NoisePreSlew = Slew * NoisePreSlew + re_tmp * rtb_RateTransition3;
            if (NoisePreSlew == 0.0F)
            {
                rtb_RateTransition3 = qhmath_div_f(re, 3.0F);
                NoisePreSlew = 0.0F;
            }
            else if (re == 0.0F)
            {
                rtb_RateTransition3 = 0.0F;
                NoisePreSlew = qhmath_div_f(NoisePreSlew, 3.0F);
            }
            else
            {
                rtb_RateTransition3 = qhmath_div_f(re, 3.0F);
                NoisePreSlew = qhmath_div_f(NoisePreSlew, 3.0F);
            }

            Model_Target_DW.Psd[yIdx].re += rtb_RateTransition3;
            Model_Target_DW.Psd[yIdx].im += NoisePreSlew;
            y_p[yIdx] = Model_Target_DW.prevout[yIdx];
        }
    }
    else if (Model_Target_DW.counter_l == 3.0)
    {
        /* '<S370>:1:24' elseif counter ==K */
        /* '<S370>:1:25' y = Psd; */
        /* '<S370>:1:26' prevout = Psd; */
        /* '<S370>:1:27' Psd = complex(single(zeros(size(u)))); */
        for (i = 0; i < 31; i++)
        {
            y_p[i] = Model_Target_DW.Psd[i];
            Model_Target_DW.prevout[i] = Model_Target_DW.Psd[i];
            Model_Target_DW.Psd[i].re = 0.0F;
            Model_Target_DW.Psd[i].im = 0.0F;
        }

        /* '<S370>:1:28' counter = 0; */
        Model_Target_DW.counter_l = 0.0;
    }
    else
    {
        /* '<S370>:1:29' else */
        /* '<S370>:1:30' y = prevout; */
        memcpy(&y_p[0], &Model_Target_DW.prevout[0], 31U * sizeof(creal32_T));
    }

    /* End of MATLAB Function: '<S368>/CrossPSD' */

    /* MATLAB Function: '<S368>/RefPSD ' incorporates:
     *  Constant: '<S368>/WelchSize'
     *  Math: '<S368>/Math Function2'
     *
     * About '<S368>/Math Function2':
     *  Operator: magnitude^2
     */
    /*  This function forms the power spectral density over */
    /*  LFWELCHSIZE frames. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfMusicNoiseSeparation/Coherence/RefPSD ': '<S372>:1' */
    /* '<S372>:1:5' K = LFWELCHSIZE; */
    /*  Double States */
    /*  Holds the PSD accumulation */
    /*  Contains the previous PSD */
    /* '<S372>:1:12' if isempty(counter) */
    /* '<S372>:1:13' if isempty(Psd) */
    /* '<S372>:1:14' if isempty(prevout) */
    /*  Increment the counter */
    /* '<S372>:1:17' counter = counter + 1; */
    Model_Target_DW.counter_f++;

    /*  The output is the previous PSD for K frames until */
    /*  the next PSD is ready */
    /* '<S372>:1:21' if counter < K */
    if (Model_Target_DW.counter_f < 3.0)
    {
        /* '<S372>:1:22' Psd = Psd + u/K; */
        /* '<S372>:1:23' y = prevout; */
        for (yIdx = 0; yIdx < 31; yIdx++)
        {
            /* Math: '<S368>/Math Function2' incorporates:
             *  Math: '<S368>/Math Function3'
             *  S-Function (sdspsubmtrx): '<S368>/BandLimitingMic'
             *  S-Function (sdspsubmtrx): '<S368>/BandLimitingRef'
             *
             * About '<S368>/Math Function2':
             *  Operator: magnitude^2
             *
             * About '<S368>/Math Function3':
             *  Operator: magnitude^2
             */
            tmp = &Model_Target_B.BandLimitingRef[yIdx];
            Model_Target_DW.Psd_g[yIdx] += qhmath_div_f(tmp->re * tmp->re +
                tmp->im * tmp->im, 3.0F);
            y_l[yIdx] = Model_Target_DW.prevout_j[yIdx];
        }
    }
    else if (Model_Target_DW.counter_f == 3.0)
    {
        /* '<S372>:1:24' elseif counter ==K */
        /* '<S372>:1:25' y = Psd; */
        /* '<S372>:1:26' prevout = Psd; */
        /* '<S372>:1:27' Psd = single(zeros(size(u))); */
        for (i = 0; i < 31; i++)
        {
            y_l[i] = Model_Target_DW.Psd_g[i];
            Model_Target_DW.prevout_j[i] = Model_Target_DW.Psd_g[i];
            Model_Target_DW.Psd_g[i] = 0.0F;
        }

        /* '<S372>:1:28' counter = 0; */
        Model_Target_DW.counter_f = 0.0;
    }
    else
    {
        /* '<S372>:1:29' else */
        /* '<S372>:1:30' y = prevout; */
        memcpy(&y_l[0], &Model_Target_DW.prevout_j[0], 31U * sizeof(real32_T));
    }

    /* End of MATLAB Function: '<S368>/RefPSD ' */

    /* DownSample: '<S368>/DownsampleGxx' incorporates:
     *  DownSample: '<S368>/DownsampleGyx'
     */
    if (Model_Target_M->Timing.RateInteraction.TID7_8)
    {
        /* DownSample: '<S368>/DownsampleGxx' */
        memcpy(&Model_Target_B.DownsampleGxx[0], &y_l[0], 31U * sizeof(real32_T));

        /* DownSample: '<S368>/DownsampleGyx' */
        memcpy(&Model_Target_B.DownsampleGyx[0], &y_p[0], 31U * sizeof(creal32_T));
    }

    /* End of DownSample: '<S368>/DownsampleGxx' */

    /* MATLAB Function: '<S368>/MicPSD' incorporates:
     *  Constant: '<S368>/WelchSize'
     *  Math: '<S368>/Math Function3'
     *
     * About '<S368>/Math Function3':
     *  Operator: magnitude^2
     */
    /*  This function forms the power spectral density over */
    /*  LFWELCHSIZE frames. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfMusicNoiseSeparation/Coherence/MicPSD': '<S371>:1' */
    /* '<S371>:1:5' K = LFWELCHSIZE; */
    /*  Double States */
    /*  Holds the PSD accumulation */
    /*  Contains the previous PSD */
    /* '<S371>:1:12' if isempty(counter) */
    /* '<S371>:1:13' if isempty(Psd) */
    /* '<S371>:1:14' if isempty(prevout) */
    /*  Increment the counter */
    /* '<S371>:1:17' counter = counter + 1; */
    Model_Target_DW.counter_fg++;

    /*  The output is the previous PSD for K frames until */
    /*  the next PSD is ready */
    /* '<S371>:1:21' if counter < K */
    if (Model_Target_DW.counter_fg < 3.0)
    {
        /* '<S371>:1:22' Psd = Psd + u/K; */
        /* '<S371>:1:23' y = prevout; */
        for (yIdx = 0; yIdx < 31; yIdx++)
        {
            /* Math: '<S368>/Math Function3' incorporates:
             *  Math: '<S368>/Math Function2'
             *  S-Function (sdspsubmtrx): '<S368>/BandLimitingMic'
             *  S-Function (sdspsubmtrx): '<S368>/BandLimitingRef'
             *
             * About '<S368>/Math Function3':
             *  Operator: magnitude^2
             *
             * About '<S368>/Math Function2':
             *  Operator: magnitude^2
             */
            tmp = &Model_Target_B.BandLimitingMic[yIdx];
            Model_Target_DW.Psd_h[yIdx] += qhmath_div_f(tmp->re * tmp->re +
                tmp->im * tmp->im, 3.0F);
            y_l[yIdx] = Model_Target_DW.prevout_c[yIdx];
        }
    }
    else if (Model_Target_DW.counter_fg == 3.0)
    {
        /* '<S371>:1:24' elseif counter ==K */
        /* '<S371>:1:25' y = Psd; */
        /* '<S371>:1:26' prevout = Psd; */
        /* '<S371>:1:27' Psd = single(zeros(size(u))); */
        for (i = 0; i < 31; i++)
        {
            y_l[i] = Model_Target_DW.Psd_h[i];
            Model_Target_DW.prevout_c[i] = Model_Target_DW.Psd_h[i];
            Model_Target_DW.Psd_h[i] = 0.0F;
        }

        /* '<S371>:1:28' counter = 0; */
        Model_Target_DW.counter_fg = 0.0;
    }
    else
    {
        /* '<S371>:1:29' else */
        /* '<S371>:1:30' y = prevout; */
        memcpy(&y_l[0], &Model_Target_DW.prevout_c[0], 31U * sizeof(real32_T));
    }

    /* End of MATLAB Function: '<S368>/MicPSD' */

    /* DownSample: '<S368>/DownsampleGyy' */
    if (Model_Target_M->Timing.RateInteraction.TID7_8)
    {
        /* DownSample: '<S368>/DownsampleGyy' */
        memcpy(&Model_Target_B.DownsampleGyy[0], &y_l[0], 31U * sizeof(real32_T));
    }

    /* End of DownSample: '<S368>/DownsampleGyy' */
    /* RateTransition: '<S34>/Rate Transition1' */
    Model_Target_DW.RateTransition1_Buffer_k[Model_Target_DW.RateTransition1_ActiveBufIdx
        == 0] = Model_Target_B.PostSlew_l;
    Model_Target_DW.RateTransition1_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition1_ActiveBufIdx == 0);

    /* RateTransition: '<S34>/Rate Transition11' */
    Model_Target_DW.RateTransition11_Buffer[Model_Target_DW.RateTransition11_ActiveBufIdx
        == 0] = rtb_Switch_a;
    Model_Target_DW.RateTransition11_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition11_ActiveBufIdx == 0);

    /* RateTransition: '<S34>/Rate Transition9' */
    Model_Target_DW.RateTransition9_Buffer[Model_Target_DW.RateTransition9_ActiveBufIdx
        == 0] = rtb_Switch_a;
    Model_Target_DW.RateTransition9_ActiveBufIdx = (int8_T)
        (Model_Target_DW.RateTransition9_ActiveBufIdx == 0);

    /* End of Outputs for SubSystem: '<S25>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Update for M-S-Function: '<S362>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoisePostSlew '<S362>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 26, &Model_Target_B.PostSlew_l);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S363>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoisePreSlew '<S363>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 27, &Model_Target_B.NoisePreSlew);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S364>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoisePreSpeedBound '<S364>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 28, &Model_Target_B.RateTransition);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S440>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseSpeedBoundsCurrMax '<S440>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 29, &Model_Target_B.CurrNoiseBoundH);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S441>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseSpeedBoundsCurrMin '<S441>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 30, &Model_Target_B.CurrNoiseBoundL);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S442>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseSpeedBoundsFlag '<S442>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 31, &Model_Target_B.SpeedBoundFlag);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S25>/AudioPilot35' */
}

/* Model step function for TID8 */
void Model_Target_step8(void)    /* Sample time: [0.55466666666666664s, 0.0s] */
{
    creal32_T *tmp;
    int32_T i;
    real32_T ImpRejFiltCoef;
    real32_T TotalVar;
    real32_T rtb_PreNoisedBSPL;
    real32_T rtb_Sqrt;
    real32_T rtb_Sqrt1;
    real32_T u0;

    /* Outputs for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Sum: '<S353>/Sum of Elements3' */
    rtb_Sqrt1 = -0.0F;

    /* Sum: '<S353>/Sum of Elements2' */
    rtb_Sqrt = -0.0F;
    for (i = 0; i < 31; i++)
    {
        /* Sum: '<S353>/Sum of Elements3' incorporates:
         *  DownSample: '<S368>/DownsampleGyy'
         */
        rtb_Sqrt1 += Model_Target_B.DownsampleGyy[i];

        /* Math: '<S368>/Math Function1' incorporates:
         *  DownSample: '<S368>/DownsampleGyx'
         *
         * About '<S368>/Math Function1':
         *  Operator: magnitude^2
         */
        tmp = &Model_Target_B.DownsampleGyx[i];

        /* Product: '<S368>/Divide' incorporates:
         *  Constant: '<S368>/DivideByZero'
         *  DownSample: '<S368>/DownsampleGxx'
         *  DownSample: '<S368>/DownsampleGyy'
         *  Math: '<S368>/Math Function1'
         *  Product: '<S368>/Product'
         *  Sum: '<S368>/Add1'
         *
         * About '<S368>/Math Function1':
         *  Operator: magnitude^2
         */
        u0 = qhmath_div_f(1.0F, Model_Target_B.DownsampleGxx[i] *
                          Model_Target_B.DownsampleGyy[i] + 2.22044605E-16F) *
            (tmp->re * tmp->re + tmp->im * tmp->im);

        /* Saturate: '<S368>/Saturation' */
        if (u0 > 1.0F)
        {
            u0 = 1.0F;
        }
        else if (u0 < 0.0F)
        {
            u0 = 0.0F;
        }

        /* Sum: '<S353>/Sum of Elements2' incorporates:
         *  Constant: '<S353>/Constant1'
         *  DownSample: '<S368>/DownsampleGyy'
         *  Product: '<S353>/Product'
         *  Saturate: '<S368>/Saturation'
         *  Sum: '<S353>/Subtract1'
         */
        rtb_Sqrt += (1.0F - u0) * Model_Target_B.DownsampleGyy[i];
    }

    /* Gain: '<S353>/Gain3' incorporates:
     *  Sqrt: '<S353>/Sqrt2'
     */
    Model_Target_B.Gain3 = 0.0078125F * qhmath_sqrt_f(rtb_Sqrt1);

    /* Gain: '<S353>/Gain2' incorporates:
     *  Constant: '<S353>/Constant'
     *  MinMax: '<S353>/Max'
     *  Sqrt: '<S353>/Sqrt1'
     *  Sum: '<S353>/Subtract2'
     */
    Model_Target_B.Gain2 = qhmath_sqrt_f(fmaxf(rtb_Sqrt1 - rtb_Sqrt, 0.0F)) *
        0.0078125F;

    /* Gain: '<S353>/Gain' incorporates:
     *  Sqrt: '<S353>/Sqrt'
     */
    Model_Target_B.Gain = 0.0078125F * qhmath_sqrt_f(rtb_Sqrt);

    /* MATLAB Function: '<S251>/LfNoiseEnergyCalculation' */
    /*  Energy salculation has been simplified from before */
    /*  This is now just a smoothing of the output from the */
    /*  coherence calculations. */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfNoiseEnergyCalculation': '<S354>:1' */
    /*  States  */
    /*  Initialization */
    /* '<S354>:1:11' if isempty(MusicLPState) */
    /* '<S354>:1:14' if isempty(NoiseLPState) */
    /* '<S354>:1:17' if isempty(MicLPState) */
    /*  Energy Conversion */
    /* '<S354>:1:22' MusicLPState     = MusicLPState*EngyFiltCoef ... */
    /* '<S354>:1:23' 	+ abs(Music)*(1-EngyFiltCoef); */
    Model_Target_DW.MusicLPState = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseEnergyLpfCoef) * qhmath_abs_f
        (Model_Target_B.Gain2) + Model_Target_DW.MusicLPState *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseEnergyLpfCoef;

    /* '<S354>:1:24' NoiseLPState     = NoiseLPState*EngyFiltCoef ... */
    /* '<S354>:1:25' 	+ abs(Noise)*(1-EngyFiltCoef); */
    Model_Target_DW.NoiseLPState = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseEnergyLpfCoef) * qhmath_abs_f
        (Model_Target_B.Gain) + Model_Target_DW.NoiseLPState *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseEnergyLpfCoef;

    /* '<S354>:1:26' MicLPState       = MicLPState*EngyFiltCoef ... */
    /* '<S354>:1:27' 	+ abs(Mic)*(1-EngyFiltCoef); */
    Model_Target_DW.MicLPState = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseEnergyLpfCoef) * qhmath_abs_f
        (Model_Target_B.Gain3) + Model_Target_DW.MicLPState *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseEnergyLpfCoef;

    /* S-Function (TOP_MEX): '<S386>/TOP' */
    /*  Output */
    /* '<S354>:1:30' MusicLP = MusicLPState; */
    /* '<S354>:1:31' NoiseLP = NoiseLPState; */
    /* '<S354>:1:32' MicLP = MicLPState; */
    /* MATLAB Function: '<S355>/NoiseCalculations' incorporates:
     *  MATLAB Function: '<S251>/LfNoiseEnergyCalculation'
     */
    /*  Function that conditions the noise energy. */
    /*  Performs impulse rejection */
    /*  Microphone energy check */
    /*  Convert to dBSPL */
    /*  Also outputs various intermediate check points */
    /* MATLAB Function 'ModelPreAmp/DecRate/AudioPilot35/Audiopilot_3_5/NoiseEstimationVariant/RegularNoiseEstimation/LFNoiseEstimatorCoh/LfNoiseImpulseRejection/NoiseCalculations': '<S390>:1' */
    /*  States */
    /*  Initialize to zero */
    /* '<S390>:1:19' if isempty(ImpFiltState) */
    /* '<S390>:1:22' if isempty(FiltOut) */
    if (!Model_Target_DW.FiltOut_not_empty)
    {
        /* '<S390>:1:23' FiltOut   = single(ImpRejFiltOutMin); */
        Model_Target_DW.FiltOut =
            Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionOutputMin;
        Model_Target_DW.FiltOut_not_empty = true;
    }

    /*  Impulse Estimate */
    /*  A First-Order Filter is applied twice */
    /* '<S390>:1:28' ImpFiltState(1) = ImpFiltState(1)*ImpFiltCoef ... */
    /* '<S390>:1:29' 	+ ErrorLP*(1-ImpFiltCoef); */
    Model_Target_DW.ImpFiltState_a[0] = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef)
        * Model_Target_DW.NoiseLPState + Model_Target_DW.ImpFiltState_a[0] *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef;

    /* '<S390>:1:30' ImpFiltState(2) = ImpFiltState(2)*ImpFiltCoef ... */
    /* '<S390>:1:31' 	+ ImpFiltState(1)*(1-ImpFiltCoef); */
    Model_Target_DW.ImpFiltState_a[1] = (1.0F -
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef)
        * Model_Target_DW.ImpFiltState_a[0] + Model_Target_DW.ImpFiltState_a[1] *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceFilterCoef;

    /*  Variances & Scaling */
    /* '<S390>:1:34' MusicVar = MusicScale * MusicLP^2; */
    rtb_Sqrt = Model_Target_DW.MusicLPState * Model_Target_DW.MusicLPState *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionMusicVarianceScale;

    /* '<S390>:1:35' NoiseVar = NoiseScale * ImpFiltState(2)^2; */
    rtb_Sqrt1 = Model_Target_DW.ImpFiltState_a[1] *
        Model_Target_DW.ImpFiltState_a[1] *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionNoiseVarianceScale;

    /* '<S390>:1:36' ImpulseVar = ImpulseScale ... */
    /* '<S390>:1:37' 	* (max(0, ErrorLP-ImpFiltState(2)))^2; */
    u0 = fmaxf(0.0F, Model_Target_DW.NoiseLPState -
               Model_Target_DW.ImpFiltState_a[1]);
    u0 = u0 * u0 *
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionImpulseVarianceScale;

    /* '<S390>:1:38' TotalVar = NoiseVar + max(0, MusicVar+ImpulseVar); */
    TotalVar = fmaxf(0.0F, rtb_Sqrt + u0) + rtb_Sqrt1;

    /*  Gamma correction */
    /* '<S390>:1:41' ImpRejFiltCoef = 1 - Gamma0*NoiseVar/(TotalVar+eps); */
    ImpRejFiltCoef = 1.0F - qhmath_div_f
        (Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionGamma0 *
         rtb_Sqrt1, TotalVar + 2.22044605E-16F);

    /*  Impulse Reject Filter */
    /* '<S390>:1:44' FiltOut = ImpRejFiltCoef*FiltOut+ErrorLP*(1-ImpRejFiltCoef); */
    Model_Target_DW.FiltOut = (1.0F - ImpRejFiltCoef) *
        Model_Target_DW.NoiseLPState + ImpRejFiltCoef * Model_Target_DW.FiltOut;

    /*  Set Minimum Bound */
    /* '<S390>:1:47' FiltOut = max(FiltOut, ImpRejFiltOutMin); */
    Model_Target_DW.FiltOut = fmaxf(Model_Target_DW.FiltOut,
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseImpulseRejectionOutputMin);

    /*  Filter Output */
    /* '<S390>:1:50' FilterOut = FiltOut; */
    Model_Target_B.FilterOut = Model_Target_DW.FiltOut;

    /*  dBSPL Conversion and Microphone Energy Check */
    /* '<S390>:1:53' PreNoisedBSPL = db20(FiltOut+eps)... */
    /* '<S390>:1:54' 	+ NoiseOffsetDbspl + SysMaxDbspl; */
    /* '<S390>:1:63' y = 20*log10(abs(x)); */
    rtb_PreNoisedBSPL = (qhmath_log10_f(qhmath_abs_f(Model_Target_DW.FiltOut +
                           2.22044605E-16F)) * 20.0F +
                         Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseOffsetDb) +
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSysMaxDbspl;

    /*  Microphone Level */
    /* '<S390>:1:57' MicDbspl= db20(MicLP)+SysMaxDbspl+NoiseOffsetDbspl; */
    /* '<S390>:1:63' y = 20*log10(abs(x)); */
    Model_Target_B.MicDbspl = (20.0F * qhmath_log10_f(qhmath_abs_f
        (Model_Target_DW.MicLPState)) +
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseSysMaxDbspl) +
        Model_Target_PreAmp_p4_b0.AudiopilotLfNoiseOffsetDb;
    Model_Target_B.ImpRejFiltCoef = ImpRejFiltCoef;
    Model_Target_B.ImpulseVar = u0;
    Model_Target_B.MusicVar = rtb_Sqrt;
    Model_Target_B.NoiseVar = rtb_Sqrt1;
    Model_Target_B.TotalVar = TotalVar;

    /* End of MATLAB Function: '<S355>/NoiseCalculations' */
    /* RateTransition: '<S251>/Rate Transition' */
    Model_Target_DW.RateTransition_Buffer0 = rtb_PreNoisedBSPL;

    /* End of Outputs for SubSystem: '<S25>/AudioPilot35' */

    /* Update for Atomic SubSystem: '<S25>/AudioPilot35' */
    /* Update for M-S-Function: '<S357>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseMicLevel '<S357>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 22, &Model_Target_B.MicDbspl);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S358>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseMicOut '<S358>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 23, &Model_Target_B.Gain3);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S359>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseMusicOut '<S359>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 24, &Model_Target_B.Gain2);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S361>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseNoiseOut '<S361>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 25, &Model_Target_B.Gain);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S382>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionFilterOut '<S382>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 17, &Model_Target_B.FilterOut);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S384>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionFiltCoef '<S384>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 16, &Model_Target_B.ImpRejFiltCoef);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S385>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionImpulseVariance '<S385>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 18, &Model_Target_B.ImpulseVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S388>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionMusicVariance '<S388>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 19, &Model_Target_B.MusicVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S391>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionNoiseVariance '<S391>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 20, &Model_Target_B.NoiseVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* Update for M-S-Function: '<S394>/TSP' */
    // TSP advanced triggered capture for PreAmpAudiopilotLfNoiseImpulseRejectionTotalVariance '<S394>/TSP':
#if TSP_ENABLE_ADVANCED

    TSP_StepCapture(TspDispatchTable0204, 21, &Model_Target_B.TotalVar);

#endif                                 //TSP_ENABLE_ADVANCED

    /* End of Update for SubSystem: '<S25>/AudioPilot35' */
}

/* Model initialize function */
void Model_Target_initialize(void)
{
    {
        int32_T i;

        /* SystemInitialize for Atomic SubSystem: '<Root>/InputSelect' */
        Model_Target_InputSelect_Init();

        /* End of SystemInitialize for SubSystem: '<Root>/InputSelect' */

        /* SystemInitialize for Atomic SubSystem: '<S25>/AudioPilot35' */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S277>/ITC1' */
        InitTrigger_Model_117_516_1977_115_100();

        /* InitTriggerControl '<S328>/ITC1' */
        InitTrigger_Model_117_516_1849_50_172_192();

        /* InitTriggerControl '<S320>/ITC1' */
        InitTrigger_Model_117_516_1849_50_172_156();

        /* InitTriggerControl '<S344>/ITC1' */
        InitTrigger_Model_117_516_1847_50_172_192();

        /* InitTriggerControl '<S336>/ITC1' */
        InitTrigger_Model_117_516_1847_50_172_156();

        /* InitTriggerControl '<S378>/ITC1' */
        InitTrigger_Model_117_517_563_115_100();

        /* InitTriggerControl '<S410>/ITC1' */
        InitTrigger_Model_117_517_515_50_172_192();

        /* InitTriggerControl '<S402>/ITC1' */
        InitTrigger_Model_117_517_515_50_172_156();

        /* InitTriggerControl '<S426>/ITC1' */
        InitTrigger_Model_117_517_516_50_172_192();

        /* InitTriggerControl '<S418>/ITC1' */
        InitTrigger_Model_117_517_516_50_172_156();

        /* InitTriggerControl '<S531>/ITC1' */
        InitTrigger_Model_120_422_50_172_192();

        /* InitTriggerControl '<S523>/ITC1' */
        InitTrigger_Model_120_422_50_172_156();

        /* InitializeConditions for Buffer: '<S271>/Buffer' */
        /* Full-cycle Table lookup */
        /* This code only executes when block is re-enabled in an
           enabled subsystem when the enabled subsystem states on
           re-enabling are set to 'Reset' */
        /* Reset to time zero on re-enable */
        /* Full-cycle Table lookup */
        Model_Target_DW.Buffer_inBufPtrIdx_e = 256;
        Model_Target_DW.Buffer_outBufPtrIdx_d = 128;

        /* InitializeConditions for Buffer: '<S356>/BufferMic' */
        Model_Target_DW.BufferMic_inBufPtrIdx = 64;

        /* InitializeConditions for Buffer: '<S356>/BufferRef' */
        Model_Target_DW.BufferRef_inBufPtrIdx = 64;

        /* InitializeConditions for Buffer: '<S369>/Buffer' */
        Model_Target_DW.Buffer_inBufPtrIdx_g = 256;
        Model_Target_DW.Buffer_outBufPtrIdx_i = 128;

        /* InitializeConditions for Delay: '<S281>/Delay1' */
        for (i = 0; i < 65; i++)
        {
            Model_Target_DW.Delay1_DSTATE_n[i] = 1.0F;
        }

        /* End of InitializeConditions for Delay: '<S281>/Delay1' */

        /* InitializeConditions for Delay: '<S293>/Delay' */
        Model_Target_DW.Delay_DSTATE_n0 = 0.5F;

        /* SystemInitialize for MATLAB Function: '<S291>/ComputePmin' */
        /* Initialize phase index */
        /* Initialize input buffer values */
        /* Initialize phase index */
        /* Initialize input buffer values */
        /* Initialize phase index */
        /* Initialize input buffer values */
        /* '<S260>:1:9' init_noise_floor = false; */
        /* '<S258>:1:12' GXY=complex(single(zeros(L,M,M))); */
        /* '<S258>:1:15' frame_counter=int16(0); */
        /* '<S300>:1:19' ; */
        /* '<S300>:1:19' IRMinCount	= single(-1); */
        Model_Target_DW.IRMinCount = -1.0F;

        /* '<S300>:1:20' ; */
        /* '<S300>:1:20' IRSubMin	= single(ones(numSubWin, numFreqBins))*1e-8; */
        for (i = 0; i < 195; i++)
        {
            Model_Target_DW.IRSubMin[i] = 1.0E-8F;
        }

        /* '<S300>:1:21' ; */
        /* '<S300>:1:21' IRPowMS		= single(ones(1, numFreqBins))*1e-8; */
        for (i = 0; i < 65; i++)
        {
            Model_Target_DW.IRPowMS[i] = 1.0E-8F;
        }

        /* End of SystemInitialize for MATLAB Function: '<S291>/ComputePmin' */

        /* SystemInitialize for MATLAB Function: '<S491>/InnerLink' */
        /* '<S309>:1:5' ; */
        /* '<S309>:1:5' PrevChange = single(0); */
        /* '<S309>:1:6' ; */
        /* '<S309>:1:6' PrevDelta = single(0); */
        /* '<S350>:1:17' delayIndex = int32(0); */
        /* '<S370>:1:12' counter = 0; */
        /* '<S370>:1:13' Psd = complex(single(zeros(size(u)))); */
        /* '<S370>:1:14' prevout = complex(single(zeros(size(u)))); */
        /* '<S371>:1:12' counter = 0; */
        /* '<S371>:1:13' Psd = single(zeros(size(u))); */
        /* '<S371>:1:14' prevout = single(zeros(size(u))); */
        /* '<S372>:1:12' counter = 0; */
        /* '<S372>:1:13' Psd = single(zeros(size(u))); */
        /* '<S372>:1:14' prevout = single(zeros(size(u))); */
        /* '<S354>:1:12' MusicLPState = single(0); */
        /* '<S354>:1:15' NoiseLPState = single(0); */
        /* '<S354>:1:18' MicLPState = single(0); */
        /* '<S390>:1:20' ImpFiltState = single([0 0]); */
        /* '<S432>:1:17' delayIndex = int32(0); */
        /* '<S437>:1:5' ; */
        /* '<S437>:1:5' PrevChange = single(0); */
        /* '<S437>:1:6' ; */
        /* '<S437>:1:6' PrevDelta = single(0); */
        /* '<S457>:1:14' ; */
        /* '<S457>:1:14' prev = single(0); */
        /* '<S457>:1:15' ; */
        /* '<S457>:1:15' counter = single(0); */
        /* '<S457>:1:16' ; */
        /* '<S457>:1:16' counter2 = single(0); */
        /* '<S457>:1:17' ; */
        /* '<S457>:1:17' LFUP = single(0); */
        /* '<S464>:1:5' ; */
        /* '<S464>:1:5' PrevChange = single(0); */
        /* '<S464>:1:6' ; */
        /* '<S464>:1:6' PrevDelta = single(0); */
        /* '<S473>:1:11' ; */
        /* '<S473>:1:11' PreRatioLinLP = single(0); */
        /* '<S473>:1:12' ; */
        /* '<S473>:1:12' ImpFiltState = single([0 0]); */
        /* '<S85>:1:17' delayIndex = int32(0); */
        /* '<S234>:1:11' dyneq_boost_gain_prev = single(0); */
        /* '<S234>:1:15' audiopilot_boost_gain_prev = single(0); */
        Model_Target_InnerLink_Init(&Model_Target_DW.sf_InnerLink);

        /* SystemInitialize for MATLAB Function: '<S504>/InnerLink' */
        Model_Target_InnerLink_Init(&Model_Target_DW.sf_InnerLink_a);

        /* '<S513>:1:17' delayIndex = int32(0); */

        /* End of SystemInitialize for SubSystem: '<S25>/AudioPilot35' */

        /* SystemInitialize for Atomic SubSystem: '<S558>/Medusa5H1 Part 1' */
        Model_Target_Medusa5H1Part1_Init();

        /* End of SystemInitialize for SubSystem: '<S558>/Medusa5H1 Part 1' */

        /* SystemInitialize for Atomic SubSystem: '<S558>/Medusa5H1 Part 2' */
        Model_Target_Medusa5H1Part2_Init();

        /* End of SystemInitialize for SubSystem: '<S558>/Medusa5H1 Part 2' */

        /* SystemInitialize for Atomic SubSystem: '<S558>/Medusa5H1 Part 3' */
        Model_Target_Medusa5H1Part3_Init();

        /* End of SystemInitialize for SubSystem: '<S558>/Medusa5H1 Part 3' */

        /* SystemInitialize for Atomic SubSystem: '<S558>/Medusa5H1 Part 4' */
        Model_Target_Medusa5H1Part4_Init();

        /* End of SystemInitialize for SubSystem: '<S558>/Medusa5H1 Part 4' */

        /* SystemInitialize for Atomic SubSystem: '<S558>/Medusa5H1 Part 5' */
        Model_Target_Medusa5H1Part5_Init();

        /* End of SystemInitialize for SubSystem: '<S558>/Medusa5H1 Part 5' */

        /* SystemInitialize for Atomic SubSystem: '<S558>/Medusa5H1 Part 6' */
        Model_Target_Medusa5H1Part6_Init();

        /* End of SystemInitialize for SubSystem: '<S558>/Medusa5H1 Part 6' */

        /* SystemInitialize for Atomic SubSystem: '<S33>/MedusaPostHoligram' */

        /* SystemInitialize for Atomic SubSystem: '<S559>/MedusaPostHoligram' */
        Model_Target_MedusaPostHoligram_Init();

        /* End of SystemInitialize for SubSystem: '<S559>/MedusaPostHoligram' */

        /* End of SystemInitialize for SubSystem: '<S33>/MedusaPostHoligram' */

        /* SystemInitialize for Atomic SubSystem: '<S33>/NearWiggleFilters' */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S1341>/ITC1' */
        InitTrigger_Model_416_84();

        /* InitTriggerControl '<S1340>/ITC1' */
        InitTrigger_Model_416_65();

        /* '<S1335>:1:10' currentFadeInd = 0; */
        /* '<S1335>:1:11' currentSig = uint32(0); */

        /* End of SystemInitialize for SubSystem: '<S33>/NearWiggleFilters' */

        /* SystemInitialize for Atomic SubSystem: '<S33>/SleepingBeauty' */

        /* SystemInitialize for Atomic SubSystem: '<S1345>/Enabled' */
        Model_Target_Enabled_Init();

        /* End of SystemInitialize for SubSystem: '<S1345>/Enabled' */

        /* End of SystemInitialize for SubSystem: '<S33>/SleepingBeauty' */

        /* SystemInitialize for Atomic SubSystem: '<S33>/VLS' */
        Model_Target_VLS_Init();

        /* End of SystemInitialize for SubSystem: '<S33>/VLS' */

        /* SystemInitialize for Atomic SubSystem: '<S4>/PreAmpPart1' */
        Model_Target_PreAmpPart1_Init();

        /* End of SystemInitialize for SubSystem: '<S4>/PreAmpPart1' */

        /* SystemInitialize for Atomic SubSystem: '<S4>/SrcDownEnt' */
        Model_Target_SrcDownEnt_Init();

        /* End of SystemInitialize for SubSystem: '<S4>/SrcDownEnt' */

        /* SystemInitialize for Atomic SubSystem: '<S4>/SrcDownMic' */
        Model_Target_SrcDownMic_Init();

        /* End of SystemInitialize for SubSystem: '<S4>/SrcDownMic' */

        /* SystemInitialize for Atomic SubSystem: '<S4>/SrcUp' */
        Model_Target_SrcUp_Init();

        /* End of SystemInitialize for SubSystem: '<S4>/SrcUp' */

        /* SystemInitialize for Atomic SubSystem: '<Root>/NEAR' */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S1811>/ITC1' */
        InitTrigger_Model_1259_172_192();

        /* InitTriggerControl '<S1803>/ITC1' */
        InitTrigger_Model_1259_172_156();

        /* InitTriggerControl '<S1632>/ITC1' */
        InitTrigger_Model_771_172_192();

        /* InitTriggerControl '<S1624>/ITC1' */
        InitTrigger_Model_771_172_156();

        /* InitTriggerControl '<S1651>/ITC1' */
        InitTrigger_Model_889_172_192();

        /* InitTriggerControl '<S1643>/ITC1' */
        InitTrigger_Model_889_172_156();

        /* InitTriggerControl '<S1772>/ITC1' */
        InitTrigger_Model_1221_143_84();

        /* InitTriggerControl '<S1771>/ITC1' */
        InitTrigger_Model_1221_143_65();

        /* Start for If: '<S1607>/If' */
        Model_Target_DW.If_ActiveSubsystem = -1;

        /* SystemInitialize for Atomic SubSystem: '<S1885>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S1899>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S1902>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_k = 1U;

        /* End of SystemInitialize for SubSystem: '<S1899>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S1885>/Ramping_Subsystem' */

        /* SystemInitialize for Atomic SubSystem: '<S1965>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S1979>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S1982>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_m = 1U;

        /* End of SystemInitialize for SubSystem: '<S1979>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S1965>/Ramping_Subsystem' */

        /* SystemInitialize for Atomic SubSystem: '<S2045>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S2059>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S2062>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad_e = 1U;

        /* End of SystemInitialize for SubSystem: '<S2059>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S2045>/Ramping_Subsystem' */

        /* SystemInitialize for Atomic SubSystem: '<S2125>/Ramping_Subsystem' */
        /* SystemInitialize for IfAction SubSystem: '<S2139>/ifActionSubsystem' */
        /* InitializeConditions for DiscreteFilter: '<S2142>/ramping_filter' */
        Model_Target_DW.ramping_filter_icLoad = 1U;

        /* End of SystemInitialize for SubSystem: '<S2139>/ifActionSubsystem' */
        /* End of SystemInitialize for SubSystem: '<S2125>/Ramping_Subsystem' */

        /* SystemInitialize for MATLAB Function: '<S1814>/InnerLink' */
        Model_Target_InnerLink_g_Init(&Model_Target_DW.sf_InnerLink_n);

        /* SystemInitialize for MATLAB Function: '<S1822>/InnerLink' */
        Model_Target_InnerLink_g_Init(&Model_Target_DW.sf_InnerLink_m);

        /* SystemInitialize for MATLAB Function: '<S1830>/InnerLink' */
        Model_Target_InnerLink_g_Init(&Model_Target_DW.sf_InnerLink_ny);

        /* SystemInitialize for MATLAB Function: '<S1838>/InnerLink' */
        Model_Target_InnerLink_g_Init(&Model_Target_DW.sf_InnerLink_k);

        /* SystemInitialize for IfAction SubSystem: '<S1607>/Subsystem' */
        /* '<S1619>:1:17' delayIndex = int32(0); */
        /* '<S1638>:1:17' delayIndex = int32(0); */

        /* user code (Initialize function Body) */

        /* InitTriggerControl '<S1690>/ITC1' */
        InitTrigger_Model_1040_172_192();

        /* InitTriggerControl '<S1682>/ITC1' */
        InitTrigger_Model_1040_172_156();

        /* InitTriggerControl '<S1709>/ITC1' */
        InitTrigger_Model_1078_172_192();

        /* InitTriggerControl '<S1701>/ITC1' */
        InitTrigger_Model_1078_172_156();

        /* '<S1677>:1:17' delayIndex = int32(0); */
        /* '<S1696>:1:17' delayIndex = int32(0); */

        /* End of SystemInitialize for SubSystem: '<S1607>/Subsystem' */

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction_j4);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function1' */
        Model_Target_MATLABFunction_m_Init
            (&Model_Target_DW.sf_MATLABFunction1_io);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function2' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction2);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function3' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction3);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function4' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction4);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function5' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction5);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function6' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction6);

        /* SystemInitialize for MATLAB Function: '<S1608>/MATLAB Function7' */
        Model_Target_MATLABFunction_m_Init(&Model_Target_DW.sf_MATLABFunction7);

        /* SystemInitialize for Atomic SubSystem: '<S5>/SrcDownAnn' */
        Model_Target_SrcDownAnn_Init();

        /* End of SystemInitialize for SubSystem: '<S5>/SrcDownAnn' */

        /* End of SystemInitialize for SubSystem: '<Root>/NEAR' */

        /* SystemInitialize for Atomic SubSystem: '<Root>/PostProcess' */

        /* SystemInitialize for Atomic SubSystem: '<S7>/PostProcess' */
        Model_Target_PostProcess_Init();

        /* End of SystemInitialize for SubSystem: '<S7>/PostProcess' */

        /* End of SystemInitialize for SubSystem: '<Root>/PostProcess' */
    }
}

/* Model terminate function */
void Model_Target_terminate(void)
{
    /* Terminate for Atomic SubSystem: '<S4>/SrcUp' */
    Model_Target_SrcUp_Term();

    /* End of Terminate for SubSystem: '<S4>/SrcUp' */

    /* Terminate for Atomic SubSystem: '<S4>/SrcDownEnt' */
    Model_Target_SrcDownEnt_Term();

    /* End of Terminate for SubSystem: '<S4>/SrcDownEnt' */

    /* Terminate for Atomic SubSystem: '<S4>/SrcDownMic' */
    Model_Target_SrcDownMic_Term();

    /* End of Terminate for SubSystem: '<S4>/SrcDownMic' */

    /* Terminate for Atomic SubSystem: '<Root>/NEAR' */
    /* Terminate for Atomic SubSystem: '<S5>/SrcDownAnn' */
    Model_Target_SrcDownAnn_Term();

    /* End of Terminate for SubSystem: '<S5>/SrcDownAnn' */
    /* End of Terminate for SubSystem: '<Root>/NEAR' */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
