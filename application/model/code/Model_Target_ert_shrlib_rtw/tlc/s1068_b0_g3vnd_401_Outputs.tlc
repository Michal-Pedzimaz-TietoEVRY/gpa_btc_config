%implements s1068_b0_g3vnd_401_Outputs "C"

%function Outputs(block, system) Output
%assign cfgTxt = ""
%openfile cfgTxt
%assign localVarDecl = ""
%openfile localVarDecl

real32_T currentGainLinear_idx_0;
real32_T currentGainLinear_idx_1;
real32_T currentGainLinear_idx_2;
real32_T currentGainLinear_idx_3;
real32_T diff_idx_0;
real32_T diff_idx_1;
real32_T diff_idx_2;
real32_T diff_idx_3;
real32_T quantumMs;
real32_T targetGainLinear;
real32_T targetGainLinear_0;
real32_T targetGainLinear_1;
real32_T targetGainLinear_2;
%closefile localVarDecl
%assign _modelSS = ""

%if !SLibCGSysFcnIsEmptyForTid(CompiledModel.System[560], "Output",2)
/* {S!d3227}MATLAB Function: '<S1432>/calculate_SB_gains' */
/* {S!d3238}MATLAB Function: '<S1432>/calculate_SB_gains' */
/*  Invoke the function trigger output */
/* MATLAB Function 'RTC/REQ': '<S1449>:1' */
/* '<S1449>:1:3' go(); */
%if SLibCG_SystemFcnArgAccessed("Model_Target_calculate_SB_gains",560,0)
%assign _modelSS = RTMGetModelSSFromIR()
%endif

%<SLibCG_DumpSSCode("/*@[14617b0*/",SLibCGIRGenReusableSysCall("Model_Target_calculate_SB_gains", ["%<_modelSS>", "%<SLibCG_DumpSSCode("/*@[1462196*/",(SLibCG_BOCSC(77, 1, "", -1, "", 0)),"/*@]*/")>", "%<SLibCG_DumpSSCode("/*@[14621a8*/",(SLibCG_BOCSCAddr(280, 30, "", -1, "", 0)),"/*@]*/")>", "%<SLibCG_DumpSSCode("/*@[14621ba*/",(SLibCG_BOCSCAddr(281, 30, "", -1, "", 0)),"/*@]*/")>", "%<SLibCG_DumpSSCode("/*@[14621cc*/",(SLibCG_BOCSC(282, 1, "", -1, "", 0)),"/*@]*/")>", "%<SLibCG_DumpSSCode("/*@[14621de*/",(SLibCG_BOCSC(283, 1, "", -1, "", 0)),"/*@]*/")>", "&/*@>14621f2*/Model_Target_B./*@>14621f1*/sf_calculate_SB_gains"], 560, 0, 6, 2, 6, 957),"/*@]*/")>\
%assign ss = ::CompiledModel.System[560]
%if !LibSystemIsInlined(ss)
;
%else
\
%endif
%endif
%if !SLibCGSysFcnIsEmptyForTid(CompiledModel.System[561], "Output",2)

/* {S!d3229}MATLAB Function: '<S1432>/calculate_ramp_parameters' */
/* {S!d3240}MATLAB Function: '<S1432>/calculate_ramp_parameters' */
%if SLibCG_SystemFcnArgAccessed("Model_Target_calculate_ramp_parameters",561,0)
%assign _modelSS = RTMGetModelSSFromIR()
%endif

%<SLibCG_DumpSSCode("/*@[14617b1*/",SLibCGIRGenReusableSysCall("Model_Target_calculate_ramp_parameters", ["%<_modelSS>", "%<SLibCG_DumpSSCode("/*@[1462240*/",(SLibCG_BOCSC(279, 1, "", -1, "", 0)),"/*@]*/")>", "%<SLibCG_DumpSSCode("/*@[1462252*/",(SLibCG_BOCSC(78, 1, "", -1, "", 0)),"/*@]*/")>", "%<SLibCG_DumpSSCode("/*@[1462264*/",(SLibCG_BOCSC(79, 1, "", -1, "", 0)),"/*@]*/")>", "&/*@>1462278*/Model_Target_B./*@>1462277*/sf_calculate_ramp_parameters_b"], 561, 0, 6, 2, 6, 957),"/*@]*/")>\
%assign ss = ::CompiledModel.System[561]
%if !LibSystemIsInlined(ss)
;
%else
\
%endif
%endif
%if !SLibCGSysFcnIsEmptyForTid(CompiledModel.System[562], "Output",2)

/* {S!d3231}Outputs for Function Call SubSystem: '<S1432>/SetDsm' */
%if SLibCG_SystemFcnArgAccessed("Model_Target_SetDsm_h",562,0)
%assign _modelSS = RTMGetModelSSFromIR()
%endif

%<SLibCG_DumpSSCode("/*@[14617b2*/",SLibCGIRGenReusableSysCall("Model_Target_SetDsm_h", ["%<_modelSS>", "/*@>14622a5*/1U"], 562, 0, 6, 2, 6, 957),"/*@]*/")>\
%assign ss = ::CompiledModel.System[562]
%if !LibSystemIsInlined(ss)
;
%else
\
%endif

/* {E!d3231}End of Outputs for SubSystem: '<S1432>/SetDsm' */

%endif
/* {S!d3233}MATLAB Function: '<S1432>/control' */
/* {S!d3242}MATLAB Function: '<S1432>/control' incorporates:
 *  S-Function (AudioStats_MEX): '<S1432>/Audio Stats'
 */
/*  %<"\% inputs"> */
/*  parameters */
/* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/SleepingBeauty/SleepingBeauty/Enabled/SleepingBeautyDR/InnerLink/control': '<S1444>:1' */
/*  CONTROL LOGIC: */
/*  Shift of 'balance' between the 'Right' and 'Left' channel groups is */
/*  achieved by multiplying the corresponding 'cut' or 'boost' gain. As the */
/*  index increases from 0, the balance shifts from left to right. */
/*  rampdbPerSec takes precidence: */
/*    If dbPerSec has a non-zero value then any ramp_times_ms values are */
/*    ignored and the dbPerSec is used to determine ramper timing. */
/*  Inputs: */
/*    targetGainLinear: Indicates the gain (in linear scale) which needs to */
/*        be applied to the audio. Gain values can be mapped to the ramper */
/*        configuration. */
/*    rampTimeMs: Indicates the time in milliseconds in which the gain of the */
/*        rampers must change from their current to target values. */
/*    rampdbPerSecond: Indicates the rate in dB/second at which the gain of the */
/*        rampers must change from their current to target values. If this */
/*        value is non-zero, it is used to compute the ramp time and */
/*        'rampTimeMs' is discarded (if specified). */
/*    rgain_SILENT_GAIN: Parameter defined in the initFcn callback. */
/*  Control Data: */
/*    Freeze(1) freezes the processing during this control operation */
/*    Rampers(1) is the ramper for the left speaker */
/*    Rampers(2) is the ramper for the right speaker */
/*    Rampers(3) is the ramper for the center speaker */
/*    Rampers(4) is the ramper for the mono speaker */
/* '<S1444>:1:34' rgain_SILENT_GAIN = RgainBusUtil.GetSilentGainLinear(); */
/*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
/*  on the current gain value. This step now done externally on canvas */
/*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
/*  When this control set goes live, ensure that the current gain will move. */
/*  If current gain is zero, replace with a value very close to zero. What we */
/*  really want is a value which is on the edge of perception - not too small */
/*  or large. If the value is too small, we'll waste some of our ramp time */
/*  in perceived silence. If the value is too large, the audio will lurch */
/*  into perceptability at the start of the ramp. */
/*  UPDATE: This will now loop over 4 rampers */
/* '<S1444>:1:48' currentGainLinear = zeros(1,MaskNumRampers,'single'); */
/* '<S1444>:1:49' for i = 1:MaskNumRampers */
/* '<S1444>:1:50' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
/*@>145d6bc*/currentGainLinear_idx_0/*@>145ccb7*/ = /*@>1460320*/fmaxf(%<SLibCG_DumpSSCode("/*@[14617e5*/",(SLibCG_CSCDW(6, 1, "[/*@>14617be*/0].currentGain", -1, "", 0)),"/*@]*/")>, /*@>145d61e*/5.0118723E-7F);
/* '<S1444>:1:51' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
targetGainLinear/*@>145ccc8*/ = /*@>1460322*/fmaxf(/*@>1460e7e*/Model_Target_B./*@>14620de*/sf_calculate_SB_gains./*@>14620db*/targetGainsSB/*@>1460b28*/[/*@>1460b25*/0], /*@>145d624*/5.0118723E-7F);
/* '<S1444>:1:50' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
/*@>145d6c2*/currentGainLinear_idx_1/*@>145cce6*/ = /*@>1460324*/fmaxf(%<SLibCG_DumpSSCode("/*@[1461818*/",(SLibCG_CSCDW(6, 1, "[/*@>14617f1*/1].currentGain", -1, "", 0)),"/*@]*/")>, /*@>145d62e*/5.0118723E-7F);
/* '<S1444>:1:51' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
targetGainLinear_0/*@>145ccf7*/ = /*@>1460326*/fmaxf(/*@>1460e89*/Model_Target_B./*@>14620e4*/sf_calculate_SB_gains./*@>14620e1*/targetGainsSB/*@>1460b32*/[/*@>1460b2f*/1], /*@>145d634*/5.0118723E-7F);
/* '<S1444>:1:50' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
/*@>145d6c8*/currentGainLinear_idx_2/*@>145cd15*/ = /*@>1460328*/fmaxf(%<SLibCG_DumpSSCode("/*@[146184b*/",(SLibCG_CSCDW(6, 1, "[/*@>1461824*/2].currentGain", -1, "", 0)),"/*@]*/")>, /*@>145d63e*/5.0118723E-7F);
/* '<S1444>:1:51' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
targetGainLinear_1/*@>145cd26*/ = /*@>146032a*/fmaxf(/*@>1460e94*/Model_Target_B./*@>14620ea*/sf_calculate_SB_gains./*@>14620e7*/targetGainsSB/*@>1460b3c*/[/*@>1460b39*/2], /*@>145d644*/5.0118723E-7F);
/* '<S1444>:1:50' currentGainLinear(i) = max(Rampers(i).currentGain, rgain_SILENT_GAIN); */
/*@>145d6ce*/currentGainLinear_idx_3/*@>145cd44*/ = /*@>146032c*/fmaxf(%<SLibCG_DumpSSCode("/*@[146187e*/",(SLibCG_CSCDW(6, 1, "[/*@>1461857*/3].currentGain", -1, "", 0)),"/*@]*/")>, /*@>145d64e*/5.0118723E-7F);
/* '<S1444>:1:51' targetGainLinear(i) = max(targetGainLinear(i), rgain_SILENT_GAIN); */
targetGainLinear_2/*@>145cd55*/ = /*@>146032e*/fmaxf(/*@>1460e9f*/Model_Target_B./*@>14620f0*/sf_calculate_SB_gains./*@>14620ed*/targetGainsSB/*@>1460b46*/[/*@>1460b43*/3], /*@>145d654*/5.0118723E-7F);
/*  Step 3a: If a slope in dB/second is provided, ignore the ramp time */
/*  and instead calculate a new ramp time that matches the slope. */
/* '<S1444>:1:56' rampMs = zeros(1,MaskNumRampers,'single'); */
/* '<S1444>:1:57' if (rampdbPerSec) */
/*@>10cbf56*/if (/*@>1460eaa*/Model_Target_B./*@>14620f6*/sf_calculate_ramp_parameters_b./*@>14620f3*/rampRate/*@>10cbf29*/ != /*@>145d43a*/0.0F) {
    /* '<S1444>:1:58' currentGainDb = 20*log10(currentGainLinear); */
    /* '<S1444>:1:59' targetGainDb = 20*log10(targetGainLinear); */
    /* '<S1444>:1:60' diff = abs(currentGainDb - targetGainDb); */
    /* '<S1444>:1:61' rampMs = diff / single(rampdbPerSec) * 1000; */
    /*@>145d68c*/diff_idx_0 = /*@>1460336*/qhmath_div_f(/*@>1460334*/qhmath_abs_f(/*@>145e984*/20.0F/*@>145e983*/ * /*@>1460330*/qhmath_log10_f(/*@>145e988*/currentGainLinear_idx_0)/*@>145e982*/ - /*@>145e98a*/20.0F/*@>145e989*/ * /*@>1460332*/qhmath_log10_f(targetGainLinear)), /*@>1460ed6*/Model_Target_B./*@>146210e*/sf_calculate_ramp_parameters_b./*@>146210b*/rampRate)/*@>145e5fc*/ * /*@>145e603*/1000.0F;
    /*@>145d690*/diff_idx_1 = /*@>146033e*/qhmath_div_f(/*@>146033c*/qhmath_abs_f(/*@>145e994*/20.0F/*@>145e993*/ * /*@>1460338*/qhmath_log10_f(/*@>145e998*/currentGainLinear_idx_1)/*@>145e992*/ - /*@>145e99a*/20.0F/*@>145e999*/ * /*@>146033a*/qhmath_log10_f(targetGainLinear_0)), /*@>1460eec*/Model_Target_B./*@>146211a*/sf_calculate_ramp_parameters_b./*@>1462117*/rampRate)/*@>145e605*/ * /*@>145e60c*/1000.0F;
    /*@>145d694*/diff_idx_2 = /*@>1460346*/qhmath_div_f(/*@>1460344*/qhmath_abs_f(/*@>145e9a2*/20.0F/*@>145e9a1*/ * /*@>1460340*/qhmath_log10_f(/*@>145e9a6*/currentGainLinear_idx_2)/*@>145e9a0*/ - /*@>145e9a8*/20.0F/*@>145e9a7*/ * /*@>1460342*/qhmath_log10_f(targetGainLinear_1)), /*@>1460ef7*/Model_Target_B./*@>1462120*/sf_calculate_ramp_parameters_b./*@>146211d*/rampRate)/*@>145e60e*/ * /*@>145e615*/1000.0F;
    /*@>145d698*/diff_idx_3 = /*@>146034e*/qhmath_div_f(/*@>146034c*/qhmath_abs_f(/*@>145e818*/20.0F/*@>145e817*/ * /*@>1460348*/qhmath_log10_f(/*@>145e9b1*/currentGainLinear_idx_3)/*@>145e816*/ - /*@>145e81c*/20.0F/*@>145e81b*/ * /*@>146034a*/qhmath_log10_f(targetGainLinear_2)), /*@>1460f02*/Model_Target_B./*@>1462126*/sf_calculate_ramp_parameters_b./*@>1462123*/rampRate)/*@>145e61b*/ * /*@>145e622*/1000.0F;
} else {
    /* '<S1444>:1:62' else */
    /* '<S1444>:1:63' rampMs(:) = single(rampTimesMs); */
    /*@>145d6b2*/diff_idx_0/*@>145cc81*/ = /*@>1460eb5*/Model_Target_B./*@>14620fc*/sf_calculate_ramp_parameters_b./*@>14620f9*/ramptime;
    /*@>145d6b4*/diff_idx_1/*@>145cc8b*/ = /*@>1460ec0*/Model_Target_B./*@>1462102*/sf_calculate_ramp_parameters_b./*@>14620ff*/ramptime;
    /*@>145d6b6*/diff_idx_2/*@>145cc95*/ = /*@>1460ecb*/Model_Target_B./*@>1462108*/sf_calculate_ramp_parameters_b./*@>1462105*/ramptime;
    /*@>145d6b8*/diff_idx_3/*@>145cc9f*/ = /*@>1460ee1*/Model_Target_B./*@>1462114*/sf_calculate_ramp_parameters_b./*@>1462111*/ramptime;
}
/*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
/*  the whole number of frames required to best match requested ramp time. */
/*  Ensure that at least one frame is used. The frame size will therefore */
/*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
/* '<S1444>:1:70' quantumMs = 1000 * frameSize / sampleRateInHertz; */
/*@>145d43b*/quantumMs/*@>10cbfae*/ = /*@>1460350*/qhmath_div_f(/*@>145d443*/1000.0F/*@>145d877*/ * %<SLibCG_DumpSSCode("/*@[14618c2*/",(SLibCG_SE(SLibCG_Expr(578, 66, 1, 1, "", -1, "", 0))),"/*@]*/")>, %<SLibCG_DumpSSCode("/*@[14618a0*/",(SLibCG_Expr(578, 66, 0, 1, "", -1, "", 0)),"/*@]*/")>);
/* '<S1444>:1:71' numFrames = rampMs / quantumMs; */
/* '<S1444>:1:72' numFrames = max (1, ceil(numFrames)); */
/* '<S1444>:1:73' quantizedRampTimeMs = numFrames * quantumMs; */
/*  UPDATE: Loop over 4 rampers now (L, R, C, and Mono) */
/* '<S1444>:1:76' for ramper=1:MaskNumRampers */
diff_idx_0/*@>145c8e5*/ = /*@>1460356*/fmaxf(/*@>145d478*/1.0F, /*@>1460354*/qhmath_ceil_f(/*@>1460352*/qhmath_div_f(/*@>145e825*/diff_idx_0, /*@>145e827*/quantumMs)));
/*  In order to have the desired ramp time, the slope must vary dependent */
/*  on the gain differencebetween target and current value. */
/*  Ramper's coefficient is therefore calculated as follows: */
/*  */
/*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
/*  */
/*  therefore... */
/*  */
/*                      log(TargetGain/CurrentGain) */
/*    log(RampCoef) = ------------------------------ */
/*                         Fs*(RampTime_ms/1000) */
/*  */
/* '<S1444>:1:89' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
/* '<S1444>:1:90' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
/*  Output control signals */
/* '<S1444>:1:93' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
/*@>145eeda*/if (diff_idx_0/*@>145e638*/ < /*@>145e63b*/2.14748365E+9F) {
%<SLibCG_DumpSSCode("/*@[1461cb3*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461c8a*/0].frameCount", -1, "", 0, "/*@>14622b7*/(int32_T)diff_idx_0"),"/*@]*/")>\
} else {
%<SLibCG_DumpSSCode("/*@[14618f8*/",SLibCG_SetCSCDW(6, 1, "[/*@>14618ce*/0].frameCount", -1, "", 0, "MAX_int32_T"),"/*@]*/")>\
}
/* '<S1444>:1:94' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[146192b*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461902*/0].targetGain", -1, "", 0, "targetGainLinear"),"/*@]*/")>\
/* '<S1444>:1:95' Rampers(ramper).rampCoeff = single(RampCoef); */
%<SLibCG_DumpSSCode("/*@[1461980*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461957*/0].rampCoeff", -1, "", 0, "/*@>14622ee*/qhmath_exp_f(/*@>14622f0*/qhmath_div_f(/*@>14622f2*/qhmath_log_f(/*@>14622f4*/qhmath_div_f(targetGainLinear, /*@>14622f6*/currentGainLinear_idx_0)), /*@>14622f8*/qhmath_div_f(diff_idx_0/*@>14622fa*/ * /*@>14622fc*/quantumMs/*@>14622f9*/ * %<SLibCG_DumpSSCode("/*@[14622fd*/",(SLibCG_SE(SLibCG_Expr(578, 66, 0, 1, "", -1, "", 0))),"/*@]*/")>, /*@>146230a*/1000.0F)))"),"/*@]*/")>\
/* '<S1444>:1:96' Rampers(ramper).currentGain = currentGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[14619b3*/",SLibCG_SetCSCDW(6, 1, "[/*@>146198a*/0].currentGain", -1, "", 0, "/*@>146231c*/currentGainLinear_idx_0"),"/*@]*/")>\
diff_idx_0/*@>145c978*/ = /*@>1460366*/fmaxf(/*@>145d4b8*/1.0F, /*@>1460364*/qhmath_ceil_f(/*@>1460362*/qhmath_div_f(/*@>145e83a*/diff_idx_1, /*@>145e83c*/quantumMs)));
/*  In order to have the desired ramp time, the slope must vary dependent */
/*  on the gain differencebetween target and current value. */
/*  Ramper's coefficient is therefore calculated as follows: */
/*  */
/*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
/*  */
/*  therefore... */
/*  */
/*                      log(TargetGain/CurrentGain) */
/*    log(RampCoef) = ------------------------------ */
/*                         Fs*(RampTime_ms/1000) */
/*  */
/* '<S1444>:1:89' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
/* '<S1444>:1:90' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
/*  Output control signals */
/* '<S1444>:1:93' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
/*@>145eee3*/if (diff_idx_0/*@>145e65e*/ < /*@>145e661*/2.14748365E+9F) {
%<SLibCG_DumpSSCode("/*@[1461ce6*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461cbd*/1].frameCount", -1, "", 0, "/*@>146232e*/(int32_T)diff_idx_0"),"/*@]*/")>\
} else {
%<SLibCG_DumpSSCode("/*@[14619e7*/",SLibCG_SetCSCDW(6, 1, "[/*@>14619bd*/1].frameCount", -1, "", 0, "MAX_int32_T"),"/*@]*/")>\
}
/* '<S1444>:1:94' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[1461a1a*/",SLibCG_SetCSCDW(6, 1, "[/*@>14619f1*/1].targetGain", -1, "", 0, "targetGainLinear_0"),"/*@]*/")>\
/* '<S1444>:1:95' Rampers(ramper).rampCoeff = single(RampCoef); */
%<SLibCG_DumpSSCode("/*@[1461a6f*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461a46*/1].rampCoeff", -1, "", 0, "/*@>1462365*/qhmath_exp_f(/*@>1462367*/qhmath_div_f(/*@>1462369*/qhmath_log_f(/*@>146236b*/qhmath_div_f(targetGainLinear_0, /*@>146236d*/currentGainLinear_idx_1)), /*@>146236f*/qhmath_div_f(diff_idx_0/*@>1462371*/ * /*@>1462373*/quantumMs/*@>1462370*/ * %<SLibCG_DumpSSCode("/*@[1462374*/",(SLibCG_SE(SLibCG_Expr(578, 66, 0, 1, "", -1, "", 0))),"/*@]*/")>, /*@>1462381*/1000.0F)))"),"/*@]*/")>\
/* '<S1444>:1:96' Rampers(ramper).currentGain = currentGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[1461aa2*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461a79*/1].currentGain", -1, "", 0, "/*@>1462393*/currentGainLinear_idx_1"),"/*@]*/")>\
diff_idx_0/*@>145ca0b*/ = /*@>1460376*/fmaxf(/*@>145d4f8*/1.0F, /*@>1460374*/qhmath_ceil_f(/*@>1460372*/qhmath_div_f(/*@>145e84f*/diff_idx_2, /*@>145e851*/quantumMs)));
/*  In order to have the desired ramp time, the slope must vary dependent */
/*  on the gain differencebetween target and current value. */
/*  Ramper's coefficient is therefore calculated as follows: */
/*  */
/*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
/*  */
/*  therefore... */
/*  */
/*                      log(TargetGain/CurrentGain) */
/*    log(RampCoef) = ------------------------------ */
/*                         Fs*(RampTime_ms/1000) */
/*  */
/* '<S1444>:1:89' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
/* '<S1444>:1:90' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
/*  Output control signals */
/* '<S1444>:1:93' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
/*@>145eeec*/if (diff_idx_0/*@>145e684*/ < /*@>145e687*/2.14748365E+9F) {
%<SLibCG_DumpSSCode("/*@[1461d19*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461cf0*/2].frameCount", -1, "", 0, "/*@>14623a5*/(int32_T)diff_idx_0"),"/*@]*/")>\
} else {
%<SLibCG_DumpSSCode("/*@[1461ad6*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461aac*/2].frameCount", -1, "", 0, "MAX_int32_T"),"/*@]*/")>\
}
/* '<S1444>:1:94' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[1461b09*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461ae0*/2].targetGain", -1, "", 0, "targetGainLinear_1"),"/*@]*/")>\
/* '<S1444>:1:95' Rampers(ramper).rampCoeff = single(RampCoef); */
%<SLibCG_DumpSSCode("/*@[1461b5e*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461b35*/2].rampCoeff", -1, "", 0, "/*@>14623dc*/qhmath_exp_f(/*@>14623de*/qhmath_div_f(/*@>14623e0*/qhmath_log_f(/*@>14623e2*/qhmath_div_f(targetGainLinear_1, /*@>14623e4*/currentGainLinear_idx_2)), /*@>14623e6*/qhmath_div_f(diff_idx_0/*@>14623e8*/ * /*@>14623ea*/quantumMs/*@>14623e7*/ * %<SLibCG_DumpSSCode("/*@[14623eb*/",(SLibCG_SE(SLibCG_Expr(578, 66, 0, 1, "", -1, "", 0))),"/*@]*/")>, /*@>14623f8*/1000.0F)))"),"/*@]*/")>\
/* '<S1444>:1:96' Rampers(ramper).currentGain = currentGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[1461b91*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461b68*/2].currentGain", -1, "", 0, "/*@>146240a*/currentGainLinear_idx_2"),"/*@]*/")>\
diff_idx_0/*@>145ca9e*/ = /*@>1460386*/fmaxf(/*@>145d538*/1.0F, /*@>1460384*/qhmath_ceil_f(/*@>1460382*/qhmath_div_f(/*@>145e864*/diff_idx_3, /*@>145e866*/quantumMs)));
/*  In order to have the desired ramp time, the slope must vary dependent */
/*  on the gain differencebetween target and current value. */
/*  Ramper's coefficient is therefore calculated as follows: */
/*  */
/*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
/*  */
/*  therefore... */
/*  */
/*                      log(TargetGain/CurrentGain) */
/*    log(RampCoef) = ------------------------------ */
/*                         Fs*(RampTime_ms/1000) */
/*  */
/* '<S1444>:1:89' factor = log( targetGainLinear(ramper) / currentGainLinear(ramper) ); */
/* '<S1444>:1:90' RampCoef = double(exp(factor / (sampleRateInHertz * quantizedRampTimeMs(ramper) / 1000))); */
/*  Output control signals */
/* '<S1444>:1:93' Rampers(ramper).frameCount  = int32(numFrames(ramper)); */
/*@>145eef5*/if (diff_idx_0/*@>145e6aa*/ < /*@>145e6ad*/2.14748365E+9F) {
%<SLibCG_DumpSSCode("/*@[1461d4c*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461d23*/3].frameCount", -1, "", 0, "/*@>146241c*/(int32_T)diff_idx_0"),"/*@]*/")>\
} else {
%<SLibCG_DumpSSCode("/*@[1461bc5*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461b9b*/3].frameCount", -1, "", 0, "MAX_int32_T"),"/*@]*/")>\
}
/* '<S1444>:1:94' Rampers(ramper).targetGain  = targetGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[1461bf8*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461bcf*/3].targetGain", -1, "", 0, "targetGainLinear_2"),"/*@]*/")>\
/* '<S1444>:1:95' Rampers(ramper).rampCoeff = single(RampCoef); */
%<SLibCG_DumpSSCode("/*@[1461c4d*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461c24*/3].rampCoeff", -1, "", 0, "/*@>1462453*/qhmath_exp_f(/*@>1462455*/qhmath_div_f(/*@>1462457*/qhmath_log_f(/*@>1462459*/qhmath_div_f(targetGainLinear_2, /*@>146245b*/currentGainLinear_idx_3)), /*@>146245d*/qhmath_div_f(diff_idx_0/*@>146245f*/ * /*@>1462461*/quantumMs/*@>146245e*/ * %<SLibCG_DumpSSCode("/*@[1462462*/",(SLibCG_SE(SLibCG_Expr(578, 66, 0, 1, "", -1, "", 0))),"/*@]*/")>, /*@>146246f*/1000.0F)))"),"/*@]*/")>\
/* '<S1444>:1:96' Rampers(ramper).currentGain = currentGainLinear(ramper); */
%<SLibCG_DumpSSCode("/*@[1461c80*/",SLibCG_SetCSCDW(6, 1, "[/*@>1461c57*/3].currentGain", -1, "", 0, "/*@>1462481*/currentGainLinear_idx_3"),"/*@]*/")>\
/* {E!d3242}End of MATLAB Function: '<S1432>/control' */

/* {S!d3235}Outputs for Function Call SubSystem: '<S1432>/SetDsm1' */
/*  unfreeze the gain. This step now done externally on canvas */
%if !SLibCGSysFcnIsEmptyForTid(CompiledModel.System[562], "Output",2)
%if SLibCG_SystemFcnArgAccessed("Model_Target_SetDsm_h",562,0)
%assign _modelSS = RTMGetModelSSFromIR()
%endif

%<SLibCG_DumpSSCode("/*@[14617b3*/",SLibCGIRGenReusableSysCall("Model_Target_SetDsm_h", ["%<_modelSS>", "/*@>14624ad*/0U"], 562, 1, 6, 2, 6, 957),"/*@]*/")>\
%assign ss = ::CompiledModel.System[562]
%if !LibSystemIsInlined(ss)
;
%else
\
%endif

/* {E!d3235}End of Outputs for SubSystem: '<S1432>/SetDsm1' */
%endif
%closefile cfgTxt
%<cfgTxt>
%<LibSetSystemField(system, "CachedOutputLocalVars", localVarDecl)>
%endfunction
%function OutputsFcnProtoType(block, system) Output
%assign fcnProtoType = ""
%openfile fcnProtoType
static void HandleReqPreAmpSleepingBeautyDRSet(\
%assign comma = ""
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(401, 0, fcnProtoType)>
%endfunction
