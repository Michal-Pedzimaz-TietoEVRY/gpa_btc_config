%implements s1068_b0_g3vnd_44_Outputs "C"

%function Outputs(block, system) Output
%assign cfgTxt = ""
%openfile cfgTxt
%assign localVarDecl = ""
%openfile localVarDecl

int32_T k;
real32_T currentgain[12];
real32_T diff[12];
%closefile localVarDecl
/* MATLAB Function 'ModelPreAmp/DecRate/Medusa5H1/MedusaHoligram/Medusa5H1 Part 3/On/VLS Gains Computation/VLS Gains Drv/Gain Computation/Ramper/control': '<S1147>:1' */
/* '<S1147>:1:10' dim_rgain = size(VLSDrv_currentGain); */
/* '<S1147>:1:11' rgain_SILENT_GAIN_mat = (configStruct.rgain_SILENT_GAIN)*ones(dim_rgain); */
/*  Step 1: FREEZE the gain ramper so that we can perform calculations based */
/*  on the current gain value. */
/* '<S1147>:1:15' VLSDrv_Freeze(1) = true; */
/*  freeze the gain */
/*  Step 2: Nudge the gain values a bit if they are sitting at zero. */
/*  When this control set goes live, ensure that the current gain will move. */
/*  If current gain is zero, replace with a value very close to zero. What we */
/*  really want is a value which is on the edge of perception - not too small */
/*  or large. If the value is too small, we'll waste some of our ramp time */
/*  in perceived silence. If the value is too large, the audio will lurch */
/*  into perceptability at the start of the ramp. */
/* '<S1147>:1:24' currentgain = max(VLSDrv_currentGain, rgain_SILENT_GAIN_mat); */
/* '<S1147>:1:25' targetGain  = max(target_gains_linear, rgain_SILENT_GAIN_mat); */
/*  Step 3a: If a ramp time in milliseconds is provided, ignore the ramp */
/*  rate in dB/sec (if also provided), otherwise calculate a new ramp time */
/*  that matches the slope. */
/* '<S1147>:1:30' rampTime_ms = single(rampTime)*ones(dim_rgain); */
/*@>10bf912*/for (/*@>11d5abe*/k = /*@>11d5abd*/0; /*@>11d5ac8*/k < /*@>11d5ac6*/12; /*@>11d5ac4*/k/*@>11d5acc*/++) {
    /*@>11d3f59*/currentgain/*@>11d3169*/[/*@>11d3f5b*/k]/*@>10bf919*/ = /*@>11d525e*/fmaxf(/*@>11d55bd*/rtd_VLSDrv_currentGain/*@>11d55bf*/[/*@>11d55bb*/k], /*@>11d3f33*/1.1920929E-7F);
    /*@>11d3f61*/rtd_VLSDrv_rampCoeff/*@>11d31a5*/[/*@>11d3f63*/k]/*@>10bf925*/ = /*@>11d5260*/fmaxf(/*@>11d55c4*/rtu_target_gains_linear/*@>11d55c6*/[/*@>11d55c2*/k], /*@>11d3f34*/1.1920929E-7F);
    /*@>11d3f4d*/diff/*@>11d2cbe*/[/*@>11d3f44*/k]/*@>11d2cbd*/ = /*@>11d2cc4*/(real32_T)/*@>11d3f46*/rtu_rampTime;
}
/* '<S1147>:1:32' if(~rampTime) */
/*@>10bf8c4*/if (/*@>11d3f40*/rtu_rampTime/*@>10bf8f1*/ == /*@>11d3f27*/0U) {
    /* '<S1147>:1:33' currentGain_db = 20*log10(currentgain); */
    /* '<S1147>:1:34' targetGain_db = 20*log10(targetGain); */
    /* '<S1147>:1:35' diff = abs(currentGain_db - targetGain_db); */
    /* '<S1147>:1:36' rampTime_ms = diff / single(rampRate) * 1000; */
/*@>11d2ce4*/    for (/*@>11d5aad*/k = /*@>11d5aac*/0; /*@>11d5ab7*/k < /*@>11d5ab5*/12; /*@>11d5ab3*/k/*@>11d5acd*/++) {
        /*@>11d3fb8*/diff/*@>11d397a*/[/*@>11d3fba*/k] = /*@>11d5268*/qhmath_div_f(/*@>11d5266*/qhmath_abs_f(/*@>11d4446*/20.0F/*@>11d4445*/ * /*@>11d5262*/qhmath_log10_f(/*@>11d55ca*/currentgain/*@>11d55cc*/[/*@>11d55c9*/k])/*@>11d4444*/ - /*@>11d444a*/20.0F/*@>11d4449*/ * /*@>11d5264*/qhmath_log10_f(/*@>11d55d1*/rtd_VLSDrv_rampCoeff/*@>11d55d3*/[/*@>11d55cf*/k])), /*@>11d43be*/(real32_T)/*@>11d43c0*/rtu_rampRate)/*@>11d43b9*/ * /*@>11d43c1*/1000.0F;
    }
}
/*  Step 3b: QUANTIZE the desired ramp time to our FrameSize. Also retrieve  */
/*  the whole number of frames required to best match requested ramp time. */
/*  Ensure that at least one frame is used. The frame size will therefore */
/*  determine the steepest ramp (i.e. within one frame you can go anywhere). */
/* '<S1147>:1:43' quantum_ms = 1000 * (configStruct.frame_size) / (configStruct.sample_rate_in_hertz); */
/* '<S1147>:1:44' numFrames = rampTime_ms / quantum_ms; */
/* '<S1147>:1:45' numFrames = max (1, round(numFrames)); */
/*  In order to have the desired ramp time, the slope must vary dependent */
/*  on the gain differencebetween target and current value. */
/*  Ramper's coefficient is therefore calculated as follows: */
/*  */
/*    TargetGain = CurrentGain *( RampCoef ^ (Fs*RampTime_ms/1000) ) */
/*  */
/*  therefore... */
/*  */
/*                      log(TargetGain/CurrentGain) */
/*    log(RampCoef) = ------------------------------ */
/*                         Fs*(RampTime_ms/1000) */
/*  */
/* '<S1147>:1:59' factor = log( targetGain ./ currentgain ); */
/* '<S1147>:1:60' RampCoef = exp(factor ./ numFrames); */
/*  Output control signals */
/* '<S1147>:1:63' VLSDrv_frameCount  = int32(numFrames); */
/* '<S1147>:1:64' VLSDrv_rampCoeff   = single(RampCoef); */
/* '<S1147>:1:65' VLSDrv_targetGain  = target_gains_linear; */
/* '<S1147>:1:66' VLSDrv_currentGain = currentgain; */
/*@>11d3257*/for (/*@>11d5a9c*/k = /*@>11d5a9b*/0; /*@>11d5aa6*/k < /*@>11d5aa4*/12; /*@>11d5aa2*/k/*@>11d5ace*/++) {
    real32_T currentgain_0;
    real32_T diff_0;
    real32_T numFrames;
    currentgain_0 = /*@>11d55d7*/currentgain/*@>11d55d9*/[/*@>11d55d6*/k];
    diff_0/*@>10bf952*/ = /*@>11d526c*/roundf(/*@>11d526a*/qhmath_div_f(/*@>11d55dd*/diff/*@>11d55df*/[/*@>11d55dc*/k], /*@>11d43cd*/0.722222209F));
    numFrames/*@>10bf95e*/ = /*@>11d526e*/fmaxf(/*@>11d3f32*/1.0F, diff_0);
    /*@>11d3f78*/rtd_VLSDrv_rampCoeff/*@>11d343a*/[/*@>11d3f76*/k]/*@>11d343b*/ = /*@>11d5270*/qhmath_div_f(/*@>11d55e4*/rtd_VLSDrv_rampCoeff/*@>11d55e6*/[/*@>11d55e2*/k], currentgain_0);
    /*@>11d3f7e*/rtd_VLSDrv_rampCoeff/*@>11d3482*/[/*@>11d3f80*/k]/*@>10bf967*/ = /*@>11d5272*/qhmath_log_f(/*@>11d55eb*/rtd_VLSDrv_rampCoeff/*@>11d55ed*/[/*@>11d55e9*/k]);
    /*@>11d3f88*/rtd_VLSDrv_rampCoeff/*@>11d34ca*/[/*@>11d3f86*/k]/*@>11d34cb*/ = /*@>11d5274*/qhmath_div_f(/*@>11d55f2*/rtd_VLSDrv_rampCoeff/*@>11d55f4*/[/*@>11d55f0*/k], numFrames);
    /*@>11d3f8e*/rtd_VLSDrv_rampCoeff/*@>11d3512*/[/*@>11d3f90*/k]/*@>10bf970*/ = /*@>11d5276*/qhmath_exp_f(/*@>11d55f9*/rtd_VLSDrv_rampCoeff/*@>11d55fb*/[/*@>11d55f7*/k]);
    /*@>11d3f92*/rtd_VLSDrv_frameCount/*@>11d354c*/[/*@>11d3f94*/k]/*@>11d2c64*/ = /*@>11d400b*/(int32_T)numFrames;
    /*@>11d3f9a*/rtd_VLSDrv_targetGain/*@>11d3589*/[/*@>11d3f9c*/k]/*@>11d2c82*/ = /*@>11d5600*/rtu_target_gains_linear/*@>11d5602*/[/*@>11d55fe*/k];
    /*@>11d3f9e*/rtd_VLSDrv_currentGain/*@>11d35c3*/[/*@>11d3fa0*/k]/*@>11d2ca0*/ = currentgain_0;
    /*@>11d498d*/diff/*@>11d498c*/[/*@>11d498f*/k] = diff_0;
}
/*  unfreeze the gain */
/* '<S1147>:1:69' VLSDrv_Freeze(1) = false; */
*rtd_VLSDrv_Freeze/*@>10bf8b3*/ = /*@>11d3f28*/false;
%closefile cfgTxt
%<cfgTxt>
%assign rtmArgSys = ::CompiledModel.System[::CompiledModel.System[::CompiledModel.RTWCGModules.RTWCGModule[44].CGSystemIdx].NonInlinedParentSystemIdx]
%if SysFcnArgNeeded("Output", rtmArgSys.Interface.RTMArgDef, rtmArgSys.CurrentTID, FcnSysModuleIsRateGrouping(rtmArgSys, "Output"))
%<SLibCG_AccessArg(44, 0, 0)>
%endif
%if SLibCG_ArgAccessed(44, 0, 0)
%<SLibAccessArg(rtmArgSys.Interface.RTMArgDef, "Output", rtmArgSys.CurrentTID, FcnSysModuleIsRateGrouping(rtmArgSys, "Output"))>
%endif
%if (IsModelReferenceBaseSys(rtmArgSys) && (IsModelRefScalableBuild() || GenerateClassInterface)) ||...
(GenerateClassInterface && SLibIsMultiInstanceServer(rtmArgSys))
%<SLibCG_UndoAccessArg(44, 0, 0)>
%endif
%<LibSetSystemField(system, "CachedOutputLocalVars", localVarDecl)>
%endfunction
%function OutputsFcnProtoType(block, system) Output
%assign fcnProtoType = ""
%openfile fcnProtoType
static void Model_Target_control_as(\
%assign comma = ""
%if SLibCG_ArgAccessed(44, 0, 0)
%<comma>%<::tSimStructType> * const %<::tSimStruct>\
%assign comma = ", "
%<SLibUpdateSymbolForFunction("Model_Target_control_as", SLibGetFcnDefinitionRTMSymbolName(), TLC_FALSE)>\
%endif
%<comma>const real32_T rtu_target_gains_linear[12]\
%assign comma = ", "
%<comma>uint32_T rtu_rampRate\
%assign comma = ", "
%<comma>uint32_T rtu_rampTime\
%assign comma = ", "
%<comma>boolean_T *rtd_VLSDrv_Freeze\
%assign comma = ", "
%<comma>real32_T rtd_VLSDrv_currentGain[12]\
%assign comma = ", "
%<comma>int32_T rtd_VLSDrv_frameCount[12]\
%assign comma = ", "
%<comma>real32_T rtd_VLSDrv_rampCoeff[12]\
%assign comma = ", "
%<comma>real32_T rtd_VLSDrv_targetGain[12]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(44, 0, fcnProtoType)>
%endfunction
